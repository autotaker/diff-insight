---
date: '2026-01-17'
permalink: https://github.com/MicrosoftDocs/azure-ai-docs/compare/MicrosoftDocs:a88a880...MicrosoftDocs:7d9d2d5
summary: 今回の変更は、Azure AI Searchに関連するドキュメントに軽微な修正と重要な更新を加え、情報の正確性、最新性、一貫性を向上させることを目的としています。特に、「情報検索における生成強化技術の概要」での大規模な更新により、RAG（生成強化技術）の概念が刷新され、最新の適用例と利点が詳述されています。また、「エージェント取得概説」には新たな使用例が追加され、Azure
  AI Search APIを活用したカスタムエージェントソリューションが紹介されています。その他にも、多数のドキュメントの著者情報や日付の更新、用語の一貫性向上に向けた表現調整が行われています。全体として、これらの変更はAzure
  AI Searchの信頼性とユーザビリティを高め、技術者や開発者がその機能をより効果的に活用できるようにすることを目指しています。
title: Diff Insight Report - search

---

[View Diff on GitHub](https://github.com/MicrosoftDocs/azure-ai-docs/compare/MicrosoftDocs:a88a880...MicrosoftDocs:7d9d2d5){target="_blank"}

# Highlights
今次の変更は、Azure AI Searchに関連する一連のドキュメントに軽微な修正と重要な更新を加えるものであり、特に情報の正確性、最新性、一貫性を高めることを目的としています。一部には「情報検索における生成強化技術の概要」に関するブレイキングチェンジも含まれています。

## New features
- 「エージェント取得概説」の新たな使用例が追加され、Azure AI Search APIを使用したカスタムエージェントソリューションが明らかにされています。

## Breaking changes
- 「情報検索における生成強化技術の概要」に大規模な更新が加えられ、RAG（生成強化技術）の概念が刷新され、最新の適用例と利点が詳細に説明されています。

## Other updates
- 多数のドキュメントに関して、著者情報や日付の更新、軽微な文書の改善が含まれています。
- 「SharePointインデックスされた知識ソース」のクエリプロパティに関する説明が改善され、その実際の用途を明確化しました。
- 用語の一貫性を高めるための表現調整が複数のファイルで行われています。

# Insights
このシリーズの変更は、小規模な文書の改善から大規模な内容の刷新まで、多岐にわたりますが、その主目的はAzure AI Searchに関するドキュメンテーションの信頼性とユーザビリティを向上させることです。

特に「情報検索における生成強化技術の概要」での変更は、利用可能な技術の適用範囲を拡大し、読者がその実際の価値を理解しやすくするものであり、ここでは最新の実装動向に対応するために全体が再構築されています。これによって、エージェントベースの検索手法がより効果的に利用できるようになることが期待されます。

加えて、「エージェント取得概説」などでは新しい使用例が示され、実際の応用例が具体化されました。これにより、ユーザーはAzure AI SearchのAPIがどのように実際のソリューションにインテグレートされうるかをより直感的に理解できます。

また、文書の日付更新や著者情報の変更は、ドキュメントがコンテンツ管理上最新の状態を保つための重要な手段であり、これもドキュメンテーションの質を高める一因です。

これらの変更は、技術者や開発者にとってAzure AI Searchの機能を活用しやすくし、データ取得のプロセスを深く理解するための実用的なガイドとして機能することを目指しています。

# Summary Table
|  Filename  | Type |    Title    | Status | A  | D  | M  |
|------------|------|-------------|--------|----|----|----|
| [agentic-knowledge-source-overview.md](#item-dcf29a) | minor update | エージェント知識ソース概要の更新 | modified | 14 | 14 | 28 | 
| [agentic-retrieval-how-to-create-knowledge-base.md](#item-7df0e2) | minor update | 知識ベース作成ガイドの著者情報の更新 | modified | 3 | 3 | 6 | 
| [agentic-retrieval-how-to-retrieve.md](#item-d739cf) | minor update | エージェント取得ガイドの内容修正 | modified | 17 | 17 | 34 | 
| [agentic-retrieval-overview.md](#item-d1f354) | minor update | エージェント取得概説の更新 | modified | 3 | 1 | 4 | 
| [hybrid-search-overview.md](#item-6987b4) | minor update | ハイブリッド検索の概説更新 | modified | 6 | 6 | 12 | 
| [agentic-knowledge-source-how-to-sharepoint-indexed-csharp.md](#item-2eb305) | minor update | SharePointインデックスされた知識ソースのクエリプロパティの修正 | modified | 1 | 1 | 2 | 
| [agentic-knowledge-source-how-to-sharepoint-indexed-python.md](#item-923abb) | minor update | SharePointインデックスされた知識ソースのクエリプロパティの修正（Python版） | modified | 1 | 1 | 2 | 
| [agentic-knowledge-source-how-to-sharepoint-indexed-rest.md](#item-e26ea0) | minor update | SharePointインデックスされた知識ソースのクエリプロパティの修正（REST API版） | modified | 1 | 1 | 2 | 
| [agentic-retrieval-how-to-create-knowledge-base-csharp.md](#item-4469a2) | minor update | C#における知識ベースの作成手順の更新 | modified | 11 | 9 | 20 | 
| [agentic-retrieval-how-to-create-knowledge-base-python.md](#item-4e498f) | minor update | Pythonにおける知識ベースの作成手順の更新 | modified | 9 | 7 | 16 | 
| [agentic-retrieval-how-to-create-knowledge-base-rest.md](#item-37851c) | minor update | REST APIにおける知識ベースの作成手順の更新 | modified | 12 | 10 | 22 | 
| [retrieval-augmented-generation-overview.md](#item-ec76e0) | breaking change | 情報検索における生成強化技術の概要に関する更新 | modified | 40 | 56 | 96 | 
| [search-security-rbac.md](#item-a5d129) | minor update | Azure AI Searchのロールベースアクセス制御の文書更新 | modified | 47 | 47 | 94 | 
| [semantic-how-to-configure.md](#item-7a92a6) | minor update | セマンティック構成の説明文の修正 | modified | 1 | 1 | 2 | 
| [semantic-search-overview.md](#item-b7497b) | minor update | セマンティック検索の概要に関する文書の修正 | modified | 27 | 27 | 54 | 
| [vector-search-overview.md](#item-56e5fa) | minor update | ベクター検索の概要文書の修正 | modified | 3 | 3 | 6 | 


# Modified Contents
## articles/search/agentic-knowledge-source-overview.md{#item-dcf29a}

<details>
<summary>Diff</summary>
````diff
@@ -7,20 +7,20 @@ author: HeidiSteen
 ms.author: heidist
 ms.service: azure-ai-search
 ms.topic: concept-article
-ms.date: 12/04/2025
+ms.date: 01/15/2026
 ---
 
 # What is a knowledge source?
 
 [!INCLUDE [Feature preview](./includes/previews/preview-generic.md)]
 
-A knowledge source specifies the content used for agentic retrieval. It either encapsulates a search index which is populated by an external data source, or it's a direct connection to a remote source such as Bing or Sharepoint that's queried directly. A knowledge source is a required definition in a knowledge base.
+A knowledge source specifies the content used for agentic retrieval. It either encapsulates a search index populated by external data, or it's a direct connection to a remote target such as Bing or SharePoint that's queried directly. A knowledge source is a required definition in a knowledge base.
 
 + Create a knowledge source as a top-level resource on your search service. Each knowledge source points to exactly one data structure, either a search index that [meets the criteria for agentic retrieval](agentic-retrieval-how-to-create-index.md) or a supported external resource.
 
-+ Reference one or more knowledge sources in a [knowledge base](agentic-retrieval-how-to-create-knowledge-base.md). In an agentic retrieval pipeline, it's possible to query against multiple knowledge sources in a single request. Subqueries are generated for each knowledge source. Top results are returned in the retrieval response.
++ Reference one or more knowledge sources in a [knowledge base](agentic-retrieval-how-to-create-knowledge-base.md). In an agentic retrieval pipeline, you can query against multiple knowledge sources in a single request. Subqueries are generated for each knowledge source. Top results are returned in the retrieval response.
 
-+ For certain knowledge sources, you can use a knowledge source definition to generate a full indexer pipeline (data source, skillset, indexer, and index) that works for agentic retrieval. Instead of creating multiple objects manually, information in the knowledge source is used to generate all objects, including a populated, chunked, and searchable index.
++ For certain knowledge sources, you can use a knowledge source definition to generate a full indexer pipeline (data source, skillset, indexer, and index) that works for agentic retrieval. Instead of creating multiple objects manually, the information in the knowledge source is used to generate all objects, including a populated, chunked, and searchable index.
 
 Make sure you have at least one knowledge source before creating a knowledge base. The full specification of a knowledge source and a knowledge base can be found in the [preview REST API reference](/rest/api/searchservice/operation-groups?view=rest-searchservice-2025-11-01-preview&preserve-view=true).
 
@@ -34,7 +34,7 @@ Make sure you have at least one knowledge source before creating a knowledge bas
 
 ## Supported knowledge sources
 
-Here are the knowledge sources you can create in this preview:
+In this preview, you can create the following knowledge sources:
 
 | Kind | Indexed or remote |
 |------|-------------------|
@@ -45,19 +45,19 @@ Here are the knowledge sources you can create in this preview:
 | [`"remoteSharePoint"` API](/rest/api/searchservice/knowledge-sources/create-or-update?view=rest-searchservice-2025-11-01-preview&preserve-view=true#remotesharepointknowledgesource) retrieves content directly from SharePoint. | Remote |
 |  [`"webParameters"` API](/rest/api/searchservice/knowledge-sources/create-or-update?view=rest-searchservice-2025-11-01-preview&preserve-view=true#webknowledgesource) retrieves real-time grounding data from Microsoft Bing. | Remote |
 
-Indexed knowledge sources point to target index on Azure AI Search and query execution is local to the search engine on your search service. Keyword (full text search), vector, and hybrid query capabilities are used for retrieving data from indexed knowledge sources.
+Indexed knowledge sources point to a target index on Azure AI Search. Query execution is local to the search engine on your search service. Keyword (full text search), vector, and hybrid query capabilities are used for retrieving data from indexed knowledge sources.
 
-Remote knowledge sources are accessed at query time. The agentic retrieval engine calls the retrieval APIs that are native to the platform (Bing or SharePoint APIs).
+You access remote knowledge sources at query time. The agentic retrieval engine calls the retrieval APIs that are native to the platform (Bing or SharePoint APIs).
 
 All retrieved content, whether indexed or remote, is pulled into the ranking pipeline in Azure AI Search where it's scored for relevance, merged (assuming multiple queries), reranked, and returned in the retrieval response. 
 
 ## Creating knowledge sources
 
-Knowledge sources are created as standalone objects and then specified in a [knowledge base](agentic-retrieval-how-to-create-knowledge-base.md) in a ["knowledgeSources" array](/rest/api/searchservice/knowledge-bases/create-or-update?view=rest-searchservice-2025-11-01-preview&preserve-view=true#knowledgesourcereference).
+Create knowledge sources as standalone objects. Then, specify them in a [knowledge base](agentic-retrieval-how-to-create-knowledge-base.md) within a ["knowledgeSources" array](/rest/api/searchservice/knowledge-bases/create-or-update?view=rest-searchservice-2025-11-01-preview&preserve-view=true#knowledgesourcereference).
 
-You must have [**Search Service Contributor** permissions](search-security-rbac.md) to create objects on a search service.  You also need **Search Index Data Contributor** permissions to load an index if you're using a knowledge source that creates an indexer pipeline. Alternatively, you can [use an API admin key](search-security-api-keys.md) instead of roles.
+To create objects on a search service, you need [**Search Service Contributor** permissions](search-security-rbac.md). If you're using a knowledge source that creates an indexer pipeline, you also need **Search Index Data Contributor** permissions to load an index. Alternatively, you can [use an API admin key](search-security-api-keys.md) instead of roles.
 
-You can use the REST API or an Azure SDK preview package to create a knowledge source. Azure portal support is available for select knowledge sources. The following links provide instructions for creating a knowledge source:
+Use the REST API or an Azure SDK preview package to create a knowledge source. Azure portal support is available for select knowledge sources. The following links provide instructions for creating a knowledge source:
 
 + [How to create a search index knowledge source (wraps an existing index)](agentic-knowledge-source-how-to-search-index.md)
 + [How to create a blob knowledge source (generates an indexer pipeline)](agentic-knowledge-source-how-to-blob.md)
@@ -66,11 +66,11 @@ You can use the REST API or an Azure SDK preview package to create a knowledge s
 + [How to create a SharePoint (remote) knowledge source (queries SharePoint directly)](agentic-knowledge-source-how-to-sharepoint-remote.md)
 + [How to create a Web Knowledge Source resource (connects to Bing's public endpoint)](agentic-knowledge-source-how-to-web.md)
 
-After the knowledge source is created, you can reference it in a knowledge base.
+After you create the knowledge source, reference it in a knowledge base.
 
 ## Using knowledge sources
 
-Knowledge source usage is either explicitly controlled, such as when you set `alwaysQuery` on the knowledge source definition, or subject to selection logic during query planning. Query planning occurs when you use a low or medium [retrieval reasoning effort](agentic-retrieval-how-to-set-retrieval-reasoning-effort.md). For a minimal reasoning effort, all knowledge sources listed in the knowledge base are in scope for every query. For low and medium, the knowledge base and the LLM can determine at query time which knowledge sources are likely to provide the best search corpus. 
+You can explicitly control knowledge source usage by setting `alwaysQuery` on the knowledge source definition or through steering instructions used during query planning. Steering instructions refer to descriptions on an index, or explicit retrieval instructions in the knowledge source, that provide guidance on when to use the index. Query planning happens when you use a low or medium [retrieval reasoning effort from the LLM](agentic-retrieval-how-to-set-retrieval-reasoning-effort.md). For a minimal reasoning effort, all knowledge sources listed in the knowledge base are in scope for every query. For low and medium, the knowledge base and the LLM can determine at query time which knowledge sources are likely to provide the best search corpus.  
 
 Knowledge source selection logic is based on these factors:
 
@@ -86,9 +86,9 @@ Knowledge source selection logic is based on these factors:
 
 ### Use a retrieval reasoning effort to control LLM usage
 
-Not all solutions benefit from LLM query planning and execution. If simplicity and speed outweigh the benefits the LLM query planning and context engineering provide, you can specify a minimal reasoning effort to prevent LLM processing in your pipeline.
+Not all solutions benefit from LLM query planning and execution. If simplicity and speed outweigh the benefits the LLM query planning and context engineering provide, specify a minimal reasoning effort to prevent LLM processing in your pipeline.
 
 For low and medium, the level of LLM processing is either a balanced or maximal approach that improves relevance. For more information, see [Set the retrieval reasoning effort](agentic-retrieval-how-to-set-retrieval-reasoning-effort.md).
 
 > [!NOTE]
-> If you used `attemptFastPath` in the previous preview, that approach is now replaced with `retrievalReasoningEffort` set to `minimal`.
+> If you used `attemptFastPath` in the previous preview, that approach is now replaced by `retrievalReasoningEffort` set to `minimal`.
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "エージェント知識ソース概要の更新"
}
```

### Explanation
この変更は、`articles/search/agentic-knowledge-source-overview.md`ファイルにおいて、全体的な文面の調整が行われたもので、特に文章の明確性を高めるためにいくつかの文が修正されています。具体的には、内容がより簡潔で直感的になるように構成されています。

主な修正点としては、定義や説明に関する表現の統一および文法的な改善が含まれており、いくつかの定義や手順に関連する情報の流れがスムーズになっています。例えば、「エージェント検索パイプライン」や「知識ベース」における複数の知識ソースのクエリについての説明が改良されており、ユーザーにとって理解しやすくなっています。また、日付の更新も行われています。このような変更は、文書の最新性を保つためにも重要です。

この改訂内容は、Azure AI Searchに関連する知識ソースの作成や利用方法に関する情報の信頼性と明確さを向上させることを目的としています。

## articles/search/agentic-retrieval-how-to-create-knowledge-base.md{#item-7df0e2}

<details>
<summary>Diff</summary>
````diff
@@ -2,11 +2,11 @@
 title: Create a Knowledge Base
 titleSuffix: Azure AI Search
 description: Learn how to create a knowledge base for agentic retrieval workloads in Azure AI Search.
-author: HeidiSteen
-ms.author: heidist
+author: haileytap
+ms.author: haileytapia
 ms.service: azure-ai-search
 ms.topic: how-to
-ms.date: 12/12/2025
+ms.date: 01/15/2026
 zone_pivot_groups: agentic-retrieval-pivots
 ---
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "知識ベース作成ガイドの著者情報の更新"
}
```

### Explanation
この変更は、`articles/search/agentic-retrieval-how-to-create-knowledge-base.md`ファイルのメタデータに関するもので、著者情報や日付が更新されています。具体的には、著者が「Heidi Steen」から「Hailey Tap」に変更され、これに伴い著者のユーザー名も更新されています。

また、文書の日付も「2025年12月12日」から「2026年1月15日」に変更されており、これによってドキュメントの最新性が保たれています。これらの変更は、ドキュメントの管理において重要であり、正確な情報を提供するために必要です。

全体として、この更新はユーザーが作成するエージェント検索用の知識ベースに関するガイドラインに影響を与えない軽微な変更ですが、著者情報と文書の適切な日付の維持が目的となっています。

## articles/search/agentic-retrieval-how-to-retrieve.md{#item-d739cf}

<details>
<summary>Diff</summary>
````diff
@@ -7,16 +7,16 @@ author: HeidiSteen
 ms.author: heidist
 ms.service: azure-ai-search
 ms.topic: how-to
-ms.date: 12/04/2025
+ms.date: 01/15/2026
 ---
 
-# Retrieve data using a knowledge base in Azure AI Search
+# Retrieve data by using a knowledge base in Azure AI Search
 
 [!INCLUDE [Feature preview](./includes/previews/preview-generic.md)]
 
 In an agentic retrieval multi-query pipeline, query execution is through the [**retrieve action**](/rest/api/searchservice/knowledge-retrieval/retrieve?view=rest-searchservice-2025-11-01-preview&preserve-view=true) on a knowledge base that invokes parallel query processing. This request structure is updated for the new 2025-11-01-preview, which introduces breaking changes from previous previews. For help with breaking changes, see [Migrate your agentic retrieval code](agentic-retrieval-how-to-migrate.md).
 
-This article explains how to set up a retrieve action. It also covers the three components of the retrieval response: 
+This article explains how to set up a retrieve action. It also describes the three components of the retrieval response: 
 
 + *extracted response for the LLM*
 + *referenced results*
@@ -30,7 +30,7 @@ You can also use optional [answer synthesis](agentic-retrieval-how-to-answer-syn
 
 + A [supported knowledge source](agentic-knowledge-source-overview.md#supported-knowledge-sources) that wraps a searchable index or points to an external source for native data retrieval.
 
-+ A [knowledge base](agentic-retrieval-how-to-create-knowledge-base.md) represents one or more knowledge sources, plus a chat completion model if you want intelligent query planning and answer formulation.
++ A [knowledge base](agentic-retrieval-how-to-create-knowledge-base.md) that represents one or more knowledge sources. If you want intelligent query planning and answer formulation, include a chat completion model.
 
 + Azure AI Search in any [region that provides agentic retrieval](search-region-support.md).
 
@@ -42,7 +42,7 @@ To follow the steps in this guide, we recommend [Visual Studio Code](https://cod
 
 ## Set up the retrieve action
 
-A retrieve action is specified on a [knowledge base](agentic-retrieval-how-to-create-knowledge-base.md). The knowledge base has one or more knowledge sources. Retrieval can return a synthesized answer in natural language or raw grounding chunks from the knowledge sources.
+Specify a retrieve action on a [knowledge base](agentic-retrieval-how-to-create-knowledge-base.md). The knowledge base has one or more knowledge sources. Retrieval can return a synthesized answer in natural language or raw grounding chunks from the knowledge sources.
 
 + Review your knowledge base definition to understand which knowledge sources are in scope.
 
@@ -54,9 +54,9 @@ For knowledge sources that have default retrieval instructions, you can override
 
 ### Retrieval from a search index
 
-For knowledge sources that target a search index, all `searchable` fields are in-scope for query execution. If the index includes vector fields, your index should have a valid [vectorizer definition](vector-search-how-to-configure-vectorizer.md) so that the agentic retrieval engine can vectorize the query inputs. Otherwise, vector fields are ignored. The implied query type is `semantic`, and there's no search mode.
+For knowledge sources that target a search index, all `searchable` fields are in scope for query execution. If the index includes vector fields, your index should have a valid [vectorizer definition](vector-search-how-to-configure-vectorizer.md) so that the agentic retrieval engine can vectorize the query inputs. Otherwise, vector fields are ignored. The implied query type is `semantic`, and there's no search mode.
 
-The input for the retrieval route is chat conversation history in natural language, where the `messages` array contains the conversation. Messages are only supported if the [retrieval reasoning effort](agentic-retrieval-how-to-set-retrieval-reasoning-effort.md) is either low or medium.
+The input for the retrieval route is chat conversation history in natural language, where the `messages` array contains the conversation. The agentic retrieval engine supports messages only if the [retrieval reasoning effort](agentic-retrieval-how-to-set-retrieval-reasoning-effort.md) is either low or medium.
 
 ```http
 @search-url=<YOUR SEARCH SERVICE URL>
@@ -96,7 +96,7 @@ POST https://{{search-url}}/knowledgebases/{{knowledge-base-name}}/retrieve?api-
 
 ### Responses
 
-Successful retrieval returns a `200 OK` status code. If the knowledge base fails to retrieve from one or more knowledge sources, a `206 Partial Content` status code is returned, and the response only includes results from sources that succeeded. Details about the partial response appear as [errors in the activity array](#review-the-activity-array).
+Successful retrieval returns a `200 OK` status code. If the knowledge base fails to retrieve from one or more knowledge sources, a `206 Partial Content` status code returns. The response only includes results from sources that succeeded. Details about the partial response appear as [errors in the activity array](#review-the-activity-array).
 
 ### Retrieve parameters
 
@@ -184,7 +184,7 @@ Content-Type: application/json
 
 ### Example: minimal reasoning effort
 
-In this example, there's no chat completion model for intelligent query planning or answer formulation. The query string is passed to the agentic retrieval engine for keyword search or hybrid search.
+In this example, there's no chat completion model for intelligent query planning or answer formulation. The query string goes to the agentic retrieval engine for keyword search or hybrid search.
 
 ```http
 POST {{url}}/knowledgebases/kb-minimal/retrieve?api-version={{api-version}}
@@ -203,9 +203,9 @@ Content-Type: application/json
 
 ## Review the extracted response
 
-The *extracted response* is single unified string that's typically passed to an LLM that consumes it as grounding data, using it to formulate a response. Your API call to the LLM includes the unified string and instructions for model, such as whether to use the grounding exclusively or as a supplement.
+The *extracted response* is a single unified string that you typically pass to an LLM. The LLM consumes it as grounding data and uses it to formulate a response. Your API call to the LLM includes the unified string and instructions for the model, such as whether to use the grounding exclusively or as a supplement.
 
-The body of the response is also structured in the chat message style format. Currently in this preview release, the content is serialized JSON.
+The body of the response is also structured in the chat message style format. Currently, in this preview release, the content is serialized JSON.
 
 ```http
 "response": [
@@ -225,9 +225,9 @@ The body of the response is also structured in the chat message style format. Cu
 
 + `content.text` is a JSON array. It's a single string composed of the most relevant documents (or chunks) found in the search index, given the query and chat history inputs. This array is your grounding data that a chat completion model uses to formulate a response to the user's question.
 
-  This portion of the response consists of the 200 chunks or less, excluding any results that fail to meet the minimum threshold of a 2.5 reranker score.
+  This portion of the response consists of 200 chunks or fewer, excluding any results that fail to meet the minimum threshold of a 2.5 reranker score.
 
-  The string starts with the reference ID of the chunk (used for citation purposes), and any fields specified in the semantic configuration of the target index. In this example, you should assume the semantic configuration in the target index has a "title" field, a "terms" field, and a "content" field.
+  The string starts with the reference ID of the chunk (used for citation purposes), and any fields specified in the semantic configuration of the target index. In this example, assume the semantic configuration in the target index has a "title" field, a "terms" field, and a "content" field.
 
 + `content.type` has one valid value in this preview: `text`. 
 
@@ -247,9 +247,9 @@ The output includes the following components.
 | agenticReasoningEffort | For each retrieve action, you can specify the degree of LLM support. Use minimal to bypass an LLM, low for constrained LLM processing, and medium for full LLM processing. | 
 | modelAnswerSynthesis | For knowledge bases that specify answer formulation, this section reports on the token count for formulating the answer, and the token count of the answer output. |
 
-Output reports on the token consumption for agentic reasoning during retrieval at the specified [retrieval reasoning effort](agentic-retrieval-how-to-set-retrieval-reasoning-effort.md).
+The output reports on the token consumption for agentic reasoning during retrieval at the specified [retrieval reasoning effort](agentic-retrieval-how-to-set-retrieval-reasoning-effort.md).
 
-Output also includes the following information:
+The output also includes the following information:
 
 + Subqueries sent to the retrieval pipeline.
 + Errors for any retrieval failures, such as inaccessible knowledge sources.
@@ -316,9 +316,9 @@ Here's an example of an activity array.
 
 ## Review the references array
 
-The `references` array is a direct reference from the underlying grounding data and includes the `sourceData` used to generate the response. It consists of every single document that was found and semantically ranked by the agentic retrieval engine. Fields in the `sourceData` include an `id` and semantic fields: `title`, `terms`, `content`.
+The `references` array comes directly from the underlying grounding data. It includes the `sourceData` used to generate the response. It consists of every document that the agentic retrieval engine finds and semantically ranks. Fields in the `sourceData` include an `id` and semantic fields: `title`, `terms`, and `content`.
 
-The `id` is a reference ID for an item within a specific response. It's not the document key in the search index. It's used for providing citations.
+The `id` acts as a reference ID for an item within a specific response. It's not the document key in the search index. You use it for providing citations.
 
 The purpose of this array is to provide a chat message style structure for easy integration. For example, if you want to serialize the results into a different structure or you require some programmatic manipulation of the data before you returned it to the user.
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "エージェント取得ガイドの内容修正"
}
```

### Explanation
この変更は、`articles/search/agentic-retrieval-how-to-retrieve.md`ファイルの内容に対する軽微な修正を行い、全体的な明確さを向上させることを目的としています。具体的には、文の表現を改善するために使われる語句の調整が行われています。

主な修正点には、以下のような内容があります：
- タイトルやセクション見出しの表現が若干修正され、文書の一貫性が向上しています。
- 一部の説明で「説明する」という語が使用され、より正確なメッセージを伝えるための表現が強調されています。
- 知識ソースや知識ベースに関する説明が明確にされ、読者が理解しやすくなるように配慮されています。

全体として、これらの変更はユーザーがエージェントベースのデータ取得プロセスを理解しやすくするためのものであり、専門的な内容をよりアクセスしやすい形で提供することを目的としています。また、日付情報も更新されており、文書の新しさを保つことにも寄与しています。

## articles/search/agentic-retrieval-overview.md{#item-d1f354}

<details>
<summary>Diff</summary>
````diff
@@ -5,7 +5,7 @@ description: Learn about agentic retrieval concepts, architecture, and use cases
 author: HeidiSteen
 ms.author: heidist
 manager: nitinme
-ms.date: 12/04/2025
+ms.date: 01/16/2026
 ms.service: azure-ai-search
 ms.topic: concept-article
 ms.custom:
@@ -35,6 +35,8 @@ Programmatically, agentic retrieval is supported through a new [Knowledge Base o
 
 ## Why use agentic retrieval
 
+There are two use cases for agentic retrieval. First, it's the basis of the [Foundry IQ experience](/azure/ai-foundry/agents/how-to/tools/knowledge-retrieval) in the Microsoft Foundry (new) portal. It provides the knowledge layer for agent solutions in Microsoft Foundry. Second, it's the basis for custom agentic solutions that you create using the Azure AI Search APIs.
+
 You should use agentic retrieval when you want to provide agents and apps with the most relevant content for answering harder questions, leveraging chat context and your proprietary content.
 
 The *agentic* aspect is a reasoning step in query planning processing that's performed by a supported large language model (LLM) that you provide. The LLM analyzes the entire chat thread to identify the underlying information need. Instead of a single, catch-all query, the LLM breaks down compound questions into focused subqueries based on: user questions, chat history, and parameters on the request. The subqueries target your indexed documents (plain text and vectors) in Azure AI Search. This hybrid approach ensures you surface both keyword matches and semantic similarities at once, dramatically improving recall. 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "エージェント取得概説の更新"
}
```

### Explanation
この変更は、`articles/search/agentic-retrieval-overview.md`ファイルの内容に対する軽微な修正を行い、全体的な理解を助けるためのアップデートです。具体的には、文書の日付が「2025年12月4日」から「2026年1月16日」に変更され、最新の情報を反映しています。

さらに、エージェント取得の用途に関するセクションに新たに２つの使用例が追加されています。これらの例は、Microsoft Foundryポータルにおける「Foundry IQ体験」を基盤としていること、また、Azure AI Search APIを使用して作成したカスタムエージェントソリューションの基盤となっていることを説明しています。この2つの追加情報により、エージェント取得の重要性と適用可能性が強調されています。

全体として、この更新はエージェント取得に関する概念、アーキテクチャ、およびユースケースをより明確にすることを目的とし、利用者がこの技術をより理解しやすくなるように設計されています。

## articles/search/hybrid-search-overview.md{#item-6987b4}

<details>
<summary>Diff</summary>
````diff
@@ -13,17 +13,17 @@ ms.date: 11/21/2025
 
 # Hybrid search using vectors and full text in Azure AI Search
 
-A hybrid search is a single query request configured for both full-text and vector queries. It executes against a search index that contains searchable, plain-text content and generated embeddings. For query purposes, hybrid search:
+Hybrid search is a single query request configured for both full-text and vector queries. It runs against a search index that contains searchable, plain-text content and generated embeddings. For query purposes, hybrid search:
 
 + Is a single query request that includes both `search` and `vectors` query parameters.
-+ Executes full-text search and vector search in parallel.
-+ Merges results from each query using [Reciprocal Rank Fusion (RRF)](hybrid-search-ranking.md).
++ Runs full-text search and vector search in parallel.
++ Merges results from each query by using [Reciprocal Rank Fusion (RRF)](hybrid-search-ranking.md).
 
 This article explains the concepts, benefits, and limitations of hybrid search. Links at the end provide usage instructions and next steps. You can also watch the [embedded video](#why-use-hybrid-search) for an explanation of how hybrid retrieval contributes to high-quality generative search applications.
 
 ## Why use hybrid search?
 
-Hybrid search combines the strengths of vector search and keyword search. The advantage of vector search is finding information that's conceptually similar to your search query, even if there are no keyword matches in the inverted index. The advantage of keyword or full-text search is precision, with the ability to apply optional semantic ranking that improves the quality of the initial results. Some scenarios, such as querying over product codes, highly specialized jargon, dates, and people's names, can perform better with keyword search because it can identify exact matches.
+Hybrid search combines the strengths of vector search and keyword search. The advantage of vector search is finding information that's conceptually similar to your search query, even if there are no keyword matches in the inverted index. The advantage of keyword or full-text search is precision, with the ability to apply optional semantic ranking that improves the quality of the initial results. Some scenarios, such as querying over product codes, highly specialized jargon, dates, and people's names, perform better with keyword search because it can identify exact matches.
 
 Benchmark testing on real-world and benchmark datasets indicates that hybrid retrieval with semantic ranker offers significant benefits in search relevance.
 
@@ -33,7 +33,7 @@ The following video explains how hybrid retrieval gives you optimal grounding da
 
 ## How does hybrid search work?
 
-In a search index, vector fields containing embeddings coexist with textual and numerical fields, allowing you to formulate hybrid queries that execute simultaneously. Hybrid queries take advantage of existing text-based functionality like filtering, faceting, sorting, scoring profiles, and [semantic ranking](semantic-search-overview.md) on your text fields, while executing a similarity search against vectors in a single search request.
+In a search index, vector fields containing embeddings coexist with textual and numerical fields. You can formulate hybrid queries that execute simultaneously. Hybrid queries take advantage of existing text-based functionality like filtering, faceting, sorting, scoring profiles, and [semantic ranking](semantic-search-overview.md) on your text fields, while executing a similarity search against vectors in a single search request.
 
 Hybrid search combines results from both full-text and vector queries, which use different ranking functions such as BM25 for text, and Hierarchical Navigable Small World (HNSW) and exhaustive K Nearest Neighbors (eKNN) for vectors. An [RRF](hybrid-search-ranking.md) algorithm merges the results. The query response provides just one result set, using RRF to rank the unified results.
 
@@ -83,7 +83,7 @@ content-type: application/JSON
 **Key points:**
 
 + `search` specifies a single full-text search query.
-+ `vectorQueries` specifies vector queries, which can be multiple, targeting multiple vector fields. If the embedding space includes multi-lingual content, vector queries can find the match with no language analyzers or translation required. If you're using semantic ranker, set `k` to 50 to maximize its inputs.
++ `vectorQueries` specifies vector queries, which can be multiple, targeting multiple vector fields. If the embedding space includes multilingual content, vector queries can find the match with no language analyzers or translation required. If you're using semantic ranker, set `k` to 50 to maximize its inputs.
 + `select` specifies which fields to return in results, which should be human-readable text fields if you're showing them to users or sending them to a large language model (LLM).
 + `filters` can specify geospatial search or other inclusion and exclusion criteria, such as whether parking is included. The geospatial query in this example finds hotels within a 300-kilometer radius of Washington D.C. You can apply the filter at the beginning or end of query processing. If you're using semantic ranker, you probably want post-filtering as the last step, but you should test to confirm which behavior is best for your queries.
 + `facets` can be used to compute facet buckets over results that are returned from hybrid queries.
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "ハイブリッド検索の概説更新"
}
```

### Explanation
この変更は、`articles/search/hybrid-search-overview.md`ファイルの内容に対する軽微な修正を行い、文書の明確性を向上させることを目的としています。具体的には、ハイブリッド検索の定義や動作に関する表現が更新され、一貫性を保つためにいくつかの文が再構成されています。

主な修正内容は以下の通りです：
- ハイブリッド検索がフルテキスト検索とベクトル検索の両方を対象とした単一のクエリリクエストであることに関連する文が改善され、説明がより自然になりました。
- ハイブリッド検索を使用する利点が強調され、特に正確さやセマンティックランクを適用する能力についての情報がクリアに伝わるように表現が調整されています。
- クエリの具体例や使用法がさらにわかりやすくなり、特に多言語コンテンツやフィルタリング機能に関する情報が明確に説明されています。

全体として、これらの変更はハイブリッド検索の概念、機能、及びその利点を強調し、読者に対してこの技術の使用方法をより理解しやすく提供することを目指しています。

## articles/search/includes/how-tos/agentic-knowledge-source-how-to-sharepoint-indexed-csharp.md{#item-2eb305}

<details>
<summary>Diff</summary>
````diff
@@ -151,7 +151,7 @@ You can pass the following properties to create an indexed SharePoint knowledge
 | `IndexedSharePointKnowledgeSourceParameters` | Parameters specific to indexed SharePoint knowledge sources: `connectionString`, `containerName`, and `query`. | Object | No | No |
 | `connectionString` | The connection string to a SharePoint site. For more information, see [Connection string syntax](../../search-how-to-index-sharepoint-online.md#connection-string-format). | String | Yes | Yes |
 | `containerName` | The SharePoint library to access. Use `defaultSiteLibrary` to index content from the site's default document library or `allSiteLibraries` to index content from every document library in the site. Ignore `useQuery` for now. | String | No | Yes |
-| `query` | Ignore for now. | String | Yes | No |
+| `query` | Optional [query](../../search-how-to-index-sharepoint-online.md#query) to filter SharePoint content. | String | Yes | No |
 
 ### `ingestion_parameters` properties
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "SharePointインデックスされた知識ソースのクエリプロパティの修正"
}
```

### Explanation
この変更は、`articles/search/includes/how-tos/agentic-knowledge-source-how-to-sharepoint-indexed-csharp.md`ファイル内の内容に対する小規模な修正で、SharePointに関連する知識ソースのクエリプロパティの説明を改善しています。

具体的には、`query`プロパティに関する説明が変更されました。以前は「無視してください」という文言が使用されていましたが、実際にはこのプロパティがSharePointコンテンツをフィルタリングするためのオプションのクエリを提供することを明確に示す内容にアップデートされています。この変更により、ユーザーは`query`プロパティの実際の用途と重要性を理解しやすくなります。

全体として、この修正はドキュメントの正確性を向上させ、利用者がSharePointのインデックスされた知識源を利用する際の理解を深めることを目的としています。

## articles/search/includes/how-tos/agentic-knowledge-source-how-to-sharepoint-indexed-python.md{#item-923abb}

<details>
<summary>Diff</summary>
````diff
@@ -140,7 +140,7 @@ You can pass the following properties to create an indexed SharePoint knowledge
 | `indexed_share_point_parameters` | Parameters specific to indexed SharePoint knowledge sources: `connection_string`, `container_name`, and `query`. | Object | No | No |
 | `connection_string` | The connection string to a SharePoint site. For more information, see [Connection string syntax](../../search-how-to-index-sharepoint-online.md#connection-string-format). | String | Yes | Yes |
 | `container_name` | The SharePoint library to access. Use `defaultSiteLibrary` to index content from the site's default document library or `allSiteLibraries` to index content from every document library in the site. Ignore `useQuery` for now. | String | No | Yes |
-| `query` | Ignore for now. | String | Yes | No |
+| `query` | Optional [query](../../search-how-to-index-sharepoint-online.md#query) to filter SharePoint content. | String | Yes | No |
 
 ### `ingestion_parameters` properties
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "SharePointインデックスされた知識ソースのクエリプロパティの修正（Python版）"
}
```

### Explanation
この変更は、`articles/search/includes/how-tos/agentic-knowledge-source-how-to-sharepoint-indexed-python.md`ファイル内の内容に対する小規模な修正で、SharePointに関連する知識ソースのクエリプロパティの説明を改善しています。

具体的には、`query`プロパティに関する説明が更新されました。以前の記述では「無視してください」とされていた部分が、実際にはこのプロパティがSharePointコンテンツをフィルタリングするためのオプションのクエリであることを明示する内容に変更されています。この修正により、ユーザーは`query`プロパティの実際の用途をより理解しやすくなります。

全体として、この修正はドキュメントの正確性を向上させ、利用者がSharePointのインデックスされた知識源を操作する際の理解を深めることを目的としています。

## articles/search/includes/how-tos/agentic-knowledge-source-how-to-sharepoint-indexed-rest.md{#item-e26ea0}

<details>
<summary>Diff</summary>
````diff
@@ -136,7 +136,7 @@ You can pass the following properties to create an indexed SharePoint knowledge
 | `indexedSharePointParameters` | Parameters specific to indexed SharePoint knowledge sources: `connectionString`, `containerName`, and `query`. | Object | No | Yes |
 | `connectionString` | The connection string to a SharePoint site. For more information, see [Connection string syntax](../../search-how-to-index-sharepoint-online.md#connection-string-format). | String | Yes |No |
 | `container_name` | The SharePoint library to access. Use `defaultSiteLibrary` to index content from the site's default document library or `allSiteLibraries` to index content from every document library in the site. Ignore `useQuery` for now. | String | No | Yes |
-| `query` | Ignore for now. | String | Yes | No |
+| `query` | Optional [query](../../search-how-to-index-sharepoint-online.md#query) to filter SharePoint content. | String | Yes | No |
 
 ### `ingestionParameters` properties
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "SharePointインデックスされた知識ソースのクエリプロパティの修正（REST API版）"
}
```

### Explanation
この変更は、`articles/search/includes/how-tos/agentic-knowledge-source-how-to-sharepoint-indexed-rest.md`ファイル内で行われた小規模な修正で、SharePointに関連する知識ソースの`query`プロパティの説明を改善しています。

具体的には、`query`プロパティに関する説明が以前の「無視してください」という文言から更新され、実際にはこのプロパティがSharePointコンテンツをフィルタリングするためのオプションのクエリであることが明示されています。この変更により、ユーザーは`query`プロパティの正確な役割と重要性を理解しやすくなります。

全体として、この修正はドキュメントの内容を明確にし、利用者がSharePointのインデックスされた知識源を使用する際の理解を増進することを目的としています。

## articles/search/includes/how-tos/agentic-retrieval-how-to-create-knowledge-base-csharp.md{#item-4469a2}

<details>
<summary>Diff</summary>
````diff
@@ -4,13 +4,15 @@ author: haileytap
 ms.author: haileytapia
 ms.service: azure-ai-search
 ms.topic: include
-ms.date: 11/19/2025
+ms.date: 01/15/2026
 ---
 
 [!INCLUDE [Feature preview](../previews/preview-generic.md)]
 
 In Azure AI Search, a *knowledge base* is a top-level object that orchestrates [agentic retrieval](../../agentic-retrieval-overview.md). It defines which knowledge sources to query and the default behavior for retrieval operations. At query time, the [retrieve method](../../agentic-retrieval-how-to-retrieve.md) targets the knowledge base to run the configured retrieval pipeline.
 
+You can create a knowledge base in a [Foundry IQ workload](/azure/ai-foundry/agents/how-to/tools/knowledge-retrieval) in the Microsoft Foundry (new) portal. You also need a knowledge base in any agentic solutions that you create using the Azure AI Search APIs.
+
 A knowledge base specifies:
 
 + One or more knowledge sources that point to searchable content.
@@ -50,7 +52,7 @@ Use one of the following LLMs from Azure OpenAI or an equivalent open-source mod
 
 ## Configure access
 
-Azure AI Search needs access to the LLM from Azure OpenAI. We recommend Microsoft Entra ID for authentication and role-based access for authorization. You must be an **Owner or User Access Administrator** to assign roles. If roles aren't feasible, use key-based authentication instead.
+Azure AI Search needs access to the LLM from Azure OpenAI. We recommend Microsoft Entra ID for authentication and role-based access for authorization. To assign roles, you must be an **Owner or User Access Administrator**. If you can't use roles, use key-based authentication instead.
 
 ### [**Use roles**](#tab/rbac)
 
@@ -71,7 +73,7 @@ Azure AI Search needs access to the LLM from Azure OpenAI. We recommend Microsof
 
 1. [Copy an Azure AI Search admin API key](../../search-security-api-keys.md#find-existing-keys) from the Azure portal.
 
-1. Use `AzureKeyCredential` to specify the API key in each request, which should look similar to the following example:
+1. Use `AzureKeyCredential` to specify the API key in each request. Your code should look similar to the following example:
 
     ```csharp
     using Azure.Search.Documents.Indexes;
@@ -87,7 +89,7 @@ Azure AI Search needs access to the LLM from Azure OpenAI. We recommend Microsof
 
 ## Check for existing knowledge bases
 
-Knowing about existing knowledge bases is helpful for either reuse or naming new objects. Any 2025-08-01-preview knowledge agents are returned in the knowledge bases collection.
+Knowing about existing knowledge bases is helpful for either reusing them or naming new objects. Any 2025-08-01-preview knowledge agents are returned in the knowledge bases collection.
 
 Run the following code to list existing knowledge bases by name.
 
@@ -151,7 +153,7 @@ The following JSON is an example of a knowledge base.
 
 ## Create a knowledge base
 
-A knowledge base drives the agentic retrieval pipeline. In application code, it's called by other agents or chatbots.
+A knowledge base drives the agentic retrieval pipeline. In application code, other agents or chatbots call it.
 
 A knowledge base connects knowledge sources (searchable content) to an LLM deployment from Azure OpenAI. Properties on the LLM establish the connection, while properties on the knowledge source establish defaults that inform query execution and the response.
 
@@ -216,17 +218,17 @@ Console.WriteLine($"Knowledge base '{knowledgeBase.Name}' created or updated suc
 
 ### Knowledge base properties
 
-You can pass the following properties to create a knowledge base.
+Pass the following properties to create a knowledge base.
 
 | Name | Description | Type | Required |
 |--|--|--|--|
-| `name` | The name of the knowledge base, which must be unique within the knowledge bases collection and follow the [naming guidelines](/rest/api/searchservice/naming-rules) for objects in Azure AI Search. | String | Yes |
+| `name` | The name of the knowledge base. It must be unique within the knowledge bases collection and follow the [naming guidelines](/rest/api/searchservice/naming-rules) for objects in Azure AI Search. | String | Yes |
 | `knowledgeSources` | One or more [supported knowledge sources](../../agentic-knowledge-source-overview.md#supported-knowledge-sources). | Array | Yes |
 | `Description` | A description of the knowledge base. The LLM uses the description to inform query planning. | String | No |
-| `RetrievalInstructions` | A prompt for the LLM to determine whether a knowledge source should be in scope for a query, which is recommended when you have multiple knowledge sources. This field influences both knowledge source selection and query formulation. For example, instructions could append information or prioritize a knowledge source. Instructions are passed directly to the LLM, which means it's possible to provide instructions that break query planning, such as instructions that result in bypassing an essential knowledge source. | String | Yes |
+| `RetrievalInstructions` | A prompt for the LLM to determine whether a knowledge source should be in scope for a query. Include this prompt when you have multiple knowledge sources. This field influences both knowledge source selection and query formulation. For example, instructions could append information or prioritize a knowledge source. Instructions are passed directly to the LLM, which means it's possible to provide instructions that break query planning, such as instructions that result in bypassing an essential knowledge source. | String | Yes |
 | `AnswerInstructions` | Custom instructions to shape synthesized answers. The default is null. For more information, see [Use answer synthesis for citation-backed responses](../../agentic-retrieval-how-to-answer-synthesis.md). | String | Yes |
 | `OutputMode` | Valid values are `AnswerSynthesis` for an LLM-formulated answer or `ExtractedData` for full search results that you can pass to an LLM as a downstream step. | String | Yes |
-| `Models` | A connection to a [supported LLM](#supported-models) used for answer formulation or query planning. In this preview, `Models` can contain just one model, and the model provider must be Azure OpenAI. Obtain model information from the Foundry portal or a command-line request. Provide the parameters using the [KnowledgeBaseAzureOpenAIModel class](/dotnet/api/azure.search.documents.indexes.models.knowledgebaseazureopenaimodel?view=azure-dotnet-preview). You can use role-based access control instead of API keys for the Azure AI Search connection to the model. For more information, see [How to deploy Azure OpenAI models with Foundry](/azure/ai-foundry/how-to/deploy-models-openai). | Object | No |
+| `Models` | A connection to a [supported LLM](#supported-models) used for answer formulation or query planning. In this preview, `Models` can contain just one model, and the model provider must be Azure OpenAI. Obtain model information from the Foundry portal or a command-line request. Provide the parameters by using the [KnowledgeBaseAzureOpenAIModel class](/dotnet/api/azure.search.documents.indexes.models.knowledgebaseazureopenaimodel?view=azure-dotnet-preview&preserve-view=true). You can use role-based access control instead of API keys for the Azure AI Search connection to the model. For more information, see [How to deploy Azure OpenAI models with Foundry](/azure/ai-foundry/how-to/deploy-models-openai). | Object | No |
 | `RetrievalReasoningEffort` | Determines the level of LLM-related query processing. Valid values are `minimal`, `low` (default), and `medium`. For more information, see [Set the retrieval reasoning effort](../../agentic-retrieval-how-to-set-retrieval-reasoning-effort.md). | Object | No |
 
 ## Query a knowledge base
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "C#における知識ベースの作成手順の更新"
}
```

### Explanation
この変更は、`articles/search/includes/how-tos/agentic-retrieval-how-to-create-knowledge-base-csharp.md`ファイルに対する小規模な修正で、C#を使用してAzure AI Searchの知識ベースを作成する手順を更新しています。

具体的には、以下の点が変更されています：

1. **日付の更新**: ドキュメントの日付が2025年11月19日から2026年1月15日に更新されています。
2. **新しい情報の追加**: 知識ベースをMicrosoft FoundryポータルのFoundry IQワークロードで作成できることや、知識ベースがAzure AI Search APIsを使用するエージェントソリューションに必要であることが説明に追加されました。
3. **内容の明確化**: 一部の文言が明確にされ、使い方の説明が改善されました。例えば、APIキーの指定方法や知識ベースの役割に関する表現が変更されています。

全体として、この修正はドキュメントの精度を向上させ、ユーザーがAzure AI Searchの知識ベースを効果的に作成・使用する手助けをすることを目的としています。

## articles/search/includes/how-tos/agentic-retrieval-how-to-create-knowledge-base-python.md{#item-4e498f}

<details>
<summary>Diff</summary>
````diff
@@ -4,13 +4,15 @@ author: haileytap
 ms.author: haileytapia
 ms.service: azure-ai-search
 ms.topic: include
-ms.date: 12/12/2025
+ms.date: 01/15/2026
 ---
 
 [!INCLUDE [Feature preview](../previews/preview-generic.md)]
 
 In Azure AI Search, a *knowledge base* is a top-level object that orchestrates [agentic retrieval](../../agentic-retrieval-overview.md). It defines which knowledge sources to query and the default behavior for retrieval operations. At query time, the [retrieve method](../../agentic-retrieval-how-to-retrieve.md) targets the knowledge base to run the configured retrieval pipeline.
 
+You can create a knowledge base in a [Foundry IQ workload](/azure/ai-foundry/agents/how-to/tools/knowledge-retrieval) in the Microsoft Foundry (new) portal. You also need a knowledge base in any agentic solutions that you create using the Azure AI Search APIs.
+
 A knowledge base specifies:
 
 + One or more knowledge sources that point to searchable content.
@@ -70,7 +72,7 @@ Azure AI Search needs access to the LLM from Azure OpenAI. We recommend Microsof
 
 1. [Copy an Azure AI Search admin API key](../../search-security-api-keys.md#find-existing-keys) from the Azure portal.
 
-1. Use `AzureKeyCredential` to specify the API key in each request, which should look similar to the following example:
+1. Use `AzureKeyCredential` to specify the API key in each request. Your code should look similar to the following example:
 
     ```python
     # Authenticate using keys
@@ -141,7 +143,7 @@ The following JSON is an example response for a knowledge base.
 
 ## Create a knowledge base
 
-A knowledge base drives the agentic retrieval pipeline. In application code, it's called by other agents or chatbots.
+A knowledge base drives the agentic retrieval pipeline. In application code, other agents or chatbots call it.
 
 A knowledge base connects knowledge sources (searchable content) to an LLM deployment from Azure OpenAI. Properties on the LLM establish the connection, while properties on the knowledge source establish defaults that inform query execution and the response.
 
@@ -183,13 +185,13 @@ print(f"Knowledge base '{knowledge_base.name}' created or updated successfully."
 
 ### Knowledge base properties
 
-You can pass the following properties to create a knowledge base.
+Pass the following properties to create a knowledge base.
 
 | Name | Description | Type | Required |
 |--|--|--|--|
-| `name` | The name of the knowledge base, which must be unique within the knowledge bases collection and follow the [naming guidelines](/rest/api/searchservice/naming-rules) for objects in Azure AI Search. | String | Yes |
+| `name` | The name of the knowledge base. It must be unique within the knowledge bases collection and follow the [naming guidelines](/rest/api/searchservice/naming-rules) for objects in Azure AI Search. | String | Yes |
 | `description` | A description of the knowledge base. The LLM uses the description to inform query planning. | String | No |
-| `retrieval_instructions` | A prompt for the LLM to determine whether a knowledge source should be in scope for a query, which is recommended when you have multiple knowledge sources. This field influences both knowledge source selection and query formulation. For example, instructions could append information or prioritize a knowledge source. Instructions are passed directly to the LLM, which means it's possible to provide instructions that break query planning, such as instructions that result in bypassing an essential knowledge source. | String | Yes |
+| `retrieval_instructions` | A prompt for the LLM to determine whether a knowledge source should be in scope for a query. Include this prompt when you have multiple knowledge sources. This field influences both knowledge source selection and query formulation. For example, instructions could append information or prioritize a knowledge source. Pass instructions directly to the LLM. It's possible to provide instructions that break query planning, such as instructions that result in bypassing an essential knowledge source. | String | Yes |
 | `answer_instructions` | Custom instructions to shape synthesized answers. The default is null. For more information, see [Use answer synthesis for citation-backed responses](../../agentic-retrieval-how-to-answer-synthesis.md). | String | Yes |
 | `output_mode` | Valid values are `answer_synthesis` for an LLM-formulated answer or `extracted_data` for full search results that you can pass to an LLM as a downstream step. | String | Yes |
 | `knowledge_sources` | One or more [supported knowledge sources](../../agentic-knowledge-source-overview.md#supported-knowledge-sources). | Array | Yes |
@@ -239,7 +241,7 @@ print(result.response[0].content[0].text)
 
 **Key points:**
 
-+ [`messages`](/rest/api/searchservice/knowledge-retrieval/retrieve?view=rest-searchservice-2025-11-01-preview#knowledgeagentmessage&preserve-view=true) is required, but you can run this example using just the `user` role that provides the query.
++ [`messages`](/rest/api/searchservice/knowledge-retrieval/retrieve?view=rest-searchservice-2025-11-01-preview#knowledgeagentmessage&preserve-view=true) is required, but you can run this example by using just the `user` role that provides the query.
 
 + [`knowledge_source_params`](/rest/api/searchservice/knowledge-retrieval/retrieve?view=rest-searchservice-2025-11-01-preview#searchindexknowledgesourceparams&preserve-view=true) specifies one or more query targets. For each knowledge source, you can specify how much information to include in the output.
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "Pythonにおける知識ベースの作成手順の更新"
}
```

### Explanation
この変更は、`articles/search/includes/how-tos/agentic-retrieval-how-to-create-knowledge-base-python.md`ファイルに対して行われた小規模な修正で、Pythonを使用してAzure AI Searchの知識ベースを作成する手順を更新しています。

具体的な変更点は以下の通りです：

1. **日付の更新**: ドキュメントの日付が2025年12月12日から2026年1月15日に変更されています。
2. **新しい情報の追加**: 知識ベースをMicrosoft FoundryポータルのFoundry IQワークロードで作成できることや、Azure AI Search APIsを使用するエージェントソリューションには知識ベースが必要であることが新たに加えられています。
3. **内容の具体化**: APIキーの指定方法や知識ベースの説明が明確化され、特定の文言が改善されています。例えば、参照するエージェントからの呼び出し方や複数の知識ソースを扱う際の扱いについて、文章がより明瞭になっています。

全体として、この修正はドキュメントの明確性を向上させ、Azure AI Searchの知識ベースをPythonで効果的に作成・利用する手助けをすることを目的としています。

## articles/search/includes/how-tos/agentic-retrieval-how-to-create-knowledge-base-rest.md{#item-37851c}

<details>
<summary>Diff</summary>
````diff
@@ -4,13 +4,15 @@ author: heidisteen
 ms.author: heidist
 ms.service: azure-ai-search
 ms.topic: include
-ms.date: 11/14/2025
+ms.date: 01/15/2026
 ---
 
 [!INCLUDE [Feature preview](../previews/preview-generic.md)]
 
 In Azure AI Search, a *knowledge base* is a top-level object that orchestrates [agentic retrieval](../../agentic-retrieval-overview.md). It defines which knowledge sources to query and the default behavior for retrieval operations. At query time, the [retrieve method](../../agentic-retrieval-how-to-retrieve.md) targets the knowledge base to run the configured retrieval pipeline.
 
+You can create a knowledge base in a [Foundry IQ workload](/azure/ai-foundry/agents/how-to/tools/knowledge-retrieval) in the Microsoft Foundry (new) portal. You also need a knowledge base in any agentic solutions that you create using the Azure AI Search APIs.
+
 A knowledge base specifies:
 
 + One or more knowledge sources that point to searchable content.
@@ -31,7 +33,7 @@ After you create a knowledge base, you can update its properties at any time. If
 
 + One or more [knowledge sources](../../agentic-knowledge-source-overview.md#supported-knowledge-sources) on your search service.
 
-+ Permission to create and use objects on Azure AI Search. We recommend [role-based access](../../search-security-rbac.md). **Search Service Contributor** can create and manage a knowledge base. **Search Index Data Reader** can run queries. Alternatively, you can use [API keys](../../search-security-api-keys.md) if a role assignment isn't feasible. For more information, see [Connect to a search service](../../search-get-started-rbac.md)
++ Permission to create and use objects on Azure AI Search. We recommend [role-based access](../../search-security-rbac.md). **Search Service Contributor** can create and manage a knowledge base. **Search Index Data Reader** can run queries. Alternatively, you can use [API keys](../../search-security-api-keys.md) if a role assignment isn't feasible. For more information, see [Connect to a search service](../../search-get-started-rbac.md).
 
 + The latest preview version of the [`Azure.Search.Documents` client library](https://www.nuget.org/packages/Azure.Search.Documents/11.8.0-beta.1) for the .NET SDK.
 
@@ -50,7 +52,7 @@ Use one of the following LLMs from Azure OpenAI or an equivalent open-source mod
 
 ## Configure access
 
-Azure AI Search needs access to the LLM from Azure OpenAI. We recommend Microsoft Entra ID for authentication and role-based access for authorization. You must be an **Owner or User Access Administrator** to assign roles. If roles aren't feasible, use key-based authentication instead.
+Azure AI Search needs access to the LLM from Azure OpenAI. We recommend Microsoft Entra ID for authentication and role-based access for authorization. To assign roles, you must be an **Owner or User Access Administrator**. If you can't use roles, use key-based authentication instead.
 
 ### [**Use roles**](#tab/rbac)
 
@@ -71,7 +73,7 @@ Azure AI Search needs access to the LLM from Azure OpenAI. We recommend Microsof
 
 1. [Copy an Azure AI Search admin API key](../../search-security-api-keys.md#find-existing-keys) from the Azure portal.
 
-1. Specify the API key in each request, which should look similar to the following example:
+1. Specify the API key in each request. The key should look similar to the following example:
 
    ```http
    # List indexes using keys
@@ -131,9 +133,9 @@ The following JSON is an example response for a knowledge base.
 
 ## Create a knowledge base
 
-A knowledge base drives the agentic retrieval pipeline. In application code, it's called by other agents or chatbots.
+A knowledge base drives the agentic retrieval pipeline. In application code, other agents or chatbots call it.
 
-A knowledge base connects knowledge sources (searchable content) to an LLM deployment from Azure OpenAI. Properties on the LLM establish the connection, while properties on the knowledge source establish defaults that inform query execution and the response.
+A knowledge base connects knowledge sources (searchable content) to an LLM deployment from Azure OpenAI. Properties on the LLM establish the connection, while properties on the knowledge source set defaults that guide query execution and the response.
 
 Use [Knowledge Bases - Create or Update (REST API)](/rest/api/searchservice/knowledge-bases/create-or-update?view=rest-searchservice-2025-11-01-preview&preserve-view=true) to formulate the request.
 
@@ -177,13 +179,13 @@ api-key: {{search-api-key}}
 
 ### Knowledge base properties
 
-You can pass the following properties to create a knowledge base.
+Pass the following properties to create a knowledge base.
 
 | Name | Description | Type | Required |
 |--|--|--|--|
-| `name` | The name of the knowledge base, which must be unique within the knowledge bases collection and follow the [naming guidelines](/rest/api/searchservice/naming-rules) for objects in Azure AI Search. | String | Yes |
+| `name` | The name of the knowledge base. It must be unique within the knowledge bases collection and follow the [naming guidelines](/rest/api/searchservice/naming-rules) for objects in Azure AI Search. | String | Yes |
 | `description` | A description of the knowledge base. The LLM uses the description to inform query planning. | String | No |
-| `retrievalInstructions` | A prompt for the LLM to determine whether a knowledge source should be in scope for a query, which is recommended when you have multiple knowledge sources. This field influences both knowledge source selection and query formulation. For example, instructions could append information or prioritize a knowledge source. Instructions are passed directly to the LLM, which means it's possible to provide instructions that break query planning, such as instructions that result in bypassing an essential knowledge source. | String | Yes |
+| `retrievalInstructions` | A prompt for the LLM to determine whether a knowledge source should be in scope for a query. Include this prompt when you have multiple knowledge sources. This field influences both knowledge source selection and query formulation. For example, instructions could append information or prioritize a knowledge source. You pass instructions directly to the LLM, which means it's possible to provide instructions that break query planning, such as instructions that result in bypassing an essential knowledge source. | String | Yes |
 | `answerInstructions` | Custom instructions to shape synthesized answers. The default is null. For more information, see [Use answer synthesis for citation-backed responses](../../agentic-retrieval-how-to-answer-synthesis.md). | String | Yes |
 | `outputMode` | Valid values are `answerSynthesis` for an LLM-formulated answer or `extractedData` for full search results that you can pass to an LLM as a downstream step. | String | Yes |
 | `knowledgeSources` | One or more [supported knowledge sources](../../agentic-knowledge-source-overview.md#supported-knowledge-sources). | Array | Yes |
@@ -235,7 +237,7 @@ api-key: {{search-api-key}}
 
 **Key points:**
 
-+ [`messages`](/rest/api/searchservice/knowledge-retrieval/retrieve?view=rest-searchservice-2025-11-01-preview#knowledgeagentmessage&preserve-view=true) is required, but you can run this example using just the `user` role that provides the query.
++ [`messages`](/rest/api/searchservice/knowledge-retrieval/retrieve?view=rest-searchservice-2025-11-01-preview#knowledgeagentmessage&preserve-view=true) is required, but you can run this example by using just the `user` role that provides the query.
 
 + [`knowledgeSourceParams`](/rest/api/searchservice/knowledge-retrieval/retrieve?view=rest-searchservice-2025-11-01-preview#searchindexknowledgesourceparams&preserve-view=true) specifies one or more query targets. For each knowledge source, you can specify how much information to include in the output.
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "REST APIにおける知識ベースの作成手順の更新"
}
```

### Explanation
この変更は、`articles/search/includes/how-tos/agentic-retrieval-how-to-create-knowledge-base-rest.md`ファイルに対して行われた小規模な修正で、REST APIを使用してAzure AI Searchの知識ベースを作成する手順を更新しています。

主な変更点は以下の通りです：

1. **日付の更新**: ドキュメントの日付が2025年11月14日から2026年1月15日に変更されています。
2. **新しい情報の追加**: 知識ベースをMicrosoft FoundryポータルのFoundry IQワークロードで作成できることや、Azure AI Search APIsを使用するエージェントソリューションには知識ベースが必要であることが明記されました。
3. **文の明確化**: 許可、役割、APIキーに関する説明が明確化され、文章の一部が改善されています。他のエージェントやチャットボットから呼び出されることに関する説明も修正されています。

全体として、この修正はドキュメントの内容をより明確にし、Azure AI Searchの知識ベースをREST APIで効果的に作成・使用するためのガイダンスを向上させることを目指しています。

## articles/search/retrieval-augmented-generation-overview.md{#item-ec76e0}

<details>
<summary>Diff</summary>
````diff
@@ -5,7 +5,7 @@ description: Learn how generative AI and retrieval augmented generation (RAG) pa
 author: HeidiSteen
 ms.author: heidist
 manager: nitinme
-ms.date: 12/15/2025
+ms.date: 01/15/2026
 ms.service: azure-ai-search
 ms.topic: article
 ms.custom:
@@ -24,7 +24,7 @@ Retrieval-augmented Generation (RAG) is a pattern that extends LLM capabilities
 |-----------|-------------|
 | **Query&nbsp;understanding** | Modern users ask complex, conversational, or vague questions with assumed context. Traditional keyword search fails when queries don't match document terminology. For RAG, an information retrieval system must understand intent, not just match words. |
 | **Multi-source&nbsp;data&nbsp;access** | Enterprise content spans SharePoint, databases, blob storage, and other platforms. Creating a unified search corpus without disrupting data operations is essential. |
-| **Token&nbsp;constraints** | LLMs accept limited token inputs. Your retrieval system must return highly relevant, concise results—not exhaustive document dumps. |
+| **Token&nbsp;constraints** | LLMs accept limited token inputs. Your retrieval system must return highly relevant, concise results - not exhaustive document dumps. |
 | **Response&nbsp;time&nbsp;expectations** | Users expect AI-powered answers in seconds, not minutes. The retrieval system must balance thoroughness with speed.
 | **Security&nbsp;and&nbsp;governance** | Opening private content to LLMs requires granular access control. Users and agents must only retrieve authorized content. |
 
@@ -44,43 +44,43 @@ The following sections explain how each approach solves specific RAG challenges.
 
 **Agentic retrieval solution:**
 
-+ LLM analyzes the question and generates multiple targeted subqueries
-+ Decomposes complex questions into focused searches
-+ Uses conversation history to understand context
-+ Parallel execution across knowledge sources
++ LLM analyzes the question and generates multiple targeted subqueries.
++ Decomposes complex questions into focused searches.
++ Uses conversation history to understand context.
++ Parallel execution across knowledge sources.
 
 **Classic RAG solution:**
 
-+ Hybrid queries combine keyword and vector search for better recall
-+ Semantic ranking re-scores results based on meaning, not just keywords
-+ Vector similarity search matches concepts, not exact terms
++ Hybrid queries combine keyword and vector search for better recall.
++ Semantic ranking re-scores results based on meaning, not just keywords.
++ Vector similarity search matches concepts, not exact terms.
 
 [Learn more about query planning](agentic-retrieval-how-to-set-retrieval-reasoning-effort.md).
 
-### Solving multi-source data challenges
+### Solving multisource data challenges
 
-**The problem:** HR policies in SharePoint, benefits in databases, company news on web pages—creating copies disrupts governance and routine data operations.
+**The problem:** HR policies in SharePoint, benefits in databases, company news on web pages - creating copies disrupts governance and routine data operations.
 
 **Agentic retrieval solution:**
 
-+ Knowledge bases unify multiple knowledge sources
-+ Direct query against remote SharePoint and Bing (no indexing needed) to supplement index content
-+ Retrieval instructions guide the LLM to appropriate data sources
-+ Automatic indexing pipeline generation for Azure Blob, OneLake, ingested SharePoint content, ingested other external content
-+ Single query interface and query plan across all sources
++ Knowledge bases unify multiple knowledge sources.
++ Direct query against remote SharePoint and Bing (no indexing needed) to supplement index content.
++ Retrieval instructions guide the LLM to appropriate data sources.
++ Automatic indexing pipeline generation for Azure Blob, OneLake, ingested SharePoint content, ingested other external content.
++ Single query interface and query plan across all sources.
 
 **Classic RAG solution:**
 
-+ Indexers pull from over 10 Azure data sources
-+ Skills pipeline for chunking, vectorization, image verbalization and analysis
-+ Incremental indexing keeps content fresh
-+ You control what's indexed and how
++ Indexers pull from more than 10 Azure data sources.
++ Skills pipeline for chunking, vectorization, image verbalization, and analysis.
++ Incremental indexing keeps content fresh.
++ You control what's indexed and how.
 
 [Learn more about knowledge sources](agentic-knowledge-source-overview.md).
 
 ### Solving token constraint challenges
 
-**The problem:** GPT-4 accepts ~128k tokens, but you have 10,000 pages of documentation. Sending everything wastes tokens and degrades quality.
+**The problem:** GPT-4 accepts about 128k tokens, but you have 10,000 pages of documentation. Sending everything wastes tokens and degrades quality.
 
 **Agentic retrieval solution:**
 
@@ -91,7 +91,7 @@ The following sections explain how each approach solves specific RAG challenges.
 
 **Classic RAG solution:**
 
-+ Semantic ranking identifies top 50 most relevant results
++ Semantic ranking identifies the top 50 most relevant results
 + Configurable result limits (top-k for vectors, top-n for text) and minimum thresholds
 + Scoring profiles boost critical content
 + Select statement controls which fields are returned
@@ -136,7 +136,7 @@ The following sections explain how each approach solves specific RAG challenges.
 
 [Learn more about security](search-security-overview.md).
 
-<!-- OLD INTRO #2
+<!-- OLD INTRO
 Retrieval-augmented Generation (RAG) is a design pattern in AI that augments the capabilities of a pretrained large language model (LLM) by adding newer, specialized, or proprietary content to help answer questions. To get that content, you typically need an information retrieval component. Azure AI Search is an information retrieval solution that's designed to solve the challenges of RAG implementations.
 
 + The first challenge: rising expectations for reasonable answers regardless of the quality of the question. The modern query consists of complex or convoluted questions, possibly vague or incomplete, with the assumption of context from the current chat. These become the inputs to the information retrieval system, against which the system must understand so that it can find relevant matches for LLM answer formulation.
@@ -153,24 +153,8 @@ Azure AI Search can meet *all* of these challenges with the new agentic retrieva
 
 It can meet *most* of these challenges with the classic search engine that accepts single-shot queries against a single search index. Classic search is generally available, and it supports a hybrid search capability with semantic ranking that produces high quality responses that help LLMs deliver their best answers using your content.
 
-This article explores modern RAG and classic RAG experiences that you can get with Azure AI Search. It speaks to the challenges of RAG implementations and how Azure AI Search solves for specific problems with each RAG pattern. -->
-
-<!-- OLD INTRO #1
-Retrieval-augmented Generation (RAG) is a design pattern that augments the capabilities of a pretrained large language model (LLM) by adding newer, specialized, or proprietary content to help answer questions. 
-
-RAG implementations typically include an information retrieval component. The decision about which information retrieval system to use is critical because LLMs are constrained by the number of token inputs they can accept, so you want the grounding data to be as relevant as possible. Criteria to consider include:
-
-+ Ability to pull from a broad range of data sources and platforms.
-
-+ Query capabilities that can target all of your data and return synthesized and highly relevant results, in the short-form formats necessary for meeting the token length requirements of LLM inputs.
-
-+ Ease of integration with agents and chat apps, and other models and processes that are part of your application.
-
-+ Built-in content preparation (chunking, vectorization, image verbalization). It's common to consolidate searchable data into separate physical data structures that are optimized for search. You can verbalize, recognize, or analyze images to get text-equivalent information into your index. More likely, you might want to chunk verbose source content so that it can be easily consumed, and vectorize that content if you want similarity search.
-
-Azure AI Search is a [proven solution for RAG workloads](https://github.com/Azure-Samples/azure-search-openai-demo/blob/main/README.md). It provides indexing and query capabilities that meet common criteria, with the infrastructure and security of the Azure cloud. Through code and other components, you can design a full stack RAG architecture that includes all of the elements for generative AI over your proprietary content.
-
-You can choose between two approaches for RAG workloads: new **agentic retrieval** for modern RAG (currently in preview), or the original query architecture for **classic RAG**. If you're required to use only generally available features, you should consider classic RAG. -->
+This article explores modern RAG and classic RAG experiences that you can get with Azure AI Search. It speaks to the challenges of RAG implementations and how Azure AI Search solves for specific problems with each RAG pattern. 
+ -->
 
 ### Modern RAG with agentic retrieval
 
@@ -182,11 +166,11 @@ Agentic retrieval represents the evolution from traditional single-query RAG pat
 + Parallel execution of multiple focused subqueries  
 + Structured responses with grounding data, citations, and execution metadata
 + Built-in semantic ranking for optimal relevance
-+ Optional answer synthesis that uses an LLM-formulated answer in the query response.
++ Optional answer synthesis that uses an LLM-formulated answer in the query response
 
 You need new objects for this pipeline: one or more knowledge sources, a knowledge base, and the retrieve action that you call from application code, such as a tool that works with your AI agent.
 
-For new RAG implementations, we recommend starting with [agentic retrieval](agentic-retrieval-overview.md). For existing solutions, consider migrating to take advantage of improved accuracy and context understanding.
+For new RAG implementations, start with [agentic retrieval](agentic-retrieval-overview.md). For existing solutions, consider migrating to take advantage of improved accuracy and context understanding.
 
 ### Classic RAG pattern for Azure AI Search
 
@@ -201,7 +185,7 @@ RAG quality depends on how you prepare content for retrieval. Azure AI Search su
 | Content challenge | How Azure AI Search helps |
 |-------------------|---------------------------|
 | **Large documents** | Automatic chunking (built-in or via skills) |
-| **Multiple languages** | 50+ language analyzers for text, multilingual vectors |
+| **Multiple languages** | More than 50 language analyzers for text, multilingual vectors |
 | **Images and PDFs** | OCR, image analysis, image verbalization, document extraction skills |
 | **Need for similarity search** | Integrated vectorization (Azure OpenAI, Azure Vision in Foundry Tools, custom) |
 | **Terminology mismatches** | Synonym maps, semantic ranking |
@@ -226,24 +210,24 @@ On the query side, to ensure the most relevant results for your RAG implementati
 
 + Fine-tune with vector query parameters for [vector weighting](vector-search-how-to-query.md#vector-weighting) and [minimum thresholds](vector-search-how-to-query.md#set-thresholds-to-exclude-low-scoring-results-preview).
 
-Learn more about [hybrid search](hybrid-search-overview.md) and [semantic ranking](semantic-ranking.md).
+For more information, see [hybrid search](hybrid-search-overview.md) and [semantic ranking](semantic-ranking.md).
 
 ## Choose between agentic retrieval and classic RAG
 
 **Use agentic retrieval when:**
 
-+ Your client is an agent or chatbot
-+ You need the highest possible relevance and accuracy
-+ Your queries are complex or conversational
-+ You want structured responses with citations and query details
-+ You're building new RAG implementations
++ Your client is an agent or chatbot.
++ You need the highest possible relevance and accuracy.
++ Your queries are complex or conversational.
++ You want structured responses with citations and query details.
++ You're building new RAG implementations.
 
 **Use classic RAG when:**
 
-+ You need generally available (GA) features only
-+ Simplicity and speed are priorities over advanced relevance
-+ You have existing orchestration code you want to preserve
-+ You need fine-grained control over the query pipeline
++ You need generally available (GA) features only.
++ Simplicity and speed are priorities over advanced relevance.
++ You have existing orchestration code you want to preserve.
++ You need fine-grained control over the query pipeline.
 
 A RAG solution that includes agents and Azure AI Search can benefit from [Foundry IQ](https://techcommunity.microsoft.com/blog/azure-ai-foundry-blog/foundry-iq-unlocking-ubiquitous-knowledge-for-agents/4470812), as an agent's single endpoint to a knowledge layer that provides grounding data. Foundry IQ uses agentic retrieval.
 
@@ -276,7 +260,7 @@ There are many ways to get started, including code-first solutions and demos.
 + [Review creating queries](search-query-create.md) to learn more about search request syntax and requirements.
 
 > [!NOTE]
-> Some Azure AI Search features are intended for human interaction and aren't useful in a RAG pattern. Specifically, you can skip features like autocomplete and suggestions. Other features like facets and orderby might be useful, but would be uncommon in a RAG scenario.
+> Some Azure AI Search features are intended for human interaction and aren't useful in a RAG pattern. Specifically, you can skip features like autocomplete and suggestions. Other features like facets and orderby might be useful, but are uncommon in a RAG scenario.
 
 ### [**Code**](#tab/demos)
 
@@ -290,7 +274,7 @@ There are many ways to get started, including code-first solutions and demos.
 
 ### [**Templates**](#tab/templates)
 
-[Use enterprise chat app templates](https://aka.ms/azai) deploy Azure resources, code, and sample grounding data using fictitious health plan documents for Contoso and Northwind. This end-to-end solution gives you an operational chat app in as little as 15 minutes. Code for these templates is the **azure-search-openai-demo** featured in several presentations. The following links provide language-specific versions:
+[Use enterprise chat app templates](https://aka.ms/azai) to deploy Azure resources, code, and sample grounding data using fictitious health plan documents for Contoso and Northwind. This end-to-end solution gives you an operational chat app in as little as 15 minutes. Code for these templates is the **azure-search-openai-demo** featured in several presentations. The following links provide language-specific versions:
 
 + [.NET](https://aka.ms/azai/net)
 + [Python](https://aka.ms/azai/py)
````
</details>

### Summary

```json
{
    "modification_type": "breaking change",
    "modification_title": "情報検索における生成強化技術の概要に関する更新"
}
```

### Explanation
この変更は、`articles/search/retrieval-augmented-generation-overview.md`ファイルに対する大規模な更新を行い、情報検索と生成強化（RAG）の概念に関する文書を刷新しています。主な変更点は次のとおりです。

1. **日付の更新**: ドキュメントの日付が2025年12月15日から2026年1月15日に変更されました。
2. **内容の改善**: RAGの概念とその適用についての説明がより明確になり、具体的なユースケースや利点が強調されています。
3. **構造の調整**: 複雑なクエリ解決の手法や、マルチソースデータの問題解決策が整理され、情報が分かりやすく提示されています。また、トークン制約に関する課題や、エージェントベースの検索手法の利点が詳細に説明されるようになりました。
4. **旧内容の削除**: いくつかの古いイントロや説明が削除され、新しい情報に置き換えられています。これは、RAGの実装における最新の動向に対応したものです。

全体的に、この修正はRAGの理解を促進し、Azure AI Searchがこの手法をサポートする具体的な方法を提供することを目的としており、ドキュメントの整合性と精度が向上しました。

## articles/search/search-security-rbac.md{#item-a5d129}

<details>
<summary>Diff</summary>
````diff
@@ -17,7 +17,7 @@ ms.custom:
 
 # Connect to Azure AI Search using roles
 
-Azure provides a global authentication and [role-based access control](/azure/role-based-access-control/role-assignments-portal) through Microsoft Entra ID for all services running on the platform. In this article, learn which roles provide access to search content and administration on Azure AI Search.
+Azure provides global authentication and [role-based access control](/azure/role-based-access-control/role-assignments-portal) through Microsoft Entra ID for all services running on the platform. In this article, learn which roles provide access to search content and administration on Azure AI Search.
 
 In Azure AI Search, you can assign Azure roles for:
 
@@ -28,7 +28,7 @@ In Azure AI Search, you can assign Azure roles for:
 
 Per-user access over search results (sometimes referred to as *row-level security* or *document-level access*) is supported through permission inheritance for Azure Data Lake Storage (ADLS) Gen2 and Azure blob indexes and through security filters for all other platforms (see [Document-level access control](search-document-level-access-overview.md)).
 
-Role assignments are cumulative and pervasive across all tools and client libraries. You can assign roles using any of the [supported approaches](/azure/role-based-access-control/role-assignments-steps) described in Azure role-based access control documentation.
+Role assignments are cumulative and pervasive across all tools and client libraries. You can assign roles by using any of the [supported approaches](/azure/role-based-access-control/role-assignments-steps) described in Azure role-based access control documentation.
 
 Role-based access is optional, but recommended. The alternative is [key-based authentication](search-security-api-keys.md), which is the default.
 
@@ -54,21 +54,21 @@ The following steps work for all role assignments.
 
    :::image type="content" source="media/search-security-rbac/portal-access-control.png" alt-text="Screenshot of the access control page in the Azure portal.":::
 
-1. Select a role. You can assign multiple security principals, whether users or managed identities to a role in one pass through the wizard, but you have to repeat these steps for each role you define.
+1. Select a role. You can assign multiple security principals, whether users or managed identities, to a role in one pass through the wizard. However, you need to repeat these steps for each role you define.
 
 1. On the **Members** tab, select the Microsoft Entra user or group identity. If you're setting up permissions for another Azure service, select a system or user-managed identity.
 
 1. On the **Review + assign** tab, select **Review + assign** to assign the role.
 
 ## Built-in roles used in search
 
-Roles are a collection of permissions on specific operations affecting either data plane or control plane layers.
+Roles are a collection of permissions on specific operations that affect either data plane or control plane layers.
 
 *Data plane* refers to operations against the search service endpoint, such as indexing or queries, or any other operation specified in the [Search Service REST APIs](/rest/api/searchservice/) or equivalent Azure SDK client libraries. 
 
 *Control plane* refers to Azure resource management, such as creating or configuring a search service.
 
-The following roles are built in. If these roles are insufficient, [create a custom role](#create-a-custom-role). 
+The following roles are built in. If these roles don't meet your needs, [create a custom role](#create-a-custom-role). 
 
 | Role | Plane | Description  |
 | ---- | ------|--------------------- |
@@ -82,34 +82,34 @@ The following roles are built in. If these roles are insufficient, [create a cus
 Combine these roles to get sufficient permissions for your use case.
 
 > [!NOTE]
-> If you disable Azure role-based access, built-in roles for the control plane (Owner, Contributor, Reader) continue to be available. Disabling role-based access removes just the data-related permissions associated with those roles. If data plane roles are disabled, Search Service Contributor is equivalent to control-plane Contributor.
+> If you disable Azure role-based access, built-in roles for the control plane (Owner, Contributor, Reader) continue to be available. Disabling role-based access removes just the data-related permissions associated with those roles. If you disable data plane roles, Search Service Contributor is equivalent to control-plane Contributor.
 
 ## Summary
 
 | Permissions | Search Index Data Reader | Search Index Data Contributor | Search Service Contributor | Owner/Contributor | Reader |
 |-------------|--------------------------|-------------------------------|----------------------------|-------------------|--------|
 |View the resource in Azure portal |❌|❌|✅|✅|✅|
-|View resource properties/metrics/endpoint |❌|❌|✅|✅|✅|
+|View resource properties, metrics, and endpoint |❌|❌|✅|✅|✅|
 |List all objects on the resource |❌|❌|✅|✅|✅|
 |Access quotas and service statistics |❌|❌|✅|✅|❌|
-|Read/query an index |✅|✅|❌|❌|❌|
+|Read and query an index |✅|✅|❌|❌|❌|
 |Upload data for indexing <sup>1</sup>|❌|✅|❌|❌|❌|
 |Elevated read regardless of permission filters <sup>2</sup>|❌|✅|❌|❌|❌|
-|Create or edit indexes/aliases |❌|❌|✅|✅|❌|
-|Create, edit and run indexers/data sources/skillsets |❌|❌|✅|✅|❌|
+|Create or edit indexes and aliases |❌|❌|✅|✅|❌|
+|Create, edit, and run indexers, data sources, and skillsets |❌|❌|✅|✅|❌|
 |Create or edit synonym maps |❌|❌|✅|✅|❌|
 |Create or edit debug sessions |❌|❌|✅|✅|❌|
 |Create or manage deployments |❌|❌|✅|✅|❌|
 |Create or configure Azure AI Search resources |❌|❌|✅|✅|❌|
-|View/Copy/Regenerate keys under Keys |❌|❌|✅|✅|❌|
-|View roles/policies/definitions |❌|❌|✅|✅|❌|
+|View, copy, and regenerate keys under Keys |❌|❌|✅|✅|❌|
+|View roles, policies, and definitions |❌|❌|✅|✅|❌|
 |Set authentication options |❌|❌|✅|✅|❌|
 |Configure private connections |❌|❌|✅|✅|❌|
 |Configure network security |❌|❌|✅|✅|❌|
 
-<sup>1</sup> In the Azure portal, an Owner or Contributor can run the Import data wizards that create and load indexes, even though they can't upload documents in other clients. Data connections in the wizard are made by the search service itself and not individual users. The wizards have the `Microsoft.Search/searchServices/indexes/documents/*` permission necessary for completing this task.
+<sup>1</sup> In the Azure portal, an Owner or Contributor can run the Import data wizards that create and load indexes, even though they can't upload documents in other clients. The search service itself, not individual users, makes data connections in the wizard. The wizards have the `Microsoft.Search/searchServices/indexes/documents/*` permission necessary for completing this task.
 
-<sup>2</sup> Elevated read is used for debugging queries that obtain results using the identity of the called. For more information, see [Investigate incorrect query results](search-query-access-control-rbac-enforcement.md#elevated-permissions-for-investigating-incorrect-results).
+<sup>2</sup> Use elevated read for debugging queries that obtain results by using the identity of the called. For more information, see [Investigate incorrect query results](search-query-access-control-rbac-enforcement.md#elevated-permissions-for-investigating-incorrect-results).
 
 Owners and Contributors grant the same permissions, except that only Owners can assign roles.
 
@@ -118,7 +118,7 @@ Owners and Contributors grant the same permissions, except that only Owners can
 In this section, assign roles for:
 
 + Service administration
-+ Development or write-access to a search service
++ Development or write access to a search service
 + Read-only access for queries
 
 ### Assign roles for service administration
@@ -157,13 +157,13 @@ New-AzRoleAssignment -SignInName <email> `
 
 ### Assign roles for development
 
-Role assignments are global across the search service. To [scope permissions to a single index](#rbac-single-index), use PowerShell or the Azure CLI to create a custom role.
+Role assignments apply globally across the search service. To [scope permissions to a single index](#rbac-single-index), use PowerShell or the Azure CLI to create a custom role.
 
-| Task | Role | ID|
+| Task | Role | ID |
 | --- | --- | --- |
-| Create or manage objects| [`Search Service Contributor`](/azure/role-based-access-control/built-in-roles#search-service-contributor)|7ca78c08-252a-4471-8644-bb5ff32d4ba0|
-| Load documents, run indexing jobs | [`Search Index Data Contributor`](/azure/role-based-access-control/built-in-roles#search-index-data-contributor)|8ebe5a00-799e-43f5-93ac-243d3dce84a7|
-| Query an index | [`Search Index Data Reader`](/azure/role-based-access-control/built-in-roles#search-index-data-reader)|1407120a-92aa-4202-b7e9-c0e197c71c8f|
+| Create or manage objects | [`Search Service Contributor`](/azure/role-based-access-control/built-in-roles#search-service-contributor) | 7ca78c08-252a-4471-8644-bb5ff32d4ba0 |
+| Load documents, run indexing jobs | [`Search Index Data Contributor`](/azure/role-based-access-control/built-in-roles#search-index-data-contributor) | 8ebe5a00-799e-43f5-93ac-243d3dce84a7 |
+| Query an index | [`Search Index Data Reader`](/azure/role-based-access-control/built-in-roles#search-index-data-reader) | 1407120a-92aa-4202-b7e9-c0e197c71c8f |
 
 Another combination of roles that provides full access is Contributor or Owner, plus Search Index Data Reader.
 
@@ -176,7 +176,7 @@ Another combination of roles that provides full access is Contributor or Owner,
 
 1. Assign these roles:
 
-   + Search Service Contributor (create-read-update-delete operations on indexes, indexers, skillsets, and other top-level objects)
+   + Search Service Contributor (create, read, update, and delete operations on indexes, indexers, skillsets, and other top-level objects)
    + Search Index Data Contributor (load documents and run indexing jobs)
    + Search Index Data Reader (query an index)
 
@@ -204,18 +204,18 @@ New-AzRoleAssignment -SignInName <email> `
 
 ### Assign roles for read-only queries
 
-Use the Search Index Data Reader role for apps and processes that only need read-access to an index.
+Use the Search Index Data Reader role for apps and processes that only need read access to an index.
 
 | Role | ID|
 | --- | --- |
 | [`Search Index Data Reader`](/azure/role-based-access-control/built-in-roles#search-index-data-reader) [with PowerShell](search-security-rbac.md#grant-access-to-a-single-index)|1407120a-92aa-4202-b7e9-c0e197c71c8f|
 
-This is a very specific role. It grants [GET or POST access](/rest/api/searchservice/documents) to the *documents collection of a search index* for search, autocomplete, and suggestions. It doesn't support GET or LIST operations on an index or other top-level objects, or GET service statistics.
+This role is very specific. It grants [GET or POST access](/rest/api/searchservice/documents) to the *documents collection of a search index* for search, autocomplete, and suggestions. It doesn't support GET or LIST operations on an index or other top-level objects, or GET service statistics.
 
-This section provides basic steps for setting up the role assignment and is here for completeness, but we recommend [Use Azure AI Search without keys ](keyless-connections.md) for comprehensive instructions on configuring your app for role-based access.
+This section provides basic steps for setting up the role assignment and is here for completeness, but for comprehensive instructions on configuring your app for role-based access, see [Use Azure AI Search without keys](keyless-connections.md).
 
 > [!NOTE]
-> As a developer, if you need to debug queries that are predicated on a Microsoft identity, you should use Search Index Data Contributor or create a custom role that gives you [elevated permissions for debug purposes](search-query-access-control-rbac-enforcement.md#elevated-permissions-for-investigating-incorrect-results).
+> As a developer, if you need to debug queries that are predicated on a Microsoft identity, use Search Index Data Contributor or create a custom role that gives you [elevated permissions for debug purposes](search-query-access-control-rbac-enforcement.md#elevated-permissions-for-investigating-incorrect-results).
 
 #### [**Azure portal**](#tab/roles-portal-query)
 
@@ -259,7 +259,7 @@ When [using PowerShell to assign roles](/azure/role-based-access-control/role-as
 
 ## Test role assignments
 
-Use a client to test role assignments. Remember that roles are cumulative and inherited roles that are scoped to the subscription or resource group level can't be deleted or denied at the resource (search service) level. 
+Use a client to test role assignments. Remember that roles are cumulative. You can't delete or deny inherited roles that are scoped to the subscription or resource group level at the resource (search service) level. 
 
 [Configure your application for keyless connections](keyless-connections.md) and have role assignments in place before testing. 
 
@@ -287,7 +287,7 @@ This approach assumes Visual Studio Code with a [REST client extension](https://
    az login
    ```
 
-1. Get your tenant ID and subscription ID. The ID is used as a variable in a future step. 
+1. Get your tenant ID and subscription ID. Use the ID as a variable in a future step. 
 
    ```azurecli
    az account show
@@ -307,7 +307,7 @@ This approach assumes Visual Studio Code with a [REST client extension](https://
    @token = PASTE-YOUR-TOKEN-HERE
    ```
 
-1. Paste and then send a request that uses the variables you've specified. For the "Search Index Data Reader" role, you can send a query. You can use any [supported API version](/rest/api/searchservice/search-service-api-versions).
+1. Paste and then send a request that uses the variables you specify. For the "Search Index Data Reader" role, you can send a query. You can use any [supported API version](/rest/api/searchservice/search-service-api-versions).
 
    ```http
    POST https://{{baseUrl}}/indexes/{{index-name}}/docs/search?api-version=2025-09-01 HTTP/1.1
@@ -331,7 +331,7 @@ For more information on how to acquire a token for a specific environment, see [
 
 1. Use [Azure.Identity for .NET](/dotnet/api/overview/azure/identity-readme) for token authentication. Microsoft recommends [`DefaultAzureCredential()`](/dotnet/api/azure.identity.defaultazurecredential) for most scenarios.
 
-1. Here's an example of a client connection using `DefaultAzureCredential()`.
+1. Here's an example of a client connection using `DefaultAzureCredential()`:
 
     ```csharp
     // Create a SearchIndexClient to send create/delete index commands
@@ -382,21 +382,21 @@ For more information on how to acquire a token for a specific environment, see [
 
 1. Use [Azure.Identity for Java](/java/api/overview/azure/identity-readme?view=azure-java-stable&preserve-view=true) for token authentication.
 
-1. Microsoft recommends [DefaultAzureCredential](/java/api/overview/azure/identity-readme?view=azure-java-stable#defaultazurecredential&preserve-view=true) for apps that run on Azure.
+1. Use [DefaultAzureCredential](/java/api/overview/azure/identity-readme?view=azure-java-stable#defaultazurecredential&preserve-view=true) for apps that run on Azure.
 
 ---
 
 ## Test as current user
 
-If you're already a Contributor or Owner of your search service, you can present a bearer token for your user identity for authentication to Azure AI Search.
+If you're already a Contributor or Owner of your search service, you can use a bearer token for your user identity to authenticate to Azure AI Search.
 
-1. Get a bearer token for the current user using the Azure CLI:
+1. Get a bearer token for the current user by using the Azure CLI:
 
     ```azurecli
     az account get-access-token --scope https://search.azure.com/.default
     ```
 
-   Or by using PowerShell:
+   Or use PowerShell:
 
    ```powershell
    Get-AzAccessToken -ResourceUrl https://search.azure.com
@@ -410,7 +410,7 @@ If you're already a Contributor or Owner of your search service, you can present
    @token = PASTE-YOUR-TOKEN-HERE
    ```
 
-1. Paste in and then send a request to confirm access. Here's one that queries the hotels-quickstart index
+1. Paste in and then send a request to confirm access. Here's one that queries the hotels-quickstart index.
 
    ```http
    POST https://{{baseUrl}}/indexes/{{index-name}}/docs/search?api-version=2025-09-01 HTTP/1.1
@@ -432,7 +432,7 @@ If you're already a Contributor or Owner of your search service, you can present
 
 In some scenarios, you might want to limit an application's access to a single resource, such as an index.
 
-The Azure portal doesn't currently support role assignments at this level of granularity, but it can be done with [PowerShell](/azure/role-based-access-control/role-assignments-powershell) or the [Azure CLI](/azure/role-based-access-control/role-assignments-cli).
+The Azure portal doesn't currently support role assignments at this level of granularity, but you can assign roles using [PowerShell](/azure/role-based-access-control/role-assignments-powershell) or the [Azure CLI](/azure/role-based-access-control/role-assignments-cli).
 
 In PowerShell, use [New-AzRoleAssignment](/powershell/module/az.resources/new-azroleassignment), providing the Azure user or group name, and the scope of the assignment.
 
@@ -460,11 +460,11 @@ This example clones **Search Index Data Reader** and then adds the ability to li
 
 ### [**Azure portal**](#tab/custom-role-portal)
 
-These steps are derived from [Create or update Azure custom roles using the Azure portal](/azure/role-based-access-control/custom-roles-portal). Cloning from an existing role is supported in a search service page.
+These steps are derived from [Create or update Azure custom roles using the Azure portal](/azure/role-based-access-control/custom-roles-portal). A search service page supports cloning from an existing role.
 
 These steps create a custom role that augments search query rights to include listing indexes by name. Typically, listing indexes is considered an admin function.
 
-1. In the Azure portal, navigate to your search service.
+1. In the Azure portal, go to your search service.
 
 1. In the left-navigation pane, select **Access Control (IAM)**.
 
@@ -478,7 +478,7 @@ These steps create a custom role that augments search query rights to include li
 
 1. On the Add permissions tab, search for and then select the **Microsoft Search** tile.
 
-1. Set the permissions for your custom role. At the top of the page, using the default **Actions** selection:
+1. Set the permissions for your custom role. At the top of the page, use the default **Actions** selection:
 
    + Under Microsoft.Search/operations, select **Read : List all available operations**. 
    + Under Microsoft.Search/searchServices/indexes, select **Read : Read Index**.
@@ -516,17 +516,17 @@ These steps create a custom role that augments search query rights to include li
 
 ### [**Azure PowerShell**](#tab/custom-role-ps)
 
-The PowerShell example shows the JSON syntax for creating a custom role that's a clone of **Search Index Data Reader**, but with ability to list all indexes by name.
+The PowerShell example shows the JSON syntax for creating a custom role that's a clone of **Search Index Data Reader**, but with the ability to list all indexes by name.
 
-1. Review the [list of atomic permissions](/azure/role-based-access-control/resource-provider-operations#microsoftsearch) to determine which ones you need. For this example, you'll need the following:
+1. Review the [list of atomic permissions](/azure/role-based-access-control/resource-provider-operations#microsoftsearch) to determine which ones you need. For this example, you need the following permissions:
 
    ```json
    "Microsoft.Search/operations/read",
    "Microsoft.Search/searchServices/read",
    "Microsoft.Search/searchServices/indexes/read"
    ```
 
-1. Set up a PowerShell session to create the custom role. For detailed instructions, see [Azure PowerShell](/azure/role-based-access-control/custom-roles-powershell)
+1. Set up a PowerShell session to create the custom role. For detailed instructions, see [Azure PowerShell](/azure/role-based-access-control/custom-roles-powershell).
 
 1. Provide the role definition as a JSON document. The following example shows the syntax for creating a custom role with PowerShell.
 
@@ -552,7 +552,7 @@ The PowerShell example shows the JSON syntax for creating a custom role that's a
 ```
 
 > [!NOTE]
-> If the assignable scope is at the index level, the data action should be `"Microsoft.Search/searchServices/indexes/documents/read"`.
+> If you assign the scope at the index level, use the data action `"Microsoft.Search/searchServices/indexes/documents/read"`.
 
 ### [**REST API**](#tab/custom-role-rest)
 
@@ -574,7 +574,7 @@ The PowerShell example shows the JSON syntax for creating a custom role that's a
 
 ## Conditional Access
 
-We recommend [Microsoft Entra Conditional Access](/entra/identity/conditional-access/overview) if you need to enforce organizational policies, such as multifactor authentication.
+If you need to enforce organizational policies, such as multifactor authentication, use [Microsoft Entra Conditional Access](/entra/identity/conditional-access/overview).
 
 To enable a Conditional Access policy for Azure AI Search, follow these steps:
 
@@ -593,12 +593,12 @@ To enable a Conditional Access policy for Azure AI Search, follow these steps:
 1. Save the policy.
 
 > [!IMPORTANT]
-> If your search service has a managed identity assigned to it, the specific search service will show up as a cloud app that can be included or excluded as part of the Conditional Access policy. Conditional Access policies can't be enforced on a specific search service. Instead make sure you select the general **Azure AI Search** cloud app.
+> If your search service has a managed identity assigned to it, the specific search service shows up as a cloud app that you can include or exclude as part of the Conditional Access policy. You can't enforce Conditional Access policies on a specific search service. Instead, make sure you select the general **Azure AI Search** cloud app.
 
 ## Troubleshooting role-based access control issues
 
-When developing applications that use role-based access control for authentication, some common issues might occur:
+When you develop applications that use role-based access control for authentication, you might encounter some common problems:
 
-+ If the authorization token came from a [managed identity](/entra/identity/managed-identities-azure-resources/overview) and the appropriate permissions were recently assigned, it [might take several hours](/entra/identity/managed-identities-azure-resources/managed-identity-best-practice-recommendations#limitation-of-using-managed-identities-for-authorization) for these permissions assignments to take effect.
++ If the authorization token comes from a [managed identity](/entra/identity/managed-identities-azure-resources/overview) and you recently assigned the appropriate permissions, it [might take several hours](/entra/identity/managed-identities-azure-resources/managed-identity-best-practice-recommendations#limitation-of-using-managed-identities-for-authorization) for these permissions assignments to take effect.
 
-+ The default configuration for a search service is [key-based authentication](search-security-api-keys.md). If you didn't change the default key setting to **Both** or **Role-based access control**, then all requests using role-based authentication are automatically denied regardless of the underlying permissions.
++ The default configuration for a search service is [key-based authentication](search-security-api-keys.md). If you don't change the default key setting to **Both** or **Role-based access control**, then all requests by using role-based authentication are automatically denied regardless of the underlying permissions.
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "Azure AI Searchのロールベースアクセス制御の文書更新"
}
```

### Explanation
この変更は、`articles/search/search-security-rbac.md`ファイルに対する修正で、Azure AI Searchにおけるロールベースのアクセス制御（RBAC）に関する文書が更新されています。以下は、主な変更点の概要です：

1. **文の簡潔化**: 特定の箇所において、文章がより簡潔で明確になるように修正されています。例えば、「Azure provides a global authentication and role-based access control...」が「Azure provides global authentication and role-based access control...」に変更され、冗長な表現が省かれています。

2. **内容の改善**: 一部の説明文がより明確になり、ロールの適用や権限の管理に関する具体的な内容や手順が強調されています。また、テーブルの内容もわかりやすくして、ユーザーに役立つ情報を提供しています。

3. **用語の統一**: 一貫性のために用語や句読点が修正されました（例：「read-access」が「read access」に変更されるなど）。

4. **注意事項の修正**: 注意事項の表現が緩和され、ユーザーが理解しやすいように改善されています。

全体的に、この文書の修正は、利用者にとっての可読性と理解のしやすさを向上させることが目的であり、Azure AI Searchのロールベースのアクセス制御の利用方法やそれに伴う注意点についてより良いガイダンスを提供するものです。

## articles/search/semantic-how-to-configure.md{#item-7a92a6}

<details>
<summary>Diff</summary>
````diff
@@ -54,7 +54,7 @@ A semantic configuration has a name and the following properties:
 | Property | Characteristics |
 |----------|-----------------|
 | Title field | A short string, ideally under 25 words. This field could be the title of a document, name of a product, or a unique identifier. If you don't have suitable field, leave it blank. | 
-| Content fields | Longer chunks of text in natural language form, subject to [maximum token input limits](semantic-search-overview.md#how-inputs-are-collected-and-summarized) on the machine learning models. Common examples include the body of a document, description of a product, or other free-form text. | 
+| Content fields | Longer chunks of text in natural language form, subject to [maximum token input limits](semantic-search-overview.md#how-the-system-collects-and-summarizes-inputs) on the machine learning models. Common examples include the body of a document, description of a product, or other free-form text. | 
 | Keyword fields | A list of keywords, such as the tags on a document, or a descriptive term, such as the category of an item. | 
 
 You can only specify one title field, but you can have as many content and keyword fields as you like. For content and keyword fields, list the fields in priority order because lower priority fields might get truncated.
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "セマンティック構成の説明文の修正"
}
```

### Explanation
この変更は、`articles/search/semantic-how-to-configure.md`ファイルに対する小規模な修正で、セマンティック構成に関する記述を明確化しています。具体的には、以下の点が修正されています。

1. **表現の変更**: "maximum token input limits"の説明が「how input are collected and summarized」から「how the system collects and summarizes inputs」に変更され、文章がより正確で理解しやすくなっています。

2. **用語の一貫性**: 修正されることで、文中の用語とその説明がより整合性を持ち、読者にとって理解しやすい内容に改善されました。

この修正は、セマンティック検索に関連する情報をより明確かつ正確に提供することを目的としており、ユーザーが構成の仕組みをよりよく理解できるように努めています。

## articles/search/semantic-search-overview.md{#item-b7497b}

<details>
<summary>Diff</summary>
````diff
@@ -10,20 +10,20 @@ ms.update-cycle: 180-days
 ms.custom:
   - ignite-2023
 ms.topic: concept-article
-ms.date: 11/19/2025
+ms.date: 01/15/2026
 ---
 
 # Semantic ranking in Azure AI Search
 
 In Azure AI Search, *semantic ranker* is a feature that measurably improves search relevance by using Microsoft's language understanding models to rerank search results. Semantic ranker is also built into [agentic retrieval](agentic-retrieval-overview.md). This article is a high-level introduction to help you understand the behaviors and benefits of semantic ranker.
 
-Semantic ranker is a premium feature, billed by usage, but you can use it for free subject to [service limits](/azure/search/search-limits-quotas-capacity#index-limits) for the free tier. We recommend this article for background, but if you'd rather get started, [follow these steps](#how-to-get-started-with-semantic-ranker).
+Semantic ranker is a premium feature that's billed by usage, but you can use it for free subject to [service limits](/azure/search/search-limits-quotas-capacity#index-limits) for the free tier. We recommend this article for background, but if you'd rather get started, [follow these steps](#how-to-get-started-with-semantic-ranker).
 
 ## What is semantic ranking?
 
 Semantic ranker is a collection of query-side capabilities that improve the quality of an initial [BM25-ranked](index-similarity-and-scoring.md) or [RRF-ranked](hybrid-search-ranking.md) search result for text-based queries, the text portion of vector queries, and hybrid queries. Semantic ranking extends the query execution pipeline in three ways:
 
-* First, it always adds secondary ranking over an initial result set that was scored using BM25 or Reciprocal Rank Fusion (RRF). This secondary ranking uses multi-lingual, deep learning models adapted from Microsoft Bing to promote the most semantically relevant results.
+* First, it always adds secondary ranking over an initial result set that was scored using BM25 or Reciprocal Rank Fusion (RRF). This secondary ranking uses multilingual, deep learning models adapted from Microsoft Bing to promote the most semantically relevant results.
 
 * Second, it returns captions and optionally extracts answers in the response, which you can render on a search page to improve the user's search experience.
 
@@ -42,47 +42,47 @@ Here are the capabilities of the semantic reranker.
 
 ## How semantic ranker works
 
-Semantic ranker feeds a query and results to language understanding models hosted by Microsoft and scans for better matches. 
+Semantic ranker takes a query and results, then sends them to language understanding models hosted by Microsoft. It scans for better matches. 
 
-The following illustration explains the concept. Consider the term "capital". It has different meanings depending on whether the context is finance, law, geography, or grammar. Through language understanding, the semantic ranker can detect context and promote results that fit query intent.
+The following illustration explains the concept. Consider the term "capital". It has different meanings depending on whether the context is finance, law, geography, or grammar. Through language understanding, the semantic ranker detects context and promotes results that fit query intent.
 
 :::image type="content" source="media/semantic-search-overview/semantic-vector-representation.png" alt-text="Illustration of vector representation for context." border="true":::
 
-Semantic ranking is both resource and time intensive. In order to complete processing within the expected latency of a query operation, inputs to the semantic ranker are consolidated and reduced so that the reranking step can be completed as quickly as possible.
+Semantic ranking uses a lot of resources and time. To finish processing within the expected latency of a query operation, the system consolidates and reduces inputs to the semantic ranker. This approach helps complete the reranking step as quickly as possible.
 
-There are three steps to semantic ranking:
+Semantic ranking has three steps:
 
-* Collect and summarize inputs
-* Score results using the semantic ranker
-* Output rescored results, captions, and answers
+1. Collect and summarize inputs
+1. Score results by using the semantic ranker
+1. Output rescored results, captions, and answers
 
-### How inputs are collected and summarized
+### How the system collects and summarizes inputs
 
 In semantic ranking, the query subsystem passes search results as an input to summarization and ranking models. Because the ranking models have input size constraints and are processing intensive, search results must be sized and structured (summarized) for efficient handling.
 
-1. Semantic ranker starts with a [BM25-ranked result](index-ranking-similarity.md) from a text query or an [RRF-ranked result](hybrid-search-ranking.md) from a vector or hybrid query. Only text is used in the reranking exercise, and only the top 50 results progress to semantic ranking, even if results include more than 50. Typically, fields used in semantic ranking are informational and descriptive.
+1. The semantic ranker starts with a [BM25-ranked result](index-ranking-similarity.md) from a text query or an [RRF-ranked result](hybrid-search-ranking.md) from a vector or hybrid query. The reranking exercise uses only text. Even if results include more than 50 results, only the top 50 results progress to semantic ranking. Typically, semantic ranking uses informational and descriptive fields.
 
-1. For each document in the search result, the summarization model accepts up to 2,000 tokens, where a token is approximately 10 characters. Inputs are assembled from the "title", "keyword", and "content" fields listed in the [semantic configuration](semantic-how-to-configure.md). 
+1. For each document in the search result, the summarization model accepts up to 2,000 tokens, where a token is approximately 10 characters. The model assembles inputs from the "title", "keyword", and "content" fields listed in the [semantic configuration](semantic-how-to-configure.md). 
 
-1. Excessively long strings are trimmed to ensure the overall length meets the input requirements of the summarization step. This trimming exercise is why it's important to add fields to your semantic configuration in priority order. If you have very large documents with text-heavy fields, anything after the maximum limit is ignored.
+1. The system trims excessively long strings to ensure the overall length meets the input requirements of the summarization step. This trimming exercise is why it's important to add fields to your semantic configuration in priority order. If you have very large documents with text-heavy fields, the system ignores anything after the maximum limit.
 
    | Semantic field | Token limit |
    |-----------|-------------|
    | "title"   | 128 tokens |
    | "keywords | 128 tokens |
    | "content" | remaining tokens |
 
-1. Summarization output is a summary string for each document, composed of the most relevant information from each field. Summary strings are sent to the ranker for scoring, and to machine reading comprehension models for captions and answers.
+1. The summarization output is a summary string for each document, composed of the most relevant information from each field. The system sends summary strings to the ranker for scoring, and to machine reading comprehension models for captions and answers.
 
    As of November 2024, the maximum length of each generated summary string passed to the semantic ranker is 2,048 tokens. Previously, it was 256 tokens.
 
 ## How results are scored
 
-Scoring is done over the caption, and any other content from the summary string that fills out the 2,048 token length.
+The system scores results based on the caption and any other content from the summary string that fills out the 2,048 token length.
 
-1. Captions are evaluated for conceptual and semantic relevance, relative to the query provided.
+1. The system evaluates captions for conceptual and semantic relevance, relative to the query you provide.
 
-1. A **@search.rerankerScore** is assigned to each document based on the semantic relevance of the document for the given query. Scores range from 4 to 0 (high to low), where a higher score indicates higher relevance.
+1. The system assigns a **@search.rerankerScore** to each document based on the semantic relevance of the document for the given query. Scores range from 4 to 0 (high to low), where a higher score indicates higher relevance.
 
    | Score | Meaning |
    |-------|---------|
@@ -92,16 +92,16 @@ Scoring is done over the caption, and any other content from the summary string
    | 1.0   | The document is related to the question, and it answers a small part of it. |
    | 0.0   | The document is irrelevant. |
 
-1. Matches are listed in descending order by score and included in the query response payload. The payload includes answers, plain text and highlighted captions, and any fields that you marked as retrievable or specified in a select clause.
+1. The system lists matches in descending order by score and includes them in the query response payload. The payload includes answers, plain text and highlighted captions, and any fields that you marked as retrievable or specified in a select clause.
 
 > [!NOTE]
-> For any given query, the distributions of **@search.rerankerScore** can exhibit slight variations due to conditions at the infrastructure level. Ranking model updates have also been known to affect the distribution. For these reasons, if you're writing custom code for minimum thresholds, or [setting the threshold property](vector-search-how-to-query.md#set-thresholds-to-exclude-low-scoring-results-preview) for vector and hybrid queries, don't make the limits too granular.
+> For any given query, the distributions of **@search.rerankerScore** can exhibit slight variations due to conditions at the infrastructure level. Ranking model updates can also affect the distribution. For these reasons, if you're writing custom code for minimum thresholds or [setting the threshold property](vector-search-how-to-query.md#set-thresholds-to-exclude-low-scoring-results-preview) for vector and hybrid queries, don't make the limits too granular.
 
 ### Outputs of semantic ranker
 
 From each summary string, the machine reading comprehension models find passages that are the most representative.
 
-Outputs are:
+The outputs are:
 
 * A [semantic caption](semantic-how-to-query-request.md) for the document. Each caption is available in a plain text version and a highlight version, and is frequently fewer than 200 words per document.
 
@@ -115,9 +115,9 @@ What semantic ranker *can* do:
 
 * Promote matches that are semantically closer to the intent of original query.
 
-* Find strings to use as captions and answers. Captions and answers are returned in the response and can be rendered on a search results page.
+* Find strings to use as captions and answers. The response returns captions and answers, which you can render on a search results page.
 
-What semantic ranker *can't* do is rerun the query over the entire corpus to find semantically relevant results. Semantic ranking reranks the existing result set, consisting of the top 50 results as scored by the default ranking algorithm. Furthermore, semantic ranker can't create new information or strings. Captions and answers are extracted verbatim from your content so if the results don't include answer-like text, the language models won't produce one.
+What semantic ranker *can't* do is rerun the query over the entire corpus to find semantically relevant results. Semantic ranking reranks the existing result set, consisting of the top 50 results as scored by the default ranking algorithm. Furthermore, semantic ranker can't create new information or strings. The language models extract captions and answers verbatim from your content, so if the results don't include answer-like text, they won't produce one.
 
 Although semantic ranking isn't beneficial in every scenario, certain content can benefit significantly from its capabilities. The language models in semantic ranker work best on searchable content that is information-rich and structured as prose. A knowledge base, online documentation, or documents that contain descriptive content see the most gains from semantic ranker capabilities.
 
@@ -129,22 +129,22 @@ The following video provides an overview of the capabilities.
 
 ## How semantic ranker uses synonym maps
 
-If you have already enabled support for [synonym maps associated to a field](search-synonyms.md#assign-synonyms-to-fields) in your search index, and that field is included in the [semantic ranker configuration](semantic-how-to-configure.md), the semantic ranker will automatically apply the configured synonyms during the reranking process.
+If you enable support for [synonym maps associated to a field](search-synonyms.md#assign-synonyms-to-fields) in your search index, and include that field in the [semantic ranker configuration](semantic-how-to-configure.md), the semantic ranker automatically applies the configured synonyms during the reranking process.
 
 ## Availability and pricing
 
-Semantic ranker is available [in selected regions](search-region-support.md). It's used as a standalone feature and as a built-in component of [agentic retrieval](agentic-retrieval-overview.md).
+Semantic ranker is available [in selected regions](search-region-support.md). Use it as a standalone feature and as a built-in component of [agentic retrieval](agentic-retrieval-overview.md).
 
 You can disable semantic ranker for your search service, use it on a limited basis for free, or use it more expansively with pay-as-you-go billing:
 
 | Plan | Description |
 |------|-------------|
 | Free | A free tier search service provides 1,000 semantic ranker requests per month and 50 million free agentic reasoning tokens per month. Higher tiers can also use the free plan. |
-| Standard | The standard plan is pay-as-you-go pricing once the monthly free quota is consumed. After the first 1,000 semantic ranker requests, you are charged for each additional 1,000 requests. After the first 50 million agentic reasoning tokens per month, you are charged a nominal fee for each one million agentic reasoning tokens. The transition from Free to Standard is seamless. You aren't notified when the transition occurs. For more information about charges by currency, see the [Azure AI Search pricing page](https://azure.microsoft.com/pricing/details/search). |
+| Standard | The standard plan is pay-as-you-go pricing once the monthly free quota is consumed. After the first 1,000 semantic ranker requests, you pay for each additional 1,000 requests. After the first 50 million agentic reasoning tokens per month, you pay a nominal fee for each one million agentic reasoning tokens. The transition from Free to Standard is seamless. You aren't notified when the transition occurs. For more information about charges by currency, see the [Azure AI Search pricing page](https://azure.microsoft.com/pricing/details/search). |
 
 The [Azure AI Search pricing page](https://azure.microsoft.com/pricing/details/search/) shows you the billing rate for different currencies and intervals.
 
-Charges for semantic ranker are levied when query requests include `queryType=semantic` and the search string isn't empty (for example, `search=pet friendly hotels in New York`). If your search string is empty (`search=*`), you aren't charged, even if the queryType is set to semantic.
+Charges for semantic ranker occur when query requests include `queryType=semantic` and the search string isn't empty (for example, `search=pet friendly hotels in New York`). If your search string is empty (`search=*`), you aren't charged, even if the queryType is set to semantic.
 
 ## How to get started with semantic ranker
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "セマンティック検索の概要に関する文書の修正"
}
```

### Explanation
このコードの変更は、`articles/search/semantic-search-overview.md`ファイルにおけるセマンティック検索に関する情報の修正であり、主に次のポイントが挙げられます：

1. **日付の更新**: 文書の日付が「11/19/2025」から「01/15/2026」に変更され、最新の情報を反映しています。

2. **用語の一貫性向上**: 特定の表現が調整され、例えば「multi-lingual」から「multilingual」に変更されており、用語の一貫性が高められています。

3. **文章のクリアリング**: 一部の文が明確化され、よりスムーズで理解しやすい流れになるように改善されています。特に、セマンティックランカーの動作やプロセスについて詳しく説明している箇所が明確に表現されています。

4. **構造の変更**: アウトプットや処理手順に関する表現が整理され、より明確な情報が提供されるように修正されています。たとえば、プロセスをリスト形式に整え、読みやすさを向上させています。

これらの変更は、セマンティック検索に関する理解を深めるための文書の質を向上させ、読者に対してより正確で効果的な情報を提供することを目的としています。

## articles/search/vector-search-overview.md{#item-56e5fa}

<details>
<summary>Diff</summary>
````diff
@@ -8,13 +8,13 @@ ms.service: azure-ai-search
 ms.custom:
   - ignite-2023
 ms.topic: conceptual
-ms.date: 11/21/2025
+ms.date: 01/15/2026
 ai-usage: ai-assisted
 ---
 
 # Vector search in Azure AI Search
 
-Vector search is an information retrieval approach that supports indexing and querying over numeric representations of content. Because the content is numeric rather than plain text, matching is based on vectors that are most similar to the query vector, which enables matching across:
+Vector search is an information retrieval approach that supports indexing and querying over numeric representations of content. Because the content is numeric rather than plain text, matching is based on vectors that are most similar to the query vector. This approach enables matching across:
 
 + Semantic or conceptual likeness. For example, "dog" and "canine" are conceptually similar but linguistically distinct.
 + Multilingual content, such as "dog" in English and "hund" in German.
@@ -88,7 +88,7 @@ Azure AI Search is deeply integrated across the Azure AI platform. The following
 | Azure OpenAI | Azure OpenAI provides embedding models and chat models. Demos and samples target the [text-embedding-ada-002](/azure/ai-services/openai/concepts/models#embeddings-models) model. We recommend Azure OpenAI for generating embeddings for text. |
 | Foundry Tools | [Image Retrieval Vectorize Image API](/azure/ai-services/computer-vision/how-to/image-retrieval#call-the-vectorize-image-api) supports vectorization of image content. We recommend this API for generating embeddings for images. |
 | Foundry Agent Service | In Azure AI Search, you can create an *indexed [knowledge source](agentic-knowledge-source-overview.md)* that points to a search index containing vector fields and a vectorizer. You can then parent the knowledge source to a *[knowledge base](agentic-retrieval-how-to-create-knowledge-base.md)* and [connect the knowledge base to Foundry Agent Service](/azure/ai-foundry/agents/how-to/tools/knowledge-retrieval), providing your agents with vector search results for enhanced knowledge retrieval. |
-| Azure data platforms: Azure Blob Storage, Azure Cosmos DB, Azure SQL, Microsoft OneLake | You can use [indexers](search-indexer-overview.md) to automate data ingestion, and then use [integrated vectorization](vector-search-integrated-vectorization.md) to generate embeddings. Azure AI Search can automatically index vector data from [Azure blob indexers](search-how-to-index-azure-blob-storage.md), [Azure Cosmos DB for NoSQL indexers](search-how-to-index-cosmosdb-sql.md), [Azure Data Lake Storage Gen2](search-how-to-index-azure-data-lake-storage.md), [Azure Table Storage](search-how-to-index-azure-tables.md), and [Microsoft OneLake](search-how-to-index-onelake-files.md). For more information, see [Add vector fields to a search index.](vector-search-how-to-create-index.md). |
+| Azure data platforms: Azure Blob Storage, Azure Cosmos DB, Azure SQL, Microsoft OneLake | You can use [indexers](search-indexer-overview.md) to automate data ingestion, and then use [integrated vectorization](vector-search-integrated-vectorization.md) to generate embeddings. Azure AI Search can automatically index vector data from [Azure blob indexers](search-how-to-index-azure-blob-storage.md), [Azure Cosmos DB for NoSQL indexers](search-how-to-index-cosmosdb-sql.md), [Azure Data Lake Storage Gen2](search-how-to-index-azure-data-lake-storage.md), [Azure Table Storage](search-how-to-index-azure-tables.md), and [Microsoft OneLake](search-how-to-index-onelake-files.md). For more information, see [Add vector fields to a search index](vector-search-how-to-create-index.md). |
 
 It's also commonly used in open-source frameworks like [LangChain](https://js.langchain.com/docs/integrations/vectorstores/azure_aisearch).
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "ベクター検索の概要文書の修正"
}
```

### Explanation
この変更は、`articles/search/vector-search-overview.md`ファイルにおけるベクター検索に関する文書の小規模な修正であり、以下のポイントが含まれています。

1. **日付の更新**: 文書の日付が「11/21/2025」から「01/15/2026」に変更され、最新の情報を反映しています。

2. **用語の整理**: ベクター検索の説明文において、概念的な類似性を示す部分が明確にされ「このアプローチにより、以下のマッチングが可能になります」という形で、内容の流れがスムーズになっています。

3. **箇条書きの明確化**: 概念的または言語的に異なる語のマッチングを示す文の構造が改善され、よりわかりやすい表現になっています。具体的に例として「犬」と「犬科」を挙げており、言語的な差異にも言及しています。

4. **表現の一貫性**: 修正により文章全体の一貫性が高まり、読者がベクター検索のコンセプトをより理解しやすくなっています。

これらの変更は、ベクター検索の理解を促進し、正確で価値のある情報を読者に提供することを目的としています。


