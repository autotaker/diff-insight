---
date: '2024-10-22'
permalink: https://github.com/MicrosoftDocs/azure-ai-docs/compare/MicrosoftDocs:96dd444...MicrosoftDocs:bf31bc8
summary: このコードの差分では、主に画像ファイルの更新および新規追加と、複数のマークダウン文書の軽微な修正・更新が行われています。新しい画像ファイルが追加されたことで、関連するドキュメントが視覚的に補完され、解釈しやすくなりました。さらに、文書の更新により、ユーザーがAzure
  AI Search関連の機能をより効果的に利用できるようになっています。主な変更は、画像追加による視覚的理解の向上と、マークダウン文書における情報の最新化です。全体的に、ドキュメントの質が向上し、ユーザーの体験が一歩前進しました。
title: Diff Insight Report - search

---

[View Diff on GitHub](https://github.com/MicrosoftDocs/azure-ai-docs/compare/MicrosoftDocs:96dd444...MicrosoftDocs:bf31bc8){target="_blank"}

# ハイライト

このコードの差分では、主に画像ファイルの更新および新規追加と、複数のマークダウン文書の軽微な修正・更新が行われています。新しい画像ファイルが追加されたことで、関連するドキュメントが視覚的に補完され、解釈しやすくなったことが重要な変更点です。また、文書の更新により、ユーザーがAzure AI Search関連の機能をより効果的に利用できるようになっています。

## 新機能
- 画像ファイルの追加 (`add-index-import-samples.png` と `add-semantic-config.png`) により、関連するドキュメントの視覚的理解が向上しました。

## 破壊的変更
- 特に破壊的変更はなく、全体的に軽微な修正と更新が施されています。

## その他の更新
- 複数の画像ファイルが修正され、視覚的要素が改善されました。
- 複数のマークダウン文書が更新され、情報の日付や内容が最新の情報に基づいて修正・追加されました。

# インサイト

このコード差分は、主にユーザーエクスペリエンスとドキュメントの可読性を向上させることを目的としています。変更が行われた画像ファイルは、ドキュメントに掲載された情報を視覚的に補足し、ユーザーが技術的な内容をより容易に理解できるようにする役割を担っています。

さらに、多くのマークダウン文書では、手順や用語の明記・修正が行われており、Azure AI Searchのさまざまな機能についての理解が促進されています。例えば、インデックス作成に関する文書の更新では、より具体的な手順と事例が示され、利用者が実践する際の参考になります。

また、セマンティックランカーに関連する文書の説明が整理され、より明確化されたことで、ユーザーがその機能を効果的に活用するための道筋が明確に示されました。このような更新により、Azure AI Searchを利用する開発者や企業ユーザーは、より直感的かつ効果的にサービスを活用できるようになるでしょう。

まとめると、このコード差分は全体として、ドキュメントの質を向上させ、ユーザーが技術情報をより迅速に理解し、適用できるようにすることを目指している点で重要です。新規追加された要素と変更された内容は、Azureプラットフォームの利用におけるユーザー体験を一歩前進させるものであると言えます。修正内容は、指定されたGitHubのURLから確認可能であり、ユーザーが最新の情報にアクセスし、さらなる利便性を享受できるようになっています。

# Summary Table
|  Filename  | Type |    Title    | Status | A  | D  | M  |
|------------|------|-------------|--------|----|----|----|
| [import-data-cmd.png](#item-9813db) | minor update | 画像ファイルの更新 | modified | 0 | 0 | 0 | 
| [add-index-import-samples.png](#item-16c539) | new feature | 新しい画像ファイルの追加 | added | 0 | 0 | 0 | 
| [add-index.png](#item-80036e) | minor update | 画像ファイルの更新 | modified | 0 | 0 | 0 | 
| [add-semantic-config.png](#item-6f27e6) | new feature | 新しい画像ファイルの追加 | added | 0 | 0 | 0 | 
| [create-semantic-config.png](#item-664967) | minor update | 画像ファイルの修正 | modified | 0 | 0 | 0 | 
| [semantic-search-billing.png](#item-79aec1) | minor update | 画像ファイルの修正 | modified | 0 | 0 | 0 | 
| [search-how-to-create-search-index.md](#item-c4ff31) | minor update | 検索インデックス作成のマークダウン文書の修正 | modified | 8 | 8 | 16 | 
| [search-import-data-portal.md](#item-b804d1) | minor update | データインポートウィザードに関するマークダウン文書の修正 | modified | 10 | 4 | 14 | 
| [search-limits-quotas-capacity.md](#item-3b201a) | minor update | 検索サービスの限界とクオータに関する文書の更新 | modified | 3 | 1 | 4 | 
| [search-what-is-an-index.md](#item-5a3344) | minor update | Azure AI Searchにおけるインデックスの定義に関する文書の修正 | modified | 5 | 4 | 9 | 
| [semantic-how-to-configure.md](#item-7a92a6) | minor update | セマンティックランカーの設定方法に関する文書の更新 | modified | 16 | 21 | 37 | 
| [semantic-how-to-enable-disable.md](#item-71ac1e) | minor update | セマンティックランカーの有効化・無効化に関する文書の修正 | modified | 3 | 3 | 6 | 
| [semantic-how-to-query-request.md](#item-85530d) | minor update | セマンティッククエリリクエストに関する文書の更新 | modified | 15 | 14 | 29 | 
| [tutorial-optimize-indexing-push-api.md](#item-ef0e96) | minor update | プッシュAPIを使用したインデックス最適化に関するチュートリアルの更新 | modified | 63 | 64 | 127 | 


# Modified Contents
## articles/search/media/search-import-data-portal/import-data-cmd.png{#item-9813db}

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "画像ファイルの更新"
}
```

### Explanation
このコードの差分では、画像ファイル `import-data-cmd.png` が変更されたことを示しています。ただし、追加や削除、変更の実質的な内容はありません。この画像はMicrosoftのドキュメントに関連しており、GitHub上での位置は指定されたURLから確認できます。ファイルの変更は、主にドキュメントの内容に対する軽微な更新や調整を反映している可能性があります。この更新が他のコンテンツにどのように影響するかは、ファイルの具体的な使用状況によります。

## articles/search/media/search-what-is-an-index/add-index-import-samples.png{#item-16c539}

### Summary

```json
{
    "modification_type": "new feature",
    "modification_title": "新しい画像ファイルの追加"
}
```

### Explanation
このコードの差分では、新しい画像ファイル `add-index-import-samples.png` が追加されたことを示しています。この画像は、Microsoftのドキュメントにおける「インデックスの追加」に関連します。変更は0であるため、実質的な内容の変更はありませんが、新しい画像が追加されたことで、該当する文章や内容が視覚的に補完され、より理解しやすくなることが期待されます。画像はGitHub上で指定されたURLから確認でき、ドキュメント全体のクオリティ向上に寄与する要素として重要です。

## articles/search/media/search-what-is-an-index/add-index.png{#item-80036e}

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "画像ファイルの更新"
}
```

### Explanation
このコードの差分では、画像ファイル `add-index.png` が変更されていることを示していますが、追加、削除、実質的な変更は行われていません。ここでの「修正」は、画像自体かそのメタデータに対する軽微な調整の可能性があります。この画像は「インデックスの追加」に関するMicrosoftのドキュメントに関連しており、視覚的なコンテンツの改善が期待されます。ユーザーは、指定されたGitHubのURLからこの更新された画像を確認することができ、文書の理解を助けるために利用されます。

## articles/search/media/semantic-search-overview/add-semantic-config.png{#item-6f27e6}

### Summary

```json
{
    "modification_type": "new feature",
    "modification_title": "新しい画像ファイルの追加"
}
```

### Explanation
このコードの差分では、新しい画像ファイル `add-semantic-config.png` が追加されたことを示しています。この画像は、Microsoftのドキュメント内で「セマンティック検索の概要」に関連しており、関連する情報を視覚的に補完する役割を果たします。変更内容としては、既存のファイルへの追加のみが行われており、他に具体的な変更はありませんが、画像の追加により、ドキュメントの内容がより豊かになり、読者にとっての理解が促進されることが期待されます。ユーザーは、指定されたGitHubのURLからこの画像を直接確認することができます。

## articles/search/media/semantic-search-overview/create-semantic-config.png{#item-664967}

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "画像ファイルの修正"
}
```

### Explanation
このコードの差分では、画像ファイル `create-semantic-config.png` が修正されたことを示しています。具体的な追加や削除は行われていないものの、画像自体またはその関連情報に対して軽微な変更が行われた可能性があります。この画像は「セマンティック検索の概要」に関連しており、文書の内容を視覚的に補強するために使用されます。ユーザーは、指定されたGitHubのURLからこの更新された画像を確認することができ、ドキュメントの理解を深める手助けとなります。

## articles/search/media/semantic-search-overview/semantic-search-billing.png{#item-79aec1}

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "画像ファイルの修正"
}
```

### Explanation
このコードの差分では、画像ファイル `semantic-search-billing.png` が修正されたことが示されています。具体的な追加や削除はないものの、この画像には軽微な変更が加えられた可能性があります。この画像は「セマンティック検索の請求」に関連する内容を視覚的に提供しており、ユーザーの理解を助ける役割を果たします。変更された画像は、指定されたGitHubのURLから確認可能であり、ドキュメントの内容がどのように更新されたかを把握することができます。

## articles/search/search-how-to-create-search-index.md{#item-c4ff31}

<details>
<summary>Diff</summary>
````diff
@@ -2,14 +2,12 @@
 title: Create an index
 titleSuffix: Azure AI Search
 description: Create a search index using the Azure portal, REST APIs, or an Azure SDK.
-
 manager: nitinme
 author: HeidiSteen
 ms.author: heidist
-
 ms.service: azure-ai-search
 ms.topic: how-to
-ms.date: 07/01/2024
+ms.date: 10/20/2024
 ---
 
 # Create an index in Azure AI Search
@@ -20,7 +18,7 @@ In this article, learn the steps for defining a schema for a [**search index**](
 
 + Write permissions as a [**Search Service Contributor**](search-security-rbac.md) or an [admin API key](search-security-api-keys.md) for key-based authentication.
 
-+ An understanding of the data you want to index. A search index is based on external content that you want to make searchable. Searchable content is stored as fields in an index. You should have a clear idea of which source fields you want to make searchable, retrievable, filterable, facetable, and sortable (see the [schema checklist](#schema-checklist) for guidance).
++ An understanding of the data you want to index. A search index is based on external content that you want to make searchable. Searchable content is stored as fields in an index. You should have a clear idea of which source fields you want to make searchable, retrievable, filterable, facetable, and sortable. See the [schema checklist](#schema-checklist) for guidance.
 
 + You must also have a unique field in source data that can be used as the [document key (or ID)](#document-keys) in the index.
 
@@ -46,7 +44,7 @@ Use this checklist to assist the design decisions for your search index.
 
 1. Review [supported data types](/rest/api/searchservice/supported-data-types). The data type affects how the field is used. For example, numeric content is filterable but not full text searchable. The most common data type is `Edm.String` for searchable text, which is tokenized and queried using the full text search engine. The most common data type for a vector field is `Edm.Single` but you can use other types as well.
 
-1. Identify a [document key](#document-keys). A document key is an index requirement. It's a single string field and it's populated from a source data field that contains unique values. For example, if you're indexing from Blob Storage, the metadata storage path is often used as the document key because it uniquely identifies each blob in the container.
+1. Identify a [document key](#document-keys). A document key is an index requirement. It's a single string field populated from a source data field that contains unique values. For example, if you're indexing from Blob Storage, the metadata storage path is often used as the document key because it uniquely identifies each blob in the container.
 
 1. Identify the fields in your data source that contribute searchable content in the index.
 
@@ -93,16 +91,18 @@ Index design through the portal enforces requirements and schema rules for speci
 
 1. Check for space. Search services are subject to [maximum number of indexes](search-limits-quotas-capacity.md), varying by service tier. Make sure you have room for a second index.
 
-1. In the search service Overview page, choose either option for creating a search index: 
+1. In the search service **Overview** page, choose either option for creating a search index: 
 
    + **Add index**, an embedded editor for specifying an index schema
    + [**Import wizards**](search-import-data-portal.md)
 
    The wizard is an end-to-end workflow that creates an indexer, a data source, and a finished index. It also loads the data. If this is more than what you want, use **Add index** instead.
 
-The following screenshot highlights where **Add index** and **Import data** appear on the command bar. After an index is created, you can find it again in the **Indexes** tab.
+The following screenshot highlights where **Add index**, **Import data**, and **Import and vectorize data** appear on the command bar. 
+
+:::image type="content" source="media/search-what-is-an-index/add-index.png" alt-text="Screenshot of the options to add an index." border="true":::
 
-  :::image type="content" source="media/search-what-is-an-index/add-index.png" alt-text="Add index command" border="true":::
+After an index is created, you can find it again on the **Indexes** page from the left navigation pane.
 
 > [!TIP]
 > After creating an index in the portal, you can copy the JSON representation and add it to your application code.
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "検索インデックス作成のマークダウン文書の修正"
}
```

### Explanation
このコードの差分では、`search-how-to-create-search-index.md` というマークダウン文書に対して修正が行われています。具体的には、8行の追加と8行の削除があり、全体で16行が変更されています。主な変更点は、文書の日付が2024年7月1日から2024年10月20日に更新されたこと、及び文書の内容がより明確になるように若干の文言修正が行われたことです。

修正された内容には、検索インデックスを作成する際の手順や要件に関する説明が含まれており、特に「ドキュメントキー」の識別やインデックス作成時の操作手順の説明が改善されています。また、インデックス作成に関する新しい手順が強調されており、ユーザーはこの文書を通じてAzure AI Searchの利用方法をより理解しやすくなっています。修正された文書は指定されたGitHubのURLからアクセスでき、更新された内容を確認できます。

## articles/search/search-import-data-portal.md{#item-b804d1}

<details>
<summary>Diff</summary>
````diff
@@ -31,13 +31,19 @@ This article isn't a step by step. For help with using the wizard with built-in
 
 ## Starting the wizards
 
-In the [Azure portal](https://portal.azure.com), open the search service page from the dashboard or [find your service](https://portal.azure.com/#blade/HubsExtension/BrowseResourceBlade/resourceType/Microsoft.Search%2FsearchServices) in the service list. 
+1. In the [Azure portal](https://portal.azure.com), open the search service page from the dashboard or [find your service](https://portal.azure.com/#blade/HubsExtension/BrowseResourceBlade/resourceType/Microsoft.Search%2FsearchServices) in the service list. 
 
-In the service Overview page at the top, select **Import data** or **Import and vectorize data**.
+1. In the service Overview page at the top, select **Import data** or **Import and vectorize data**.
 
-:::image type="content" source="media/search-import-data-portal/import-data-cmd.png" alt-text="Screenshot of the import wizard options on the action bar.":::
+    :::image type="content" source="media/search-what-is-an-index/add-index.png" alt-text="Screenshot of the add index options." border="true"::: 
 
-The wizards open fully expanded in the browser window so that you have more room to work. 
+    The wizards open fully expanded in the browser window so that you have more room to work. 
+
+1. If you selected **Import data**, you can select the **Samples** option to use a prebuilt sample of data from a supported data source.
+
+    :::image type="content" source="media/search-what-is-an-index/add-index-import-samples.png" alt-text="Screenshot of the import data page with the samples option selected." border="true":::
+
+1. Follow the remaining steps in the wizard to create the index and indexer.
 
 You can also launch **Import data** from other Azure services, including Azure Cosmos DB, Azure SQL Database, SQL Managed Instance, and Azure Blob Storage. Look for **Add Azure AI Search** in the left-navigation pane on the service overview page.
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "データインポートウィザードに関するマークダウン文書の修正"
}
```

### Explanation
このコードの差分では、`search-import-data-portal.md` というマークダウン文書に対して修正が行われています。具体的には、10行が追加され、4行が削除され、全体で14行が変更されました。主な修正点は、Azureポータルでのデータインポートウィザードの利用に関する手順が明確に記述されたことです。

修正の中には、プロセスのステップが番号付きリストとして整理され、ユーザーが必要な操作をより簡便に理解できるようになっています。また、ウィザードで「サンプル」オプションを選択することにより、サポートされているデータソースからの事前構築されたデータを使用できることが追加されています。さらに、ウィザードの各ステップに関連するスクリーンショットも追加され、視覚的な理解を促進しています。

この文書の変更により、ユーザーはAzure AI Searchにおけるデータのインポート方法をよりスムーズに学ぶことができるようになっています。修正された文書は、指定されたGitHubのURLからアクセス可能です。

## articles/search/search-limits-quotas-capacity.md{#item-3b201a}

<details>
<summary>Diff</summary>
````diff
@@ -123,7 +123,7 @@ Maximum running times exist to provide balance and stability to the service as a
 | Maximum running time <sup>5</sup>| 1-3 minutes |2 or 24 hours |2 or 24 hours |2 or 24 hours |2 or 24 hours |N/A  |2 or 24 hours |2 or 24 hours |
 | Maximum running time for indexers with a skillset <sup>6</sup> | 3-10 minutes |2 hours |2 hours |2 hours |2 hours |N/A  |2 hours |2 hours |
 | Blob indexer: maximum blob size, MB |16 |16 |128 |256 |256 |N/A  |256 |256 |
-| Blob indexer: maximum characters of content extracted from a blob |32,000 |64,000 |4&nbsp;million |8&nbsp;million |16&nbsp;million |N/A |4&nbsp;million |4&nbsp;million |
+| Blob indexer: maximum characters of content extracted from a blob <sup>7</sup> |32,000 |64,000 |4&nbsp;million |8&nbsp;million |16&nbsp;million |N/A |4&nbsp;million |4&nbsp;million |
 
 <sup>1</sup> Free services have indexer maximum execution time of 3 minutes for blob sources and 1 minute for all other data sources. Indexer invocation is once every 180 seconds. For AI indexing that calls into Azure AI services, free services are limited to 20 free transactions per indexer per day, where a transaction is defined as a document that successfully passes through the enrichment pipeline (tip: you can reset an indexer to reset its count).
 
@@ -137,6 +137,8 @@ Maximum running times exist to provide balance and stability to the service as a
 
 <sup>6</sup> Skillset execution, and image analysis in particular, are computationally intensive and consume disproportionate amounts of available processing power. Running time for these workloads is shorter so that other jobs in the queue have more opportunity to run.
 
+<sup>7</sup> The maximum number of characters is based on Unicode code units, specifically UTF-16.
+
 > [!NOTE]
 > As stated in the [Index limits](#index-limits), indexers will also enforce the upper limit of 3000 elements across all complex collections per document starting with the latest GA API version that supports complex types (`2019-05-06`) onwards. This means that if you've created your indexer with a prior API version, you will not be subject to this limit. To preserve maximum compatibility, an indexer that was created with a prior API version and then updated with an API version `2019-05-06` or later, will still be **excluded** from the limits. Customers should be aware of the adverse impact of having very large complex collections (as stated previously) and we highly recommend creating any new indexers with the latest GA API version.
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "検索サービスの限界とクオータに関する文書の更新"
}
```

### Explanation
このコードの差分では、`search-limits-quotas-capacity.md` という文書に対して修正が行われています。具体的には、3行の追加と1行の削除があり、全体で4行が変更されています。主に、「Blobインデクサーが抽出できるコンテンツの最大文字数」に関する注釈と説明が追加されています。

変更された内容では、Blobインデクサーによって抽出されるコンテンツの最大文字数についての説明が行われており、その基準がUnicodeコード単位、具体的にはUTF-16であることが明記されています。また、注釈が追加されることで、ユーザーはBlobインデクサーの制限についてより詳細に理解できるようになっています。

これにより、この文書はユーザーに対して、Azure AI Searchの使用をより効果的に導く情報提供が強化されています。修正された文書には、指定されたGitHubのURLからアクセスできます。

## articles/search/search-what-is-an-index.md{#item-5a3344}

<details>
<summary>Diff</summary>
````diff
@@ -11,7 +11,7 @@ ms.service: azure-ai-search
 ms.custom:
   - ignite-2023
 ms.topic: conceptual
-ms.date: 08/19/2024
+ms.date: 10/21/2024
 ---
 
 # Search indexes in Azure AI Search
@@ -28,7 +28,7 @@ Prefer to be hands-on right away? See [Create a search index](search-how-to-crea
 
 ## Schema of a search index
 
-In Azure AI Search, indexes contain *search documents*. Conceptually, a document is a single unit of searchable data in your index. For example, a retailer might have a document for each product, a news organization might have a document for each article, a travel site might have a document for each hotel and destination, and so forth. Mapping these concepts to more familiar database equivalents: a *search index* equates to a *table*, and *documents* are roughly equivalent to *rows* in a table.
+In Azure AI Search, indexes contain *search documents*. Conceptually, a document is a single unit of searchable data in your index. For example, a retailer might have a document for each product, a university might have a document for each class, a travel site might have a document for each hotel and destination, and so forth. Mapping these concepts to more familiar database equivalents: a *search index* equates to a *table*, and *documents* are roughly equivalent to *rows* in a table.
 
 The structure of a document is determined by the *index schema*, as illustrated in the following example. The "fields" collection is typically the largest part of an index, where each field is named, assigned a [data type](/rest/api/searchservice/Supported-data-types), and attributed with allowable behaviors that determine how it's used.
 
@@ -110,9 +110,9 @@ Although you can add new fields at any time, existing field definitions are lock
 
 ## Physical structure and size
 
-In Azure AI Search, the physical structure of an index is largely an internal implementation. You can access its schema, query its content, monitor its size, and manage capacity, but the clusters themselves (indexes, [shards](index-similarity-and-scoring.md#sharding-effects-on-query-results), and other files and folders) are managed internally by Microsoft.
+In Azure AI Search, the physical structure of an index is largely an internal implementation. You can access its schema, query its content, monitor its size, and manage capacity, but the clusters themselves (inverted indexes, vector indexes, [shards](index-similarity-and-scoring.md#sharding-effects-on-query-results), and other files and folders) are managed internally by Microsoft.
 
-You can monitor index size in the Indexes tab in the Azure portal, or by issuing a [GET INDEX request](/rest/api/searchservice/indexes/get) against your search service. You can also issue a [Service Statistics request](/rest/api/searchservice/get-service-statistics/get-service-statistics) and check the value of storage size.
+You can monitor index size in the **Search management > Indexes** page in the Azure portal, or by issuing a [GET INDEX request](/rest/api/searchservice/indexes/get) against your search service. You can also issue a [Service Statistics request](/rest/api/searchservice/get-service-statistics/get-service-statistics) and check the value of storage size.
 
 The size of an index is determined by:
 
@@ -178,6 +178,7 @@ All indexing and query requests target an index. Endpoints are usually one of th
 
    + [Quickstart: REST](search-get-started-rest.md)
    + [Quickstart: Azure SDKs](search-get-started-text.md)
+   + [Quickstart: RAG (using Visual Studio Code and a Jupyter notebook)](search-get-started-rag.md)
 
 ## Next steps
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "Azure AI Searchにおけるインデックスの定義に関する文書の修正"
}
```

### Explanation
このコードの差分では、`search-what-is-an-index.md` という文書に対して修正が行われています。具体的には、5行が追加され、4行が削除され、全体で9行が変更されています。主な変更点は、いくつかの用語の修正と更新、そしてコンテンツの拡充です。

まず、文書の日付が「08/19/2024」から「10/21/2024」に変更され、新しい情報を反映しています。具体的な内容に関しては、インデックス内の検索ドキュメントの例が小売業者から大学のクラスに変更され、より多様な利用ケースを示しています。また、インデックスの物理構造の説明がより詳細になり、内部実装の一部であるインバーテッドインデックスやベクターインデックスについての言及が追加されています。

さらに、Azureポータルでのインデックスサイズの監視方法が明確になり、「検索管理 > インデックス」ページへの参照が追加されています。最後に、新しいクイックスタートガイドへのリンクも追加され、ユーザーがRAG（Retriever-Augmented Generation）を利用するための手順が紹介されています。

これにより、ユーザーはAzure AI Searchに関する知識を深め、インデックスに関連する操作をより効果的に行うことができるようになります。修正された文書は、指定されたGitHubのURLからアクセス可能です。

## articles/search/semantic-how-to-configure.md{#item-7a92a6}

<details>
<summary>Diff</summary>
````diff
@@ -2,15 +2,14 @@
 title: Configure semantic ranker
 titleSuffix: Azure AI Search
 description: Add a semantic configuration to a search index.
-
 manager: nitinme
 author: HeidiSteen
 ms.author: heidist
 ms.service: azure-ai-search
 ms.custom:
   - ignite-2023
 ms.topic: how-to
-ms.date: 09/24/2024
+ms.date: 10/20/2024
 ---
 
 # Configure semantic ranker and return captions in search results
@@ -29,7 +28,7 @@ This article explains how to configure a search index for semantic reranking.
 
 ## Choose a client
 
-You can use any of the following tools and SDKs to add a semantic configuration:
+You can use any of the following tools and software development kits (SDKs) to add a semantic configuration:
 
 + [Azure portal](https://portal.azure.com), using the index designer to add a semantic configuration.
 + [Visual Studio Code](https://code.visualstudio.com/download) with the [REST client](https://marketplace.visualstudio.com/items?itemName=humao.rest-client)
@@ -61,15 +60,18 @@ Across all semantic configuration properties, the fields you assign must be:
 
 1. Sign in to the [Azure portal](https://portal.azure.com) and navigate to a search service that has [semantic ranking enabled](semantic-how-to-enable-disable.md).
 
-1. From **Indexes** on the left-navigation pane, open an index.
+1. From **Indexes** on the left-navigation pane, select an index.
+
+1. Select **Semantic configurations** and then select **Add semantic configuration**.
 
-1. Select **Semantic Configurations** and then select **Add Semantic Configuration**.
+   :::image type="content" source="./media/semantic-search-overview/add-semantic-config.png" alt-text="Screenshot that shows the option to add a semantic configuration in the Azure portal." lightbox="./media/semantic-search-overview/add-semantic-config.png" border="true":::
 
-   The **New Semantic Configuration** page opens with options for selecting a title field, content fields, and keyword fields. Only searchable and retrievable string fields are eligible. Make sure to list content fields and keyword fields in priority order.
+1. On the **New semantic configuration** page, enter a semantic configuration name and select the fields to use in the semantic configuration. Only searchable and retrievable string fields are eligible. Make sure to list content fields and keyword fields in priority order.
 
    :::image type="content" source="./media/semantic-search-overview/create-semantic-config.png" alt-text="Screenshot that shows how to create a semantic configuration in the Azure portal." lightbox="./media/semantic-search-overview/create-semantic-config.png" border="true":::
 
-   Select **OK** to save the changes.
+1. Select **Save** to save the configuration settings.
+1. Select **Save** again on the index page to save the semantic configuration in the index.
 
 ### [**REST API**](#tab/rest)
 
@@ -163,27 +165,20 @@ If your semantic ranking code is using preview APIs, this section explains how t
 + [Azure SDK for Java (11.6) change log](https://github.com/Azure/azure-sdk-for-java/blob/azure-search-documents_11.6.1/sdk/search/azure-search-documents/CHANGELOG.md#1160-2023-11-13)
 + [Azure SDK for JavaScript (12.0) change log](https://github.com/Azure/azure-sdk-for-js/blob/%40azure/search-documents_12.0.0/sdk/search/search-documents/CHANGELOG.md#1200-2023-11-13)
 
-**Behavior changes:**
-
-+ As of July 14, 2023, semantic ranker is language agnostic. It can rerank results composed of multilingual content, with no bias towards a specific language. In preview versions, semantic ranking would deprioritize results differing from the language specified by the field analyzer.
-
-+ In 2021-04-30-Preview and all later versions, for the REST API and all SDK packages targeting the same version: `semanticConfiguration` (in an index definition) defines which search fields are used in semantic ranking. Previously in the 2020-06-30-Preview REST API, `searchFields` (in a query request) was used for field specification and prioritization. This approach only worked in 2020-06-30-Preview and is obsolete in all other versions.
-
-### Step 1: Remove queryLanguage
 
-The semantic ranking engine is now language agnostic. If `queryLanguage` is specified in your query logic, it's no longer used for semantic ranking, but still applies to [spell correction](speller-how-to-add.md). 
+### queryLanguage for semantic ranker
 
-Keep `queryLanguage` if you're using speller, and if the language value is [supported by speller](speller-how-to-add.md#supported-languages). Spell check has limited availability across languages. 
+As of July 14, 2023, semantic ranker is language agnostic. It can rerank results composed of multilingual content, with no bias towards a specific language. In preview versions, semantic ranking would deprioritize results differing from the language specified by the field analyzer.
 
-Otherwise, delete `queryLanguage`.
+Stop using `queryLanguage` in your code if you were using it for semantic ranking. The `queryLanguage` property is still applicable to features such as [spell correction](speller-how-to-add.md), but not to semantic ranking.
 
-### Step 2: Replace `searchFields` with `semanticConfiguration`
+### searchFields for semantic ranker
 
-If your code calls the 2020-06-30-Preview REST API or beta SDK packages targeting that REST API version, you might be using `searchFields` in a query request to specify semantic fields and priorities. In initial beta versions, `searchFields` had a dual purpose, constraining the initial query to the fields listed in `searchFields`, and also setting field priority if semantic ranking was used. In later versions, `searchFields` retains its original purpose, but is no longer used for semantic ranking.
+For the REST API and all SDK packages targeting version `2021-04-30-Preview` and later, the `searchFields` property is no longer used for semantic ranking.
 
-Keep `searchFields` in query requests if you're using it to limit full text search to the list of named fields.
+Instead, use the `semanticConfiguration` property (in a search index) to determine which search fields are used in semantic ranking. To specify field prioritization, add a `semanticConfiguration` to in an index schema following the [instructions in this article](#add-a-semantic-configuration).
 
-Add a `semanticConfiguration` to an index schema to specify field prioritization, following the [instructions in this article](#add-a-semantic-configuration).
+You can keep `searchFields` in query requests if you're using it to limit full text search to the list of named fields. 
 
 ## Next steps
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "セマンティックランカーの設定方法に関する文書の更新"
}
```

### Explanation
このコードの差分では、`semantic-how-to-configure.md` という文書が修正されています。具体的には、16行の追加と21行の削除が行われ、全体で37行が変更されています。修正内容には主に、用語の明確化、手順の再構成、そして内容の更新が含まれています。

まず、文書の日付が「09/24/2024」から「10/20/2024」に変更され、最新の情報を反映しています。用語に関しては "SDKs" と表現されていた部分が "software development kits (SDKs)" に修正され、読者に対する理解が促されています。

手順のセクションでは、「インデックスの選択」についての指示が改訂され、「選択する」という言葉が用いられています。また、新たに「セマンティック構成を追加」という手順が追加され、視覚的な要素（スクリーンショット）が挿入されたことにより、手順が分かりやすくなりました。

さらに、セマンティックランカーに関連するコードの取り扱いについても整理され、以前のAPIバージョンに関する情報と併せて、`queryLanguage` や `searchFields` の適用についての指針が明確化されています。これにより、ユーザーがセマンティックランカーを使用する際の注意点や最適な方法が示されています。

このような変更を通じて、Azure AI Searchのセマンティック機能に関する理解が深まり、より明確で使いやすいガイダンスが提供されるようになっています。修正された文書には、指定されたGitHubのURLからアクセス可能です。

## articles/search/semantic-how-to-enable-disable.md{#item-71ac1e}

<details>
<summary>Diff</summary>
````diff
@@ -15,7 +15,7 @@ ms.date: 09/24/2024
 
 # Enable or disable semantic ranker
 
-Semantic ranker is a premium feature that's billed by usage. By default, semantic ranker is turned off on a new search service, but it can be enabled by anyone with **Contributor** permissions. If you don't want anyone enabling it inadvertently, you can [disable it using the REST API](#disable-semantic-ranker-using-the-rest-api).
+Semantic ranker is a premium feature billed by usage. By default, semantic ranker is turned off on a new search service, but it can be enabled by anyone with **Contributor** permissions. If you don't want anyone enabling it inadvertently, you can [disable it using the REST API](#disable-semantic-ranker-using-the-rest-api).
 
 ## Check availability
 
@@ -31,13 +31,13 @@ Follow these steps to enable [semantic ranker](semantic-search-overview.md) at t
 
 1. Navigate to your search service. On the **Overview** page, make sure the service is a billable tier, Basic or higher.
 
-1. On the left-nav pane, select **Settings** > **Semantic ranking**.
+1. On the left-navigation pane, select **Settings** > **Semantic ranker**.
 
 1. Select either the **Free plan** or the **Standard plan**. You can switch between the free plan and the standard plan at any time.
 
    :::image type="content" source="media/semantic-search-overview/semantic-search-billing.png" alt-text="Screenshot of enabling semantic ranking in the Azure portal." border="true":::
 
-The free plan is capped at 1,000 queries per month. After the first 1,000 queries in the free plan, an error message indicates you've exhausted your quota on the next semantic query. When quota is exhausted, you should upgrade to the standard plan to continue using semantic ranking.
+The free plan is capped at 1,000 queries per month. After the first 1,000 queries in the free plan, an error message indicates you exhausted your quota on the next semantic query. When quota is exhausted, you should upgrade to the standard plan to continue using semantic ranking.
 
 ### [**REST**](#tab/enable-rest)
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "セマンティックランカーの有効化・無効化に関する文書の修正"
}
```

### Explanation
このコードの差分では、`semantic-how-to-enable-disable.md` という文書が修正されており、3行の追加と3行の削除が行われています。全体で6行の変更があり、内容にわずかな改善が加えられています。

主な変更点は、文書の日付が「09/24/2024」に設定されていることを確認することから始まり、セマンティックランカーの機能の説明が若干の文言修正によって明確にされています。具体的には、「Semantic ranker is a premium feature that’s billed by usage.」という文が「Semantic ranker is a premium feature billed by usage.」に修正されています。この修正により、文が一貫性を持ち、読みやすさが向上しています。

さらに、手順の一部でも用語が調整されており、「Semantic ranking」から「Semantic ranker」に変更されています。この変更は、用語の一貫性を保ち、利用者がより理解しやすくなることを意図しています。

全体として、これらの修正により、Azure AI Searchのセマンティックランカーの有効化および無効化に関するガイダンスがより明確かつ一貫性があり、利用者がその機能を効果的に活用できるように配慮されています。修正された文書は、指定されたGitHubのURLからアクセス可能です。

## articles/search/semantic-how-to-query-request.md{#item-85530d}

<details>
<summary>Diff</summary>
````diff
@@ -71,21 +71,22 @@ In this step, add parameters to the query request. To be successful, your query
 
    :::image type="content" source="./media/semantic-search-overview/semantic-portal-json-query.png" alt-text="Screenshot showing JSON query syntax in the Azure portal." border="true":::
 
-   Here's some JSON text that you can paste into the view:
+   Here's a JSON example that you can paste into the view:
 
-   ```json
+    ```json
     {
-        "queryType": "semantic",
-        "search": "historic hotel with good food",
-        "semanticConfiguration": "my-semantic-config",
-        "answers": "extractive|count-3",
-        "captions": "extractive|highlight-true",
-        "highlightPreTag": "<strong>",
-        "highlightPostTag": "</strong>",
-        "select": "HotelId,HotelName,Description,Category",
-        "count": true
+      "search": "historic hotel with good food",
+      "count": true,
+      "queryType": "semantic",
+      "semanticConfiguration": "my-semantic-config",
+      "captions": "extractive|highlight-true",
+      "answers": "extractive|count-3",
+      "queryLanguage": "en-us",
+      "highlightPreTag": "<strong>",
+      "highlightPostTag": "</strong>",
+      "select": "HotelId,HotelName,Description,Category"
     }
-   ```
+    ```
 
 ### [**REST API**](#tab/rest-query)
 
@@ -95,10 +96,10 @@ A response includes an `@search.rerankerScore` automatically. If you want captio
 
 The following example in this section uses the [hotels-sample-index](search-get-started-portal.md) to demonstrate semantic ranking with semantic answers and captions.
 
-1. Paste the following request into a web client as a template. Replace the service name and index name with valid values.
+1. Paste the following request into a web client as a template. Replace `search-service-name` with your search service name and replace `hotels-sample-index` if you have a different index name.
 
     ```http
-    POST https://[service name].search.windows.net/indexes/hotels-sample-index/docs/search?api-version=2024-07-01      
+    POST https://[search-service-name].search.windows.net/indexes/hotels-sample-index/docs/search?api-version=2024-07-01      
     {
         "queryType": "semantic",
         "search": "newer hotel near the water with a great restaurant",
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "セマンティッククエリリクエストに関する文書の更新"
}
```

### Explanation
このコードの差分では、`semantic-how-to-query-request.md`という文書が修正されています。修正内容には15行の追加と14行の削除が含まれており、全体で29行の変更があります。これらの変更は、文書の明確さとユーザビリティを向上させることを目的としています。

主な変更点の一つは、例として提示されたJSON構造内の項目の順序が整理され、より読みやすくなりました。具体的には、`"search"`、`"count"`、`"queryType"`、`"semanticConfiguration"` などの要素が明確な並びで示されています。

また、「Here’s some JSON text that you can paste into the view:」という文が「Here’s a JSON example that you can paste into the view:」に変更され、より具体的かつ理解しやすい表現となっています。

さらに、HTTPリクエストの例文において、サービス名やインデックス名の置換に関する説明が分かりやすくなり、「`search-service-name`」と明記されています。このように、ユーザーが具体的にどの部分を置き換えればよいかが明示されており、ガイダンスが一層適切なものになっています。

全体として、これらの変更は文書をより直感的にし、ユーザーがセマンティッククエリのリクエストを成功裏に行えるようにするための重要な改善を反映しています。修正された文書は、指定されたGitHubのURLからアクセス可能です。

## articles/search/tutorial-optimize-indexing-push-api.md{#item-ef0e96}

<details>
<summary>Diff</summary>
````diff
@@ -1,20 +1,20 @@
 ---
-title: 'C# tutorial optimize indexing with the push API'
+title: 'C# tutorial: Optimize indexing by using the push API'
 titleSuffix: Azure AI Search
-description: Learn how to efficiently index data using Azure AI Search's push API. This tutorial and sample code are in C#.
+description: Learn how to efficiently index data by using Azure AI Search's push API. This tutorial and sample code are in C#.
 author: gmndrg
 ms.author: gimondra
 ms.service: azure-ai-search
 ms.topic: tutorial
-ms.date: 1/18/2024
+ms.date: 10/14/2024
 ms.custom:
   - devx-track-csharp
   - ignite-2023
 ---
 
-# Tutorial: Optimize indexing with the push API
+# Tutorial: Optimize indexing by using the push API
 
-Azure AI Search supports [two basic approaches](search-what-is-data-import.md) for importing data into a search index: *push* your data into the index programmatically, or pointing an [Azure AI Search indexer](search-indexer-overview.md) at a supported data source to *pull* in the data.
+Azure AI Search supports [two basic approaches](search-what-is-data-import.md) for importing data into a search index: *push* your data into the index programmatically, or *pull* in the data by pointing an [Azure AI Search indexer](search-indexer-overview.md) at a supported data source.
 
 This tutorial explains how to efficiently index data using the [push model](search-what-is-data-import.md#pushing-data-to-an-index) by batching requests and using an exponential backoff retry strategy. You can [download and run the sample application](https://github.com/Azure-Samples/azure-search-dotnet-scale/tree/main/optimize-data-indexing). This article explains the key aspects of the application and what factors to consider when indexing data.
 
@@ -27,51 +27,50 @@ This tutorial uses C# and the [Azure.Search.Documents library](/dotnet/api/overv
 > * Use multiple threads to increase indexing speeds
 > * Use an exponential backoff retry strategy to retry failed documents
 
-If you don't have an Azure subscription, create a [free account](https://azure.microsoft.com/free/?WT.mc_id=A261C142F) before you begin.
-
 ## Prerequisites
 
 The following services and tools are required for this tutorial.
 
-+ [Visual Studio](https://visualstudio.microsoft.com/downloads/), any edition. Sample code and instructions were tested on the free Community edition.
++ An Azure subscription. If you don't have one, you can [create a free account](https://azure.microsoft.com/free/?WT.mc_id=A261C142F).
 
-+ [Create an Azure AI Search service](search-create-service-portal.md) or [find an existing service](https://portal.azure.com/#blade/HubsExtension/BrowseResourceBlade/resourceType/Microsoft.Search%2FsearchServices) under your current subscription.
++ [Visual Studio](https://visualstudio.microsoft.com/downloads/), any edition. Sample code and instructions were tested on the free Community edition.
 
 <a name="get-service-info"></a>
 
 ## Download files
 
-Source code for this tutorial is in the [optimize-data-indexing/v11](https://github.com/Azure-Samples/azure-search-dotnet-scale/tree/main/optimize-data-indexing/v11) folder in the [Azure-Samples/azure-search-dotnet-samples](https://github.com/Azure-Samples/azure-search-dotnet-samples) GitHub repository.
+Source code for this tutorial is in the [optimize-data-indexing/v11](https://github.com/Azure-Samples/azure-search-dotnet-scale/tree/main/optimize-data-indexing/v11) folder in the [Azure-Samples/azure-search-dotnet-scale](https://github.com/Azure-Samples/azure-search-dotnet-scale) GitHub repository.
 
 ## Key considerations
 
-Factors affecting indexing speeds are listed next. You can learn more in [Index large data sets](search-howto-large-index.md).
+Factors that affect indexing speeds are listed next. To learn more, see [Index large data sets](search-howto-large-index.md).
 
-+ **Service tier and number of partitions/replicas** - Adding partitions or upgrading your tier increases indexing speeds.
-+ **Index schema complexity** - Adding fields and field properties lowers indexing speeds. Smaller indexes are faster to index.
-+ **Batch size** - The optimal batch size varies based on your index schema and dataset.
-+ **Number of threads/workers** - A single thread won't take full advantage of indexing speeds.
-+ **Retry strategy** - An exponential backoff retry strategy is a best practice for optimum indexing.
-+ **Network data transfer speeds** - Data transfer speeds can be a limiting factor. Index data from within your Azure environment to increase data transfer speeds.
++ **Service tier and number of partitions/replicas**: Adding partitions or upgrading your tier increases indexing speeds.
++ **Index schema complexity**: Adding fields and field properties lowers indexing speeds. Smaller indexes are faster to index.
++ **Batch size**: The optimal batch size varies based on your index schema and dataset.
++ **Number of threads/workers**: A single thread doesn't take full advantage of indexing speeds.
++ **Retry strategy**: An exponential backoff retry strategy is a best practice for optimum indexing.
++ **Network data transfer speeds**: Data transfer speeds can be a limiting factor. Index data from within your Azure environment to increase data transfer speeds.
 
-## 1 - Create Azure AI Search service
+## Step 1: Create an Azure AI Search service
 
-To complete this tutorial, you need an Azure AI Search service, which you can [create in the portal](search-create-service-portal.md). We recommend using the same tier you plan to use in production so that you can accurately test and optimize indexing speeds.
+To complete this tutorial, you need an Azure AI Search service, which you can [create in the Azure portal](search-create-service-portal.md), or [find an existing service](https://portal.azure.com/#blade/HubsExtension/BrowseResourceBlade/resourceType/Microsoft.Search%2FsearchServices) under your current subscription. We recommend using the same tier you plan to use in production so that you can accurately test and optimize indexing speeds.
 
-### Get an admin api-key and URL for Azure AI Search
+### Get an admin key and URL for Azure AI Search
 
-This tutorial uses key-based authentication. Copy an admin API key to paste into the **appsettings.json** file.
+This tutorial uses key-based authentication. Copy an admin API key to paste into the *appsettings.json* file.
 
-1. Sign in to the [Azure portal](https://portal.azure.com), and in your search service **Overview** page, get the URL. An example endpoint might look like `https://mydemo.search.windows.net`.
+1. Sign in to the [Azure portal](https://portal.azure.com). Get the endpoint URL from your search service **Overview** page. An example endpoint might look like `https://mydemo.search.windows.net`.
 
 1. In **Settings** > **Keys**, get an admin key for full rights on the service. There are two interchangeable admin keys, provided for business continuity in case you need to roll one over. You can use either the primary or secondary key on requests for adding, modifying, and deleting objects.
 
-   ![Get an HTTP endpoint and access key](media/search-get-started-rest/get-url-key.png "Get an HTTP endpoint and access key")
+    :::image type="content" source="media/search-get-started-rest/get-url-key.png" alt-text="Screenshot of the HTTP endpoint and API key locations.":::
+
+## Step 2: Set up your environment
 
-## 2 - Set up your environment
+1. Start Visual Studio and open *OptimizeDataIndexing.sln*.
 
-1. Start Visual Studio and open **OptimizeDataIndexing.sln**.
-1. In Solution Explorer, open **appsettings.json** to provide connection information.
+1. In Solution Explorer, open *appsettings.json* to provide your service's connection information.
 
 ```json
 {
@@ -81,34 +80,34 @@ This tutorial uses key-based authentication. Copy an admin API key to paste into
 }
 ```
 
-## 3 - Explore the code
+## Step 3: Explore the code
 
-Once you update *appsettings.json*, the sample program in **OptimizeDataIndexing.sln** should be ready to build and run.
+Once you update *appsettings.json*, the sample program in *OptimizeDataIndexing.sln* should be ready to build and run.
 
 This code is derived from the C# section of [Quickstart: Full text search using the Azure SDKs](search-get-started-text.md). You can find more detailed information on the basics of working with the .NET SDK in that article.
 
 This simple C#/.NET console app performs the following tasks:
 
-+ Creates a new index based on the data structure of the C# Hotel class (which also references the Address class).
++ Creates a new index based on the data structure of the C# `Hotel` class (which also references the `Address` class)
 + Tests various batch sizes to determine the most efficient size
 + Indexes data asynchronously
     + Using multiple threads to increase indexing speeds
     + Using an exponential backoff retry strategy to retry failed items
 
  Before running the program, take a minute to study the code and the index definitions for this sample. The relevant code is in several files:
 
-  + **Hotel.cs** and **Address.cs** contains the schema that defines the index
-  + **DataGenerator.cs** contains a simple class to make it easy to create large amounts of hotel data
-  + **ExponentialBackoff.cs** contains code to optimize the indexing process as described in this article
-  + **Program.cs** contains functions that create and delete the Azure AI Search index, indexes batches of data, and tests different batch sizes
+  + *Hotel.cs* and *Address.cs* contain the schema that defines the index
+  + *DataGenerator.cs* contains a simple class to make it easy to create large amounts of hotel data
+  + *ExponentialBackoff.cs* contains code to optimize the indexing process as described in this article
+  + *Program.cs* contains functions that create and delete the Azure AI Search index, indexes batches of data, and tests different batch sizes
 
-### Creating the index
+### Create the index
 
 This sample program uses the Azure SDK for .NET to define and create an Azure AI Search index. It takes advantage of the `FieldBuilder` class to generate an index structure from a C# data model class.
 
-The data model is defined by the Hotel class, which also contains references to the Address class. The FieldBuilder drills down through multiple class definitions to generate a complex data structure for the index. Metadata tags are used to define the attributes of each field, such as whether it's searchable or sortable.
+The data model is defined by the `Hotel` class, which also contains references to the `Address` class. The FieldBuilder drills down through multiple class definitions to generate a complex data structure for the index. Metadata tags are used to define the attributes of each field, such as whether it's searchable or sortable.
 
-The following snippets from the **Hotel.cs** file show how a single field, and a reference to another data model class, can be specified.
+The following snippets from the *Hotel.cs* file show how a single field, and a reference to another data model class, can be specified.
 
 ```csharp
 . . .
@@ -119,7 +118,7 @@ public Address Address { get; set; }
 . . .
 ```
 
-In the **Program.cs** file, the index is defined with a name and a field collection generated by the `FieldBuilder.Build(typeof(Hotel))` method, and then created as follows:
+In the *Program.cs* file, the index is defined with a name and a field collection generated by the `FieldBuilder.Build(typeof(Hotel))` method, and then created as follows:
 
 ```csharp
 private static async Task CreateIndexAsync(string indexName, SearchIndexClient indexClient)
@@ -134,9 +133,9 @@ private static async Task CreateIndexAsync(string indexName, SearchIndexClient i
 }
 ```
 
-### Generating data
+### Generate data
 
-A simple class is implemented in the **DataGenerator.cs** file to generate data for testing. The sole purpose of this class is to make it easy to generate a large number of documents with a unique ID for indexing.
+A simple class is implemented in the *DataGenerator.cs* file to generate data for testing. The sole purpose of this class is to make it easy to generate a large number of documents with a unique ID for indexing.
 
 To get a list of 100,000 hotels with unique IDs, run the following lines of code:
 
@@ -146,18 +145,18 @@ DataGenerator dg = new DataGenerator();
 List<Hotel> hotels = dg.GetHotels(numDocuments, "large");
 ```
 
-There are two sizes of hotels available for testing in this sample: **small** and  **large**.
+There are two sizes of hotels available for testing in this sample: *small* and *large*.
 
 The schema of your index has an effect on indexing speeds. For this reason, it makes sense to convert this class to generate data that best matches your intended index schema after you run through this tutorial.
 
-## 4 - Test batch sizes
+## Step 4: Test batch sizes
 
 Azure AI Search supports the following APIs to load single or multiple documents into an index:
 
 + [Documents - Index (REST API)](/rest/api/searchservice/documents)
 + [IndexDocumentsAction class](/dotnet/api/azure.search.documents.models.indexdocumentsaction) or [IndexDocumentsBatch class](/dotnet/api/azure.search.documents.models.indexdocumentsbatch)
 
-Indexing documents in batches will significantly improve indexing performance. These batches can be up to 1000 documents, or up to about 16 MB per batch.
+Indexing documents in batches significantly improves indexing performance. These batches can be up to 1,000 documents, or up to about 16 MB per batch.
 
 Determining the optimal batch size for your data is a key component of optimizing indexing speeds. The two primary factors influencing the optimal batch size are:
 
@@ -204,7 +203,7 @@ public static async Task TestBatchSizesAsync(SearchClient searchClient, int min
 }
 ```
 
-Because not all documents are the same size (although they are in this sample), we estimate the size of the data we're sending to the search service. We do this using the function below that first converts the object to json and then determines its size in bytes. This technique allows us to determine which batch sizes are most efficient in terms of MB/s indexing speeds.
+Because not all documents are the same size (although they are in this sample), we estimate the size of the data we're sending to the search service. You can do this by using the following function that first converts the object to json and then determines its size in bytes. This technique allows us to determine which batch sizes are most efficient in terms of MB/s indexing speeds.
 
 ```csharp
 // Returns size of object in MB
@@ -227,26 +226,26 @@ public static double EstimateObjectSize(object data)
 }
 ```
 
-The function requires a `SearchClient` plus the number of tries you'd like to test for each batch size. Because there might be variability in indexing times for each batch, we try each batch three times by default to make the results more statistically significant.
+The function requires a `SearchClient` plus the number of tries you'd like to test for each batch size. Because there might be variability in indexing times for each batch, try each batch three times by default to make the results more statistically significant.
 
 ```csharp
 await TestBatchSizesAsync(searchClient, numTries: 3);
 ```
 
-When you run the function, you should see an output like below in your console:
+When you run the function, you should see an output in your console like the following example:
 
-   ![Output of test batch size function](media/tutorial-optimize-data-indexing/test-batch-sizes.png "Output of test batch size function")
+:::image type="content" source="media/tutorial-optimize-data-indexing/test-batch-sizes.png" alt-text="Screenshot of the output of test batch size function.":::
 
 Identify which batch size is most efficient and then use that batch size in the next step of the tutorial. You might see a plateau in MB/s across different batch sizes.
 
-## 5 - Index data
+## Step 5: Index the data
 
-Now that we've identified the batch size we intend to use, the next step is to begin to index the data. To index data efficiently, this sample:
+Now that you identified the batch size you intend to use, the next step is to begin to index the data. To index data efficiently, this sample:
 
-+ Uses multiple threads/workers.
-+ Implements an exponential backoff retry strategy.
++ uses multiple threads/workers
++ implements an exponential backoff retry strategy
 
-Uncomment lines 41 through 49 and rerun and the program. On this run, the sample generates and sends batches of documents, up to 100,000 if you run the code without changing the parameters.
+Uncomment lines 41 through 49, and then rerun the program. On this run, the sample generates and sends batches of documents, up to 100,000 if you run the code without changing the parameters.
 
 ### Use multiple threads/workers
 
@@ -256,8 +255,8 @@ Several of the key considerations previously mentioned can affect the optimal nu
 
 As you ramp up the requests hitting the search service, you might encounter [HTTP status codes](/rest/api/searchservice/http-status-codes) indicating the request didn't fully succeed. During indexing, two common HTTP status codes are:
 
-+ **503 Service Unavailable** - This error means that the system is under heavy load and your request can't be processed at this time.
-+ **207 Multi-Status** - This error means that some documents succeeded, but at least one failed.
++ **503 Service Unavailable**: This error means that the system is under heavy load and your request can't be processed at this time.
++ **207 Multi-Status**: This error means that some documents succeeded, but at least one failed.
 
 ### Implement an exponential backoff retry strategy
 
@@ -280,7 +279,7 @@ TimeSpan delay = delay = TimeSpan.FromSeconds(2);
 int maxRetryAttempts = 5;
 ```
 
-The results of the indexing operation are stored in the variable `IndexDocumentResult result`. This variable is important because it allows you to check if any documents in the batch failed as shown below. If there's a partial failure, a new batch is created based on the failed documents' ID.
+The results of the indexing operation are stored in the variable `IndexDocumentResult result`. This variable is important because it allows you to check if any documents in the batch failed, as shown in the following example. If there's a partial failure, a new batch is created based on the failed documents' ID.
 
 `RequestFailedException` exceptions should also be caught as they indicate the request failed completely and should also be retried.
 
@@ -338,17 +337,17 @@ do
 } while (true);
 ```
 
-From here, we wrap the exponential backoff code into a function so it can be easily called.
+From here, wrap the exponential backoff code into a function so it can be easily called.
 
-Another function is then created to manage the active threads. For simplicity, that function isn't included here but can be found in **ExponentialBackoff.cs**. The function can be called with the following command where `hotels` is the data we want to upload, `1000` is the batch size, and `8` is the number of concurrent threads:
+Another function is then created to manage the active threads. For simplicity, that function isn't included here but can be found in *ExponentialBackoff.cs*. The function can be called with the following command where `hotels` is the data we want to upload, `1000` is the batch size, and `8` is the number of concurrent threads:
 
 ```csharp
 await ExponentialBackoff.IndexData(indexClient, hotels, 1000, 8);
 ```
 
-When you run the function, you should see an output like below:
+When you run the function, you should see an output:
 
-![Output of index data function](media/tutorial-optimize-data-indexing/index-data-start.png "Output of index data function")
+:::image type="content" source="media/tutorial-optimize-data-indexing/index-data-start.png" alt-text="Screenshot that shows the output of an index data function.":::
 
 When a batch of documents fails, an error is printed out indicating the failure and that the batch is being retried:
 
@@ -359,9 +358,9 @@ When a batch of documents fails, an error is printed out indicating the failure
 
 After the function is finished running, you can verify that all of the documents were added to the index.
 
-## 6 - Explore index
+## Step 6: Explore the index
 
-You can explore the populated search index after the program has run programmatically or using the [**Search explorer**](search-explorer.md) in the portal.
+You can explore the populated search index after the program has run either programmatically or by using the [Search explorer](search-explorer.md) in the portal.
 
 ### Programatically
 
@@ -377,17 +376,17 @@ long indexDocCount = await searchClient.GetDocumentCountAsync();
 
 #### Get Index Statistics
 
-The Get Index Statistics operation returns a document count for the current index, plus storage usage. Index statistics will take longer than document count to update.
+The Get Index Statistics operation returns a document count for the current index, plus storage usage. Index statistics take longer than document count to update.
 
 ```csharp
 var indexStats = await indexClient.GetIndexStatisticsAsync(indexName);
 ```
 
 ### Azure portal
 
-In Azure portal, from the left navigation pane, and find the **optimize-indexing** index in the **Indexes** list.
+In the Azure portal, from the left navigation pane, and find the **optimize-indexing** index in the **Indexes** list.
 
-  ![List of Azure AI Search indexes](media/tutorial-optimize-data-indexing/portal-output.png "List of Azure AI Search indexes")
+:::image type="content" source="media/tutorial-optimize-data-indexing/portal-output.png" alt-text="Screenshow that shows a list of Azure AI Search indexes.":::
 
 The *Document Count* and *Storage Size* are based on [Get Index Statistics API](/rest/api/searchservice/indexes/get-statistics) and can take several minutes to update.
 
@@ -405,7 +404,7 @@ When you're working in your own subscription, at the end of a project, it's a go
 
 You can find and manage resources in the portal, using the **All resources** or **Resource groups** link in the left-navigation pane.
 
-## Next steps
+## Next step
 
 To learn more about indexing large amounts data, try the following tutorial.
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "プッシュAPIを使用したインデックス最適化に関するチュートリアルの更新"
}
```

### Explanation
このコードの差分では、`tutorial-optimize-indexing-push-api.md`という文書が修正されており、63行の追加と64行の削除が含まれています。全体で127行の変更があり、内容がより明確で理解しやすくなるように改善されています。

主な変更点は、タイトルと説明文の表現が明確化されていることです。具体的には、「C# tutorial optimize indexing with the push API」というタイトルが「C# tutorial: Optimize indexing by using the push API」に変更され、文の構造が改善されました。また、説明文でも「efficiency」が「by using」に変更されており、内容がより具体的に確認できます。

文書の構成も整理され、ステップや要件が明確に指示されるようになりました。例えば、「## 1 - Create Azure AI Search service」の見出しは「## Step 1: Create an Azure AI Search service」に変更され、各ステップがより順を追って説明されています。

さらに、インデックス作成やデータのテスト、インデックスの確認に関する具体的な手順も含まれており、ユーザーがチュートリアルに従いやすくなっています。イメージやコードのフォーマットも統一され、視覚的にもわかりやすくなっています。

全体として、これらの変更はAzure AI SearchのプッシュAPIを使用したインデックス最適化のチュートリアルを、より実用的で親しみやすいものにすることを目的としています。修正された文書は、指定されたGitHubのURLからアクセス可能です。


