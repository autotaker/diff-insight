---
date: '2024-12-06'
permalink: https://github.com/MicrosoftDocs/azure-ai-docs/compare/MicrosoftDocs:04e3114...MicrosoftDocs:d62332b
summary: 今回の変更では、Azure AIのアプリポータルおよび関連チュートリアルの更新が行われました。新しい画像ファイルが追加され、一部の画像が削除されるなど、ユーザー体験に直接影響を与える改訂が含まれています。特に、「ストレージとコストを最小化するチュートリアル」が新たに追加され、ユーザーが最新の情報に基づいて操作を行いやすくなるよう配慮されています。また、ドキュメントの内容も微調整され、情報の正確性と一貫性が確保されています。これにより、Azure
  AI製品の利用者体験の質が向上することを目指しています。
title: Diff Insight Report - search

---

[View Diff on GitHub](https://github.com/MicrosoftDocs/azure-ai-docs/compare/MicrosoftDocs:04e3114...MicrosoftDocs:d62332b){target="_blank"}

<format>
# Highlights
今回の変更では、画像ファイルとドキュメントの更新を通じて、Azure AI のアプリポータルや関連チュートリアルの改訂が進められました。特に、新しい画像やチュートリアルが追加され、また一部の画像は削除されるなど、ユーザー体験に直接影響を与える変更が含まれています。

## New features
- 新しい画像ファイル`enable-cors.png`、`import-data-hotels.png`、`side-by-side-comparison.png`の追加。
- 「ストレージとコストを最小化するチュートリアル」が追加されました。

## Breaking changes
- `import-data-realestate.png`および`start-app-enable-cors.png`の画像ファイルが削除されました。

## Other updates
- 複数の画像がマイナーアップデートにより修正され、ドキュメントが更新されました。
- 特定のチュートリアルやドキュメントの内容に対する微調整と用語の改善。

# Insights
今回の変更は、ドキュメントの視覚的および内容的な精緻化を通じて、ユーザーがAzure AIの機能を効果的に利用できるようにするためのものです。新しい画像の追加は、手順の視覚化を促進し、ユーザーが具体的な操作をより理解しやすくするのに役立ちます。

画像の削除に関しては、ドキュメントや実際の手順が変更された可能性を示しています。これにより、ユーザーは古い情報に惑わされることなく、最新の情報に基づいた操作を行えるようになります。

さらに、新しいチュートリアルの追加は、特にコスト管理やストレージの最適化を求めるユーザー向けに役立つリソースとなります。これにより、Azure AIサービスを活用しながら、効率的なリソース管理を学ぶことができ、ユーザーはより利益を得るでしょう。

微修正や用語の見直しなどドキュメントの更新は、情報の正確性と一貫性を確保し、ユーザーが技術的詳細を適切に理解できるようにするための重要なステップです。全体として、これらの変更はAzure AI製品の利用者体験の質を向上させ、利便性を高めることを目指しています。
</format>

# Summary Table
|  Filename  | Type |    Title    | Status | A  | D  | M  |
|------------|------|-------------|--------|----|----|----|
| [configure-results.png](#item-33a179) | minor update | 画像の更新: configure-results.png | modified | 0 | 0 | 0 | 
| [enable-cors.png](#item-6da392) | new feature | 新しい画像の追加: enable-cors.png | added | 0 | 0 | 0 | 
| [import-data-hotels.png](#item-ecf7e4) | new feature | 新しい画像の追加: import-data-hotels.png | added | 0 | 0 | 0 | 
| [import-data-realestate.png](#item-e0bcd9) | breaking change | 画像の削除: import-data-realestate.png | removed | 0 | 0 | 0 | 
| [run-app.png](#item-fbe749) | minor update | 画像の変更: run-app.png | modified | 0 | 0 | 0 | 
| [start-app-enable-cors.png](#item-77bbbb) | breaking change | 画像の削除: start-app-enable-cors.png | removed | 0 | 0 | 0 | 
| [suggestions.png](#item-b20dca) | minor update | 画像の変更: suggestions.png | modified | 0 | 0 | 0 | 
| [side-by-side-comparison.png](#item-d2feb6) | new feature | 画像の追加: side-by-side-comparison.png | added | 0 | 0 | 0 | 
| [search-create-app-portal.md](#item-19ab44) | minor update | アプリ作成ポータルのチュートリアル文書の修正 | modified | 20 | 49 | 69 | 
| [search-limits-quotas-capacity.md](#item-3b201a) | minor update | 検索制限およびクオータードキュメントの更新 | modified | 23 | 14 | 37 | 
| [search-security-network-security-perimeter.md](#item-49c0d7) | minor update | ネットワークセキュリティ境界に関するドキュメントの修正 | modified | 6 | 5 | 11 | 
| [toc.yml](#item-c4768f) | new feature | 新しいチュートリアルの追加 | modified | 2 | 0 | 2 | 
| [tutorial-rag-build-solution-index-schema.md](#item-9a17ca) | minor update | インデックススキーマに関するドキュメントの修正 | modified | 2 | 4 | 6 | 
| [tutorial-rag-build-solution-maximize-relevance.md](#item-2fdb09) | minor update | 関連性最大化チュートリアルの修正 | modified | 2 | 3 | 5 | 
| [tutorial-rag-build-solution-minimize-storage.md](#item-088ad8) | new feature | ストレージとコストを最小化するチュートリアルの追加 | added | 338 | 0 | 338 | 
| [tutorial-rag-build-solution-query.md](#item-93965f) | minor update | RAGソリューションの定義文の修正 | modified | 1 | 1 | 2 | 
| [vector-search-ranking.md](#item-0764d8) | minor update | ベクトル検索における信頼性向上のための修正 | modified | 5 | 2 | 7 | 


# Modified Contents
## articles/search/media/search-create-app-portal/configure-results.png{#item-33a179}

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "画像の更新: configure-results.png"
}
```

### Explanation
この変更は、`configure-results.png`という画像ファイルに関するもので、ファイル自体に対する直接的な追加や削除はありませんが、ファイルが修正されたことを示しています。具体的には、GitHubリポジトリ内の画像のリンクにアクセスすることができ、最新の状態が反映されています。このような変更は、ドキュメントやコンテンツの改善や更新を目的としたものであると考えられます。

## articles/search/media/search-create-app-portal/enable-cors.png{#item-6da392}

### Summary

```json
{
    "modification_type": "new feature",
    "modification_title": "新しい画像の追加: enable-cors.png"
}
```

### Explanation
この変更は、`enable-cors.png`という新しい画像ファイルの追加を示しています。この画像は、Azure AI ドキュメント内のアプリポータルの設定に関連しており、CORS（Cross-Origin Resource Sharing）の設定を説明するためのビジュアルコンテンツとして機能する可能性があります。ファイルには具体的な追加や削除はありませんが、新たにリポジトリに加えられたことにより、関連情報への理解を助ける重要な要素となります。ユーザーは、この画像を利用して、設定手順をより効果的に把握することができます。

## articles/search/media/search-create-app-portal/import-data-hotels.png{#item-ecf7e4}

### Summary

```json
{
    "modification_type": "new feature",
    "modification_title": "新しい画像の追加: import-data-hotels.png"
}
```

### Explanation
このコードの変更は、`import-data-hotels.png`という新しい画像ファイルが追加されたことを示しています。この画像は、アプリポータルにおけるホテルのデータインポートに関連するビジュアルサポートを提供するものです。ファイルの追加により、ユーザーはデータのインポート手順を視覚的に理解しやすくなり、操作の流れを把握する助けとなるでしょう。新しい画像は、ドキュメントの内容を補強し、ユーザー体験を向上させる重要な要素です。

## articles/search/media/search-create-app-portal/import-data-realestate.png{#item-e0bcd9}

### Summary

```json
{
    "modification_type": "breaking change",
    "modification_title": "画像の削除: import-data-realestate.png"
}
```

### Explanation
この変更は、`import-data-realestate.png`という画像ファイルがリポジトリから削除されたことを示しています。この画像は、不動産データのインポートに関する情報を提供するために使用されていた可能性がありますが、何らかの理由でその必要がなくなったと考えられます。画像の削除は、関連するコンテンツや手順が更新されたことを示唆しており、ユーザーは関連情報の再確認が求められるかもしれません。これにより、ユーザーが情報を適切に利用するためには注意が必要です。

## articles/search/media/search-create-app-portal/run-app.png{#item-fbe749}

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "画像の変更: run-app.png"
}
```

### Explanation
この変更は、`run-app.png`という画像ファイルが修正されたことを示しています。この画像は、アプリを実行する手順やプロセスに関連しており、内容の更新が行われた可能性があります。具体的な変更内容は示されていませんが、通常、このような最小限の更新は、画像の質を向上させるか、より正確な情報を反映させるために行われます。これにより、ユーザーは視覚的にわかりやすい情報を受け取り、手順をスムーズに実行する助けとなります。

## articles/search/media/search-create-app-portal/start-app-enable-cors.png{#item-77bbbb}

### Summary

```json
{
    "modification_type": "breaking change",
    "modification_title": "画像の削除: start-app-enable-cors.png"
}
```

### Explanation
この変更は、`start-app-enable-cors.png`という画像ファイルがリポジトリから削除されたことを示しています。この画像は、CORS（Cross-Origin Resource Sharing）を有効にするためのアプリの起動プロセスに関する情報を提供していた可能性があります。画像が削除されることは、関連する手順や情報が変更されたことを示しているか、あるいはその情報が不要になったことを反映している可能性があります。この変更により、ユーザーは関連するリソースを再評価し、新しい情報に基づいて行動する必要があるかもしれません。

## articles/search/media/search-create-app-portal/suggestions.png{#item-b20dca}

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "画像の変更: suggestions.png"
}
```

### Explanation
この変更は、`suggestions.png`という画像ファイルが修正されたことを示しています。この画像は、アプリ作成ポータルでの提案に関する視覚的情報を提供していると思われます。具体的な変更内容はわかりませんが、通常、このようなマイナーな更新は、画像の質の向上や、最新の情報を反映させるために行われます。これにより、ユーザーはより適切な提案を受け取ることができ、アプリの作成や検索機能の利用が一層容易になることが期待されます。

## articles/search/media/tutorial-rag-solution/side-by-side-comparison.png{#item-d2feb6}

### Summary

```json
{
    "modification_type": "new feature",
    "modification_title": "画像の追加: side-by-side-comparison.png"
}
```

### Explanation
この変更は、`side-by-side-comparison.png`という新しい画像ファイルがリポジトリに追加されたことを示しています。この画像は、おそらくチュートリアルやアプリの解決策を視覚的に比較するためのものです。新しい画像の追加により、ユーザーは異なる要素やアプローチを横並びで比較しやすくなり、理解を深める手助けとなるでしょう。この変更は、特にチュートリアルの有用性を向上させることを目的としていると考えられます。

## articles/search/search-create-app-portal.md{#item-19ab44}

<details>
<summary>Diff</summary>
````diff
@@ -31,9 +31,9 @@ Before you begin, have the following prerequisites in place:
 
 + A [search index](search-what-is-an-index.md) to use as the basis of your generated application. 
 
-  This quickstart uses the built-in Real Estate sample data and index because it has thumbnail images (the wizard supports adding images to the results page). To create the index used in this exercise, run the **Import data** wizard, choosing the *realestate-us-sample* data source.
+  This quickstart uses the built-in hotels sample dataset. To create the index used in this exercise, run the **Import data** wizard, choosing the *hotels-sample* source and accepting all defaults.
 
-  :::image type="content" source="media/search-create-app-portal/import-data-realestate.png" alt-text="data source page for sample data" border="false":::
+  :::image type="content" source="media/search-create-app-portal/import-data-hotels.png" alt-text="Screenshot of the data source page for sample data.":::
 
 When the index is ready to use, move on to the next step.
 
@@ -43,25 +43,25 @@ When the index is ready to use, move on to the next step.
 
 1. Under **Search Management** > **Indexes**
 
-1. Choose *realestate-us-sample-index* from the list of existing indexes.
+1. Select *hotels-sample-index*.
 
 1. On the index page, at the top, select **Create demo app** to start the wizard.
 
 1. On the first wizard page, select **Enable Cross Origin Resource Sharing (CORS)** to add CORS support to your index definition. This step is optional, but your local web app won't connect to the remote index without it.
 
-:::image type="content" source="media/search-create-app-portal/start-app-enable-cors.png" alt-text="Screenshot of the enable CORS option for the real estate sample index.":::
+   :::image type="content" source="media/search-create-app-portal/enable-cors.png" alt-text="Screenshot of the enable CORS action.":::
 
 ## Configure search results
 
-The wizard provides a basic layout for rendered search results that includes space for a thumbnail image, a title, and description. Backing each of these elements is a field in your index that provides the data. 
+The wizard provides a basic layout for rendered search results that includes space for a thumbnail image, a title, and description. Backing each of these elements is a field in your index that provides the data.
 
-1. In Thumbnail, choose the *thumbnail* field in the *realestate-us-sample* index. This sample happens to include image thumbnails in the form of URL-addressed images stored in a field called *thumbnail*. If your index doesn't have images, leave this field blank.
+1. Skip **Thumbnail** because this index doesn't have images, but if you have an index field that's populated with URLs resolving to publically available images, you should specify that field for the thumbnail area. If your index doesn't have image URLs, leave this field blank.
 
-1. In Title, choose a field that conveys the uniqueness of each document. In this sample, the listing ID is a reasonable selection.
+1. In Title, choose a field that conveys the uniqueness of each document. In this sample, the Hotel Name is a reasonable selection.
 
-1. In Description, choose a field that provides details that might help someone decide whether to drill down to that particular document.
+1. In Description, choose a field that provides details that might help someone decide whether to drill down to that particular document. In this sample, the Description is a good candidate.
 
-   :::image type="content" source="media/search-create-app-portal/configure-results.png" alt-text="configure results for sample data" border="false":::
+   :::image type="content" source="media/search-create-app-portal/configure-results.png" lightbox="media/search-create-app-portal/configure-results.png" alt-text="Screenshot of the search results configuration page." :::
 
 ## Add a sidebar
 
@@ -70,62 +70,33 @@ The search service supports faceted navigation, which is often rendered as a sid
 In Azure AI Search, faceted navigation is a cumulative filtering experience. Within a category, selecting multiple filters expands the results (for example, selecting Seattle and Bellevue within City). Across categories, selecting multiple filters narrows results.
 
 > [!TIP]
-> You can view the full index schema in the portal. Look for the **Index definition (JSON)** link in each index's overview page. Fields that qualify for faceted navigation have "filterable: true" and "facetable: true" attributes.
+> You can view fields attributes on the **Fields** tab of the index in the Azure portal. Fields marked as filterable and facetable can be used in the sidebar
 
-1. In the wizard, select the **Sidebar** tab at the top of the page. You'll see a list of all fields that are attributed as filterable and facetable in the index.
+1. In the wizard, select the **Sidebar** tab at the top of the page. You should see a list of all fields that are attributed as filterable and facetable in the index.
 
-1. Accept the current selection of faceted fields and continue to the next page.
-
-## Add typeahead
-
-Typeahead functionality is available in the form of autocomplete and query suggestions. The wizard supports query suggestions. Based on keystroke inputs provided by the user, the search service returns a list of "completed" query strings that can be selected as the input.
-
-Suggestions are enabled on specific field definitions. The wizard gives you options for configuring how much information is included in a suggestion. 
-
-The following screenshot shows options in the wizard, juxtaposed with a rendered page in the app. You can see how field selections are used, and how "Show Field Name" is used to include or exclude labeling within the suggestion.
-
-:::image type="content" source="media/search-create-app-portal/suggestions.png" alt-text="Query suggestion configuration":::
+1. Remove some of the fields to shorten the sidebar so that you don't have scroll in the finished app.
 
 ## Add suggestions
 
-Suggestions refer to automated query prompts that are attached to the search box. Azure AI Search supports two: *autocompletion* of a partially entered search term, and *suggestions* for a dropdown list of potential matching documents based.
-
-Select fields for which suggested queries are provided. You should choose shorter string fields. Avoid verbose fields such as descriptions.
-
-The wizard supports suggestions, and the fields that can provide suggested results are derived from a [`Suggesters`](index-add-suggesters.md) construct in the index:
+Suggestions refer to automated query prompts that are attached to the search box. The demo app supports *suggestions* that provide a dropdown list of potential matching documents based on partial text inputs.
 
-```JSON
-  "suggesters": [
-    {
-      "name": "sg",
-      "searchMode": "analyzingInfixMatching",
-      "sourceFields": [
-        "number",
-        "street",
-        "city",
-        "region",
-        "postCode",
-        "tags"
-      ]
-    }
-  ]
-```
+In this page, select fields for which suggested queries are provided. You should choose shorter string fields. Avoid verbose fields such as descriptions. 
 
-1. In the wizard, select the **Suggestions** tab at the top of the page. You'll see a list of all fields that are designated in the index schema as suggestion providers.
+The following screenshot shows the suggestions page, juxtaposed with a rendered page in the app. You can see how field selections are used, and how "Show Field Name" is used to include or exclude labeling within the suggestion.
 
-1. Accept the current selection and continue to the next page.
+:::image type="content" source="media/search-create-app-portal/suggestions.png" lightbox="media/search-create-app-portal/suggestions.png" alt-text="Screenshot of the suggestion configuration page.":::
 
-## Create, download and execute
+## Create, download, and execute
 
 1. Select **Create demo app** at the bottom of the page to generate the HTML file.
 
 1. When prompted, select **Download your app** to download the file.
 
-1. Open the file and select the **Search** button. This action executes a query, which can be an empty query (`*`) that returns an arbitrary result set. The page should look similar to the following screenshot. Enter a term and use filters to narrow results. 
+1. Open the file and select the **Search** button. This action executes a query, which can be an empty query (`*`) that returns an arbitrary result set. The page should look similar to the following screenshot. 
 
-The underlying index is composed of fictitious, generated data that has been duplicated across documents, and descriptions sometimes don't match the image. You can expect a more cohesive experience when you create an app based on your own indexes.
+1. Enter a term and use filters to narrow results. If you don't see suggested queries, check browser settings or try a different browser.
 
-:::image type="content" source="media/search-create-app-portal/run-app.png" alt-text="Run the app":::
+:::image type="content" source="media/search-create-app-portal/run-app.png" lightbox="media/search-create-app-portal/run-app.png" alt-text="Screenshot of the search application in a browser window.":::
 
 ## Clean up resources
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "アプリ作成ポータルのチュートリアル文書の修正"
}
```

### Explanation
この変更は、`search-create-app-portal.md`という文書に対する修正を示しています。主な内容としては、アプリ作成のための手順がリファインされ、以前は「Real Estate」サンプルデータが使用されていたのに対して、新たに「Hotels」サンプルデータが適用されています。この更新に伴い、手順の説明や画像の変更も行われています。具体的には、サンプルデータのインデックスの選択や、それに関連するユーザーインターフェースの説明が新しいデータセットに合わせて修正されています。また、ユーザーが検索結果の構成やサジェッション機能を設定する際の手順が明確化されています。この変更は、ユーザーにとっての理解を助け、最新の情報を提供する目的で行われています。

## articles/search/search-limits-quotas-capacity.md{#item-3b201a}

<details>
<summary>Diff</summary>
````diff
@@ -8,7 +8,7 @@ author: HeidiSteen
 ms.author: heidist
 ms.service: azure-ai-search
 ms.topic: conceptual
-ms.date: 10/28/2024
+ms.date: 12/05/2024
 ms.custom:
   - references_regions
   - build-2024
@@ -200,11 +200,11 @@ Static rate request limits for operations related to a service:
 
 ### Semantic Ranker Throttling limits
 
-[Semantic ranker](search-get-started-semantic.md) uses a queuing system to manage concurrent requests. This sytem allows search services get the highest amount of queries per second possible. When the limit of concurrent requests is reached, additional requests are placed in a queue. If the queue is full, further requests are rejected and must be retried.
+[Semantic ranker](search-get-started-semantic.md) uses a queuing system to manage concurrent requests. This system allows search services get the highest number of queries per second possible. When the limit of concurrent requests is reached, additional requests are placed in a queue. If the queue is full, further requests are rejected and must be retried.
 
 Total semantic ranker queries per second varies based on the following factors:
 + The SKU of the search service. Both queue capacity and concurrent request limits vary by SKU.
-+ The number of search units in the search service. The simplest way to increase the maximum amount of concurrent semantic ranker queries is to [add additional search units to your search service](search-capacity-planning.md#how-to-change-capacity).
++ The number of search units in the search service. The simplest way to increase the maximum number of concurrent semantic ranker queries is to [add additional search units to your search service](search-capacity-planning.md#how-to-change-capacity).
 + The total available semantic ranker capacity in the region.
 + The amount of time it takes to serve a query using semantic ranker. This varies based on how busy the search service is.
 
@@ -217,21 +217,30 @@ The following table describes the semantic ranker throttling limits by SKU. Subj
 
 ## API request limits
 
+Limits on payloads and queries exist because unbounded queries can destabilize your search service. Typically, such queries are created programmatically. If your application generates search queries programmatically, we recommend designing it in such a way that it doesn't generate queries of unbounded size. If you must exeed a supported limit, you should [test your workload](search-performance-analysis.md#develop-baseline-numbers) so that you know what to expect.
+
 Except where noted, the following API requests apply to all programmable interfaces, including the Azure SDKs.
 
-+ Maximum of 16 MB per indexing or query request when pushing a payload to the search service <sup>1</sup>
-+ Maximum 8-KB URL length (applies to REST APIs only)
-+ Maximum 1,000 documents per batch of index uploads, merges, or deletes
-+ Maximum 32 fields in $orderby clause
-+ Maximum 100,000 characters in a search clause
-+ The maximum number of clauses in `search` (expressions separated by AND or OR) is 1024
-+ Maximum search term size is 32,766 bytes (32 KB minus 2 bytes) of UTF-8 encoded text
-+ Maximum search term size is 1,000 characters for [prefix search](query-simple-syntax.md#prefix-queries) and [regex search](query-lucene-syntax.md#bkmk_regex)
-+ [Wildcard search](query-lucene-syntax.md#bkmk_wildcard) and [Regular expression search](query-lucene-syntax.md#bkmk_regex) are limited to a maximum of 1,000 states when processed by [Lucene](https://lucene.apache.org/core/7_0_1/core/org/apache/lucene/util/automaton/RegExp.html).
+General:
+
++ Supported maximum payload limit is 16 MB for indexing and query requests via REST API and SDKs.
++ Maximum 8-KB URL length (applies to REST APIs only).
+
+Indexing APIs:
+
++ Supported maximum 1,000 documents per batch of index uploads, merges, or deletes.
+
+Query APIs:
+
++ Maximum 32 fields in $orderby clause.
++ Maximum 100,000 characters in a search clause.
++ Maximum number of clauses in search is 3,000.
++ Maximum limits on [wildcard](query-lucene-syntax.md#bkmk_wildcard) and [regular expression](query-lucene-syntax.md#bkmk_regex) queries, as enforced by [Lucene](https://lucene.apache.org/core/7_0_1/core/org/apache/lucene/util/automaton/RegExp.html). It caps the number of patterns, variations, or matches to 1,000 instances. This limit is in place to avoid engine overload.
 
-<sup>1</sup> In Azure AI Search, the body of a request is subject to an upper limit of 16 MB, imposing a practical limit on the contents of individual fields or collections that aren't otherwise constrained by theoretical limits (see [Supported data types](/rest/api/searchservice/supported-data-types) for more information about field composition and restrictions).
+Search terms:
 
-Limits on query size and composition exist because unbounded queries can destabilize your search service. Typically, such queries are created programmatically. If your application generates search queries programmatically, we recommend designing it in such a way that it doesn't generate queries of unbounded size.
++ Supported maximum search term size is 32,766 bytes (32 KB minus 2 bytes) of UTF-8 encoded text. Applies to keyword search and the text property of vector search.
++ Supported maximum search term size is 1,000 characters for [prefix search](query-simple-syntax.md#prefix-queries) and [regex search](query-lucene-syntax.md#bkmk_regex).
 
 ## API response limits
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "検索制限およびクオータードキュメントの更新"
}
```

### Explanation
この変更は、`search-limits-quotas-capacity.md`ドキュメントに対する更新を示しています。主な改訂内容には、日付の更新と、セマンティックレポート機能やAPIリクエスト制限に関する詳細が追加されています。特に、セマンティックレポート機能のスループットや制限についての説明が強化され、異なるSKUに基づく制限の詳細が明確化されています。また、APIリクエストにおけるペイロード制限や検索クエリの制限に関する段落が整理され、それぞれの制限がよりわかりやすく分類されています。全体として、これらの更新は、ユーザーがサービスの制限を理解し、効果的に利用するための情報を提供することを目的としています。

## articles/search/search-security-network-security-perimeter.md{#item-49c0d7}

<details>
<summary>Diff</summary>
````diff
@@ -9,17 +9,16 @@ ms.service: azure-ai-search
 ms.custom:
   - ignite-2024
 ms.topic: how-to
-ms.date: 10/23/2024
+ms.date: 12/05/2024
 ---
 
 # Add a search service to a network security perimeter
 
 > [!IMPORTANT]
-> Azure AI Search support for network security perimeter is in public preview under supplemental terms of use. It's available in [regions providing the feature](/azure/private-link/network-security-perimeter-concepts).
+> Azure AI Search support for network security perimeter is in public preview under [supplemental terms of use](https://azure.microsoft.com/support/legal/preview-supplemental-terms/). It's available in [regions providing the feature](/azure/private-link/network-security-perimeter-concepts).
 > This preview version is provided without a service level agreement, and it's not recommended for production workloads. Certain features might not be supported or might have constrained capabilities.
-> For more information, see [Supplemental Terms of Use for Microsoft Azure Previews](https://azure.microsoft.com/support/legal/preview-supplemental-terms/).
 >
-> Be sure to review the [limitations and considerations](#limitations-and-considerations) section before you start.
+>  Review the [limitations and considerations](#limitations-and-considerations) section before you start.
 
 This article explains how to join an Azure AI Search service to a [network security perimeter](/azure/private-link/network-security-perimeter-concepts) to control network access to your search service. By joining a network security perimeter, you can:
 
@@ -35,6 +34,8 @@ You can add a search service to a network security perimeter in the Azure portal
 
 * Supported indexer data sources are currently limited to [Azure Blob Storage](search-howto-indexing-azure-blob-storage.md), [Azure Cosmos DB for NoSQL](./search-howto-index-cosmosdb.md), and [Azure SQL Database](search-how-to-index-sql-database.md).
 
+* Currently, within the perimeter, indexer connections to Azure PaaS for data retrieval is the primary use case. For outbound skills-driven API calls to Azure AI services, Azure OpenAI, or the Azure AI Foundry model catalog, or for inbound calls from the Azure AI Foundry for "chat with your data" scenarios you must [configure inbound and outbound rules](#add-an-inbound-access-rule) to allow the requests through the perimeter. If you require private connections for [structure-aware chunking](search-how-to-semantic-chunking.md) and vectorization, you should [create a shared private link](search-indexer-howto-access-private.md) and a private network.
+
 ## Prerequisites
 
 * An existing network security perimeter. You can [create one to associate with your search service](/azure/private-link/create-network-security-perimeter-portal).
@@ -47,7 +48,7 @@ Azure Network Security Perimeter allows administrators to define a logical netwo
 
 You can add Azure AI Search to a network security perimeter so that all indexing and query requests occur within the security boundary.
 
-1. In the Azure portal, create or find the network security perimeter service for your subscription.
+1. In the Azure portal, find the network security perimeter service for your subscription.
 
 1. Select **Resources** from the left-hand menu.
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "ネットワークセキュリティ境界に関するドキュメントの修正"
}
```

### Explanation
この変更は、`search-security-network-security-perimeter.md`に加えられた修正を反映しています。主な改訂内容は、サポートされているネットワークセキュリティの境界についての情報の更新と、エンドユーザーに対する注意喚起の改善です。特に、Azure AI Searchのネットワークセキュリティ境界サポートがパブリックプレビューとして提供されていることを明確にし、利用する際の補足利用規約へのリンクが追加されました。また、インデックス接続の主な使用ケースや、Azure AIサービスへのAPIコールを行う際のルール設定についての詳細が追加され、展開手順が若干整理されています。この文書の更新は、利用者が安全にリソースを管理し、ネットワークセキュリティの利用を最大限に活用できるようにすることを目的としています。

## articles/search/toc.yml{#item-c4768f}

<details>
<summary>Diff</summary>
````diff
@@ -108,6 +108,8 @@ items:
       href: tutorial-rag-build-solution-query.md
     - name: Maximize relevance
       href: tutorial-rag-build-solution-maximize-relevance.md
+    - name: Minimize storage and costs
+      href: tutorial-rag-build-solution-minimize-storage.md
   - name: Skills tutorials
     items:
     - name: C#
````
</details>

### Summary

```json
{
    "modification_type": "new feature",
    "modification_title": "新しいチュートリアルの追加"
}
```

### Explanation
この変更は、`toc.yml`ファイルに新しいチュートリアルを追加するための更新を示しています。具体的には、「Minimize storage and costs」という名前の新しいチュートリアルが追加され、そのリンクが指定されています。このチュートリアルは、ストレージとコストを最小限に抑えるための方法を説明していると推測されます。この更新により、ユーザーは検索サービスに関する学習リソースをさらに拡充できるようになり、特にコスト管理やストレージ最適化に関心のあるユーザーにとって有益です。全体として、これはドキュメントの内容を強化するための重要な追加です。

## articles/search/tutorial-rag-build-solution-index-schema.md{#item-9a17ca}

<details>
<summary>Diff</summary>
````diff
@@ -65,10 +65,8 @@ In Azure AI Search, an index that works best for RAG workloads has these qualiti
 
 - Your schema should either be flat (no complex types or structures), or you should [format the complext type output as JSON](search-get-started-rag.md#send-a-complex-rag-query) before sending it to the LLM. This requirement is specific to the RAG pattern in Azure AI Search.
 
-<!-- Although Azure AI Search can't join indexes, you can create indexes that preserve parent-child relationship, and then use sequential queries in your search logic to pull from both (a query on the chunked data index, a lookup on the parent index). This exercise includes templates for parent-child elements in the same index and in separate indexes, where information from the parent index is retrieved using a lookup query. -->
-
-<!-- > [!NOTE]
-> Schema design affects storage and costs. This exercise is focused on schema fundamentals. In the [Minimize storage and costs](tutorial-rag-build-solution-minimize-storage.md) tutorial, you revisit schema design to consider narrow data types, attribution, and vector configurations that offer more efficient. -->
+> [!NOTE]
+> Schema design affects storage and costs. This exercise is focused on schema fundamentals. In the [Minimize storage and costs](tutorial-rag-build-solution-minimize-storage.md) tutorial, you revisit schemas to learn how narrow data types, compression, and storage options significantly reduce the amount of storage used by vectors.
 
 ## Create an index for RAG workloads
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "インデックススキーマに関するドキュメントの修正"
}
```

### Explanation
この変更は、`tutorial-rag-build-solution-index-schema.md`ファイルにおけるインデックススキーマに関する内容の更新を示しています。主な変更点は、ドキュメント内のノートの内容を改善し、ストレージやコストに対するスキーマ設計の影響についての説明を明確にしたことです。また、古いコメントアウトされたテキストが削除され、新しい説明が追加されています。具体的には、コスト効率を考慮して狭いデータタイプや圧縮技術、ストレージオプションの重要性が強調されています。この修正により、ユーザーは効果的なインデックス設計のアプローチをよりよく理解できるようになり、ストレージ管理の重要性が強調されています。全体として、これはユーザーがRAGワークロードのインデックススキーマを設計する際の実用的なガイドラインを提供するための重要な更新です。

## articles/search/tutorial-rag-build-solution-maximize-relevance.md{#item-2fdb09}

<details>
<summary>Diff</summary>
````diff
@@ -327,8 +327,7 @@ Semantic ranking and scoring profiles operate on nonvector content, but you can
 - analyzers and normalizers
 - advanced query formats (regular expressions, fuzzy search) -->
 
-<!-- ## Next step
+## Next step
 
 > [!div class="nextstepaction"]
-> [Reduce vector storage and costs](tutorial-rag-build-solution-minimize-storage.md)
- -->
+> [Minimize vector storage and costs](tutorial-rag-build-solution-minimize-storage.md)
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "関連性最大化チュートリアルの修正"
}
```

### Explanation
この変更は、`tutorial-rag-build-solution-maximize-relevance.md`ファイルにおける関連性最大化のチュートリアルに関するわずかな更新を示しています。主な修正点は、次のステップとして示されているリファレンスが微調整されたことです。「Reduce vector storage and costs」というリンクのタイトルが「Minimize vector storage and costs」に変更されており、文書の表現が一貫性を持たせるために修正されています。これにより、ユーザーはコスト管理に関連する次のアクションをより明確に理解できるようになります。また、余分なコメントアウトされたテキストが削除され、ドキュメントがすっきりとした印象になっています。この更新は、ユーザーが関連性を最大化するための手法を学ぶ上での流れを改善するためのものです。

## articles/search/tutorial-rag-build-solution-minimize-storage.md{#item-088ad8}

<details>
<summary>Diff</summary>
````diff
@@ -0,0 +1,338 @@
+---
+title: 'RAG tutorial: Minimize storage and costs'
+titleSuffix: Azure AI Search
+description: Compress vectors using narrow data types and scalar quantization. Remove extra copies of stored vectors to further save on space.
+
+manager: nitinme
+author: HeidiSteen
+ms.author: heidist
+ms.service: azure-ai-search
+ms.topic: tutorial
+ms.date: 12/05/2024
+
+---
+
+# Tutorial: Minimize storage and costs (RAG in Azure AI Search)
+
+Azure AI Search offers several approaches for reducing the size of vector indexes. These approaches range from vector compression, to being more selective over what you store on your search service.
+
+In this tutorial, you modify the existing search index to use:
+
+> [!div class="checklist"]
+> - Narrow data types
+> - Scalar quantization
+> - Reduced storage by opting out of vectors in search results
+
+This tutorial reprises the search index created by the [indexing pipeline](tutorial-rag-build-solution-pipeline.md). All of these updates affect the existing content, requiring you to rerun the indexer. However, instead of deleting the search index, you create a second one so that you can compare reductions in vector index size after adding the new capabilities.
+
+Altogether, the techniques illustrated in this tutorial can reduce vector storage by about half.
+
+The following screenshot compares the [first index](tutorial-rag-build-solution-pipeline.md) from a previous tutorial to the index built in this one.
+
+:::image type="content" source="media/tutorial-rag-solution/side-by-side-comparison.png" lightbox="media/tutorial-rag-solution/side-by-side-comparison.png" alt-text="Screenshot of the original vector index with the index created using the schema in this tutorial.":::
+
+## Prerequisites
+
+This tutorial is essentially a rerun of the [indexing pipeline](tutorial-rag-build-solution-pipeline.md). You need all of the Azure resources and permissions described in that tutorial.
+
+For comparison, you should have an existing *py-rag-tutorial-idx* index on your Azure AI Search service. It should be almost 2 MB in size, and the vector index portion should be 348 KB.
+
+You should also have the following objects:
+
+- py-rag-tutorial-ds (data source)
+
+- py-rag-tutorial-ss (skillset)
+
+## Download the sample
+
+[Download a Jupyter notebook](https://github.com/Azure-Samples/azure-search-python-samples/blob/main/Tutorial-RAG/Tutorial-rag.ipynb) from GitHub to send the requests to Azure AI Search. For more information, see [Downloading files from GitHub](https://docs.github.com/get-started/start-your-journey/downloading-files-from-github).
+
+## Update the index for reduced storage
+
+Azure AI Search has multiple approaches for reducing vector size, which lowers the cost of vector workloads. In this step, create a new index that uses the following capabilities:
+
+- Smaller vector indexes by compressing the vectors used during query execution. Scalar quantization provides this capability.
+
+- Smaller vector indexes by opting out of vector storage for search results. If you only need vectors for queries and not in response payload, you can drop the vector copy used for search results.
+
+- Smaller vector fields through narrow data types. You can specify `Collection(Edm.Half)` on the text_vector field to store incoming float32 dimensions as float16.
+
+All of these capabilities are specified in a search index. After you load the index, compare the difference between the original index and the new one.
+
+1. Name the new index `py-rag-tutorial-small-vectors-idx`.
+
+1. Use the following definition for the new index. The difference between this schema and the previous schema updates in [Maximize relevance](tutorial-rag-build-solution-maximize-relevance.md) are new classes for scalar quantization and a new compressions section, a new data type (`Collection(Edm.Half)`) for the text_vector field, and a new property `stored` set to false.
+
+    ```python
+    from azure.identity import DefaultAzureCredential
+    from azure.identity import get_bearer_token_provider
+    from azure.search.documents.indexes import SearchIndexClient
+    from azure.search.documents.indexes.models import (
+        SearchField,
+        SearchFieldDataType,
+        VectorSearch,
+        HnswAlgorithmConfiguration,
+        VectorSearchProfile,
+        AzureOpenAIVectorizer,
+        AzureOpenAIVectorizerParameters,
+        ScalarQuantizationCompression,
+        ScalarQuantizationParameters,
+        SearchIndex,
+        SemanticConfiguration,
+        SemanticPrioritizedFields,
+        SemanticField,
+        SemanticSearch,
+        ScoringProfile,
+        TagScoringFunction,
+        TagScoringParameters
+    )
+    
+    credential = DefaultAzureCredential()
+    
+    index_name = "py-rag-tutorial-small-vectors-idx"
+    index_client = SearchIndexClient(endpoint=AZURE_SEARCH_SERVICE, credential=credential)  
+    fields = [
+        SearchField(name="parent_id", type=SearchFieldDataType.String),  
+        SearchField(name="title", type=SearchFieldDataType.String),
+        SearchField(name="locations", type=SearchFieldDataType.Collection(SearchFieldDataType.String), filterable=True),
+        SearchField(name="chunk_id", type=SearchFieldDataType.String, key=True, sortable=True, filterable=True, facetable=True, analyzer_name="keyword"),  
+        SearchField(name="chunk", type=SearchFieldDataType.String, sortable=False, filterable=False, facetable=False),  
+        SearchField(name="text_vector", type="Collection(Edm.Half)", vector_search_dimensions=1024, vector_search_profile_name="myHnswProfile", stored= False)
+        ]  
+    
+    # Configure the vector search configuration  
+    vector_search = VectorSearch(  
+        algorithms=[  
+            HnswAlgorithmConfiguration(name="myHnsw"),
+        ],  
+        profiles=[  
+            VectorSearchProfile(  
+                name="myHnswProfile",  
+                algorithm_configuration_name="myHnsw",
+                compression_name="myScalarQuantization",
+                vectorizer_name="myOpenAI",  
+            )
+        ],  
+        vectorizers=[  
+            AzureOpenAIVectorizer(  
+                vectorizer_name="myOpenAI",  
+                kind="azureOpenAI",  
+                parameters=AzureOpenAIVectorizerParameters(  
+                    resource_url=AZURE_OPENAI_ACCOUNT,  
+                    deployment_name="text-embedding-3-large",
+                    model_name="text-embedding-3-large"
+                ),
+            ),  
+        ],
+        compressions=[
+            ScalarQuantizationCompression(
+                compression_name="myScalarQuantization",
+                rerank_with_original_vectors=True,
+                default_oversampling=10,
+                parameters=ScalarQuantizationParameters(quantized_data_type="int8"),
+            )
+        ]
+    )
+    
+    semantic_config = SemanticConfiguration(
+        name="my-semantic-config",
+        prioritized_fields=SemanticPrioritizedFields(
+            title_field=SemanticField(field_name="title"),
+            keywords_fields=[SemanticField(field_name="locations")],
+            content_fields=[SemanticField(field_name="chunk")]
+        )
+    )
+    
+    semantic_search = SemanticSearch(configurations=[semantic_config])
+    
+    scoring_profiles = [  
+        ScoringProfile(  
+            name="my-scoring-profile",
+            functions=[
+                TagScoringFunction(  
+                    field_name="locations",  
+                    boost=5.0,  
+                    parameters=TagScoringParameters(  
+                        tags_parameter="tags",  
+                    ),  
+                ) 
+            ]
+        )
+    ]
+    
+    index = SearchIndex(name=index_name, fields=fields, vector_search=vector_search, semantic_search=semantic_search, scoring_profiles=scoring_profiles)  
+    result = index_client.create_or_update_index(index)  
+    print(f"{result.name} created")
+    ```
+
+## Create or reuse the data source
+
+Here's the definition of the data source from the previous tutorial. If you already have this data source on your search service, you can skip creating a new one.
+
+```python
+from azure.search.documents.indexes import SearchIndexerClient
+from azure.search.documents.indexes.models import (
+    SearchIndexerDataContainer,
+    SearchIndexerDataSourceConnection
+)
+
+# Create a data source 
+indexer_client = SearchIndexerClient(endpoint=AZURE_SEARCH_SERVICE, credential=credential)
+container = SearchIndexerDataContainer(name="nasa-ebooks-pdfs-all")
+data_source_connection = SearchIndexerDataSourceConnection(
+    name="py-rag-tutorial-ds",
+    type="azureblob",
+    connection_string=AZURE_STORAGE_CONNECTION,
+    container=container
+)
+data_source = indexer_client.create_or_update_data_source_connection(data_source_connection)
+
+print(f"Data source '{data_source.name}' created or updated")
+```
+
+## Create or reuse the skillset
+
+The skillset is also unchanged from the previous tutorial. Here it is again so that you can review it.
+
+```python
+from azure.search.documents.indexes.models import (
+    SplitSkill,
+    InputFieldMappingEntry,
+    OutputFieldMappingEntry,
+    AzureOpenAIEmbeddingSkill,
+    EntityRecognitionSkill,
+    SearchIndexerIndexProjection,
+    SearchIndexerIndexProjectionSelector,
+    SearchIndexerIndexProjectionsParameters,
+    IndexProjectionMode,
+    SearchIndexerSkillset,
+    CognitiveServicesAccountKey
+)
+
+# Create a skillset  
+skillset_name = "py-rag-tutorial-ss"
+
+split_skill = SplitSkill(  
+    description="Split skill to chunk documents",  
+    text_split_mode="pages",  
+    context="/document",  
+    maximum_page_length=2000,  
+    page_overlap_length=500,  
+    inputs=[  
+        InputFieldMappingEntry(name="text", source="/document/content"),  
+    ],  
+    outputs=[  
+        OutputFieldMappingEntry(name="textItems", target_name="pages")  
+    ],  
+)  
+  
+embedding_skill = AzureOpenAIEmbeddingSkill(  
+    description="Skill to generate embeddings via Azure OpenAI",  
+    context="/document/pages/*",  
+    resource_url=AZURE_OPENAI_ACCOUNT,  
+    deployment_name="text-embedding-3-large",  
+    model_name="text-embedding-3-large",
+    dimensions=1536,
+    inputs=[  
+        InputFieldMappingEntry(name="text", source="/document/pages/*"),  
+    ],  
+    outputs=[  
+        OutputFieldMappingEntry(name="embedding", target_name="text_vector")  
+    ],  
+)
+
+entity_skill = EntityRecognitionSkill(
+    description="Skill to recognize entities in text",
+    context="/document/pages/*",
+    categories=["Location"],
+    default_language_code="en",
+    inputs=[
+        InputFieldMappingEntry(name="text", source="/document/pages/*")
+    ],
+    outputs=[
+        OutputFieldMappingEntry(name="locations", target_name="locations")
+    ]
+)
+  
+index_projections = SearchIndexerIndexProjection(  
+    selectors=[  
+        SearchIndexerIndexProjectionSelector(  
+            target_index_name=index_name,  
+            parent_key_field_name="parent_id",  
+            source_context="/document/pages/*",  
+            mappings=[  
+                InputFieldMappingEntry(name="chunk", source="/document/pages/*"),  
+                InputFieldMappingEntry(name="text_vector", source="/document/pages/*/text_vector"),
+                InputFieldMappingEntry(name="locations", source="/document/pages/*/locations"),  
+                InputFieldMappingEntry(name="title", source="/document/metadata_storage_name"),  
+            ],  
+        ),  
+    ],  
+    parameters=SearchIndexerIndexProjectionsParameters(  
+        projection_mode=IndexProjectionMode.SKIP_INDEXING_PARENT_DOCUMENTS  
+    ),  
+) 
+
+cognitive_services_account = CognitiveServicesAccountKey(key=AZURE_AI_MULTISERVICE_KEY)
+
+skills = [split_skill, embedding_skill, entity_skill]
+
+skillset = SearchIndexerSkillset(  
+    name=skillset_name,  
+    description="Skillset to chunk documents and generating embeddings",  
+    skills=skills,  
+    index_projection=index_projections,
+    cognitive_services_account=cognitive_services_account
+)
+  
+client = SearchIndexerClient(endpoint=AZURE_SEARCH_SERVICE, credential=credential)  
+client.create_or_update_skillset(skillset)  
+print(f"{skillset.name} created")
+```
+
+## Create a new indexer and load the index
+
+Although you could reset and rerun the existing indexer using the new index, it's just as easy to create a new indexer. Having two indexes and indexers preserves the execution history and allows for closer comparisons.
+
+This indexer is identical to the previous indexer, except that it specifies the new index from this tutorial.
+
+```python
+from azure.search.documents.indexes.models import (
+    SearchIndexer
+)
+
+# Create an indexer  
+indexer_name = "py-rag-tutorial-small-vectors-idxr" 
+
+indexer_parameters = None
+
+indexer = SearchIndexer(  
+    name=indexer_name,  
+    description="Indexer to index documents and generate embeddings",
+    target_index_name="py-rag-tutorial-small-vectors-idx",
+    skillset_name="py-rag-tutorial-ss", 
+    data_source_name="py-rag-tutorial-ds",
+    parameters=indexer_parameters
+)  
+
+# Create and run the indexer  
+indexer_client = SearchIndexerClient(endpoint=AZURE_SEARCH_SERVICE, credential=credential)  
+indexer_result = indexer_client.create_or_update_indexer(indexer)  
+
+print(f' {indexer_name} is created and running. Give the indexer a few minutes before running a query.')
+```
+
+As a final step, switch to the Azure portal to compare the vector storage requirements for the two indexes. You should results similar to the following screenshot.
+
+:::image type="content" source="media/tutorial-rag-solution/side-by-side-comparison.png" lightbox="media/tutorial-rag-solution/side-by-side-comparison.png" alt-text="Screenshot of the original vector index with the index created using the schema in this tutorial.":::
+
+The index created in this tutorial uses half-precision floating-point numbers (float16) for the text vectors. This reduces the storage requirements for the vectors by half compared to the previous index that used single-precision floating-point numbers (float32). Scalar compression and the omission of one set of the vectors account for the remaining storage savings. For more information about reducing vector size, see [Choose an approach for optimizing vector storage and processing](vector-search-how-to-configure-compression-storage.md).
+
+Consider revisiting the [queries from the previous tutorial](tutorial-rag-build-solution-query.md) so that you can compare query speed and utility. You should expect some variation in LLM output whenever you repeat a query, but in general the storage-saving techniques you implemented shouldn't degrade the quality of your search results.
+
+## Next step
+
+There are code samples in all of the Azure SDKs that provide Azure AI Search programmability. You can also review vector sample code for specific use cases and technology combinations.
+
+> [!div class="nextstepaction"]
+> [azure-search-vector-samples](https://github.com/Azure/azure-search-vector-samples)
\ No newline at end of file
````
</details>

### Summary

```json
{
    "modification_type": "new feature",
    "modification_title": "ストレージとコストを最小化するチュートリアルの追加"
}
```

### Explanation
この変更は、`tutorial-rag-build-solution-minimize-storage.md`という新しいチュートリアルドキュメントの追加を示しています。このチュートリアルは、Azure AI Searchにおけるベクトルインデックスのストレージを最小限に抑えるためのアプローチを紹介します。具体的には、狭いデータタイプとスカラー量子化を使用したベクトルの圧縮方法が説明されています。

このドキュメントでは、ユーザーが既存の検索インデックスを変更し、新しいインデックスを作成する手順が詳しく説明されています。得られた技術を使用することで、ベクトルのストレージを約半分に削減できることが強調されています。また、既存のインデックスとの比較を行うための手順と、Azureポータルでの結果の確認方法も説明されており、視覚的な比較が容易に行えるようになっています。

さらに、適切な前提条件、サンプルデータのダウンロード方法、スキルセットの作成、インデクサーの作成と実行に関する詳細なコードサンプルも含まれており、ユーザーが実際に手を動かして学ぶことができる内容になっています。この新しいチュートリアルは、効率的なストレージ管理を目指すユーザーにとって、価値のあるリソースとなるでしょう。

## articles/search/tutorial-rag-build-solution-query.md{#item-93965f}

<details>
<summary>Diff</summary>
````diff
@@ -15,7 +15,7 @@ ms.date: 10/04/2024
 
 # Tutorial: Search your data using a chat model (RAG in Azure AI Search)
 
-The defining characteristic of a RAG solution on Azure AI Search is sending queries to a Large Language Model (LLM) and providing a conversational search experience over your indexed content. It can be surprisingly easy if you implement just the basics.
+The defining characteristic of a RAG solution on Azure AI Search is sending queries to a Large Language Model (LLM) for a conversational search experience over your indexed content. It can be surprisingly easy if you implement just the basics.
 
 In this tutorial, you:
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "RAGソリューションの定義文の修正"
}
```

### Explanation
この変更は、`tutorial-rag-build-solution-query.md`ファイル内のテキストのわずかな修正を示しています。具体的には、RAG（Retrieval-Augmented Generation）ソリューションに関する説明文の文言が変更されました。修正前は「Large Language Model (LLM)に対してクエリを送信すること」と記載されていましたが、修正後には「Large Language Model (LLM)に対してクエリを送信することで、インデックスされたコンテンツに対する会話型検索体験を提供すること」となり、具体的には「会話型検索体験を提供すること」が強調されています。

この変更によって、RAGソリューションがどのような体験を提供するのかがより明確になり、ユーザーがチュートリアルの目的を理解しやすくなっています。内容自体は大きな変更ではありませんが、重要な情報が伝わるように改善されているといえます。このような微修正は、文書全体のクリアさや正確さに寄与します。

## articles/search/vector-search-ranking.md{#item-0764d8}

<details>
<summary>Diff</summary>
````diff
@@ -9,12 +9,12 @@ ms.service: azure-ai-search
 ms.custom:
   - ignite-2023
 ms.topic: concept-article
-ms.date: 09/19/2024
+ms.date: 12/05/2024
 ---
 
 # Relevance in vector search
 
-During vector query execution, the search engine looks for similar vectors to find the best candidates to return in search results. Depending on how you indexed the vector content, the search for relevant matches is either exhaustive, or constrained to near neighbors for faster processing. Once candidates are found, similarity metrics are used to score each result based on the strength of the match. 
+During vector query execution, the search engine looks for similar vectors to find the best candidates to return in search results. Depending on how you indexed the vector content, the search for relevant matches is either exhaustive, or constrained to nearest neighbors for faster processing. Once candidates are found, similarity metrics are used to score each result based on the strength of the match. 
 
 This article explains the algorithms used to find relevant matches and the similarity metrics used for scoring. It also offers tips for improving relevance if search results don't meet expectations.
 
@@ -90,6 +90,9 @@ The algorithm finds candidate vectors to evaluate similarity. To perform this ta
 | `dotProduct` | This metric measures both the length of each pair of two vectors, and the angle between them. Mathematically, it calculates the products of vectors' magnitudes and the angle between them. For normalized vectors, this is identical to `cosine` similarity, but slightly more performant. |
 | `euclidean` | (also known as `l2 norm`) This metric measures the length of the vector difference between two vectors. Mathematically, it calculates the Euclidean distance between two vectors, which is the l2-norm of the difference of the two vectors. |
 
+> [!NOTE]
+> If you run two or more vector queries in parallel, or if you do a hybrid search that combines vector and text queries in the same request, [Reciprocal Rank Fusion (RRF)](hybrid-search-ranking.md) is used for scoring the final search results.
+
 ## Scores in a vector search results
 
 Scores are calculated and assigned to each match, with the highest matches returned as `k` results. The **`@search.score`** property contains the score. The following table shows the range within which a score will fall.
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "ベクトル検索における信頼性向上のための修正"
}
```

### Explanation
この変更は、`vector-search-ranking.md`ファイルに対するいくつかの修正を示しています。主な変更点は以下の通りです：

1. **日付の更新**: ドキュメントの日付が「09/19/2024」から「12/05/2024」に変更されました。この変更は、記事の最新性を反映しています。

2. **用語の修正**: 文中の「近隣」を「nearest neighbors」に修正しました。これにより、用語の正確性が向上し、読者にとって理解しやすくなっています。

3. **新しいノートの追加**: 「複数のベクトルクエリを並行して実行する場合や、ベクトルとテキストクエリを同じリクエストで組み合わせる場合、[Reciprocal Rank Fusion (RRF)](hybrid-search-ranking.md)が最終的な検索結果のスコアリングに使用される。」という内容の注記が追加されました。これにより、ユーザーは複雑な検索条件でのスコア計算方法についての理解が深まるでしょう。

このような小規模な更新は、文書の質を向上させ、読者にとっての有用性を高めることに寄与しています。全体的に見て、これらの変更はベクトル検索の信頼性や正確さを強調し、ユーザーにとって価値のある情報を提供するためのものです。


