---
date: '2025-03-13'
permalink: https://github.com/MicrosoftDocs/azure-ai-docs/compare/MicrosoftDocs:3791c10...MicrosoftDocs:32f7d9a
summary: このドキュメント更新では、日付の修正を中心に多くの記事で軽微な変更や表現の改善が行われました。特に「vector-search-how-to-chunk-documents.md」では、19行の追加と20行の削除を含む大規模なリファクタリングが実施され、新しい情報が整理され、内容がわかりやすくなっています。また、多くの記事で日付が更新され、情報の信頼性が高まりました。言語的な修正も行われ、より理解しやすい表現が用いられています。全体として、利用者に対する情報提供の効率化を目的とした改善がなされています。
title: Diff Insight Report - search

---

[View Diff on GitHub](https://github.com/MicrosoftDocs/azure-ai-docs/compare/MicrosoftDocs:3791c10...MicrosoftDocs:32f7d9a){target="_blank"}

<format>
# Highlights
このドキュメント更新では、日付の修正を中心に多くの記事で軽微な変更や表現の改善が行われました。また、ベクター検索に関するドキュメントでは大規模なリファクタリングが実施され、コンテンツの整備と最新化が図られています。

## New features
- ベクター検索のチャンク化方法に関する記事での大幅なリファクタリングにより、新しい情報が効率的に整理され、さらなる理解が促進されています。

## Breaking changes
- 「vector-search-how-to-chunk-documents.md」では、19行の追加と20行の削除という大規模な変更があり、内容が再構成されました。これにより、既存の内容が大きく変わる可能性があります。

## Other updates
- 多くの記事で日付の更新が行われました。これにより、情報は最新で、読者は新しいコンテンツを信頼して利用できます。
- 一部の文章表現がより簡潔で明確になるよう修正されており、情報がより直接的に伝わるようになっています。

# Insights
この更新は、Azure AI Searchに関するドキュメントの最新化と明確な情報提供を目的としたもので、多くの部分で軽微な修正が行われています。軽微な修正では、ドキュメント全体にわたって日付の更新が行われています。これにより、情報のリアリティが増し、読者に今後の方向性や技術の信頼性を示すことができます。

特に注目すべきは「vector-search-how-to-chunk-documents.md」における大規模な変更です。この変更では、情報を効果的に整理し、データチャンク方法についての理解を深めるための方法が詳しく説明されています。さらに、この方法では、冗長な情報を削除し、直感的かつわかりやすい内容にするための取り組みが見られます。

また、言語的な修正にも焦点が置かれています。フォーマルすぎる表現から、口語的で理解しやすい表現への変更が行われ、より多くの読者に配慮したものとなっています。これにより、技術情報がより多くの観点からアクセス可能になり、読者の理解度が高まります。

全体として、この一連の更新は、利用者に対する情報の効率的な提供を実現し、ドキュメントの役割を最大限に発揮させることを意図しています。これにより、ユーザーはより快適に、この技術ドキュメントを利用することができるでしょう。
</format>

# Summary Table
|  Filename  | Type |    Title    | Status | A  | D  | M  |
|------------|------|-------------|--------|----|----|----|
| [cognitive-search-predefined-skills.md](#item-81d522) | minor update | 検索用のスキルの更新: 日付と表現の修正 | modified | 2 | 2 | 4 | 
| [hybrid-search-how-to-query.md](#item-345ce6) | minor update | ハイブリッド検索クエリの更新: 日付と構成の変更 | modified | 2 | 8 | 10 | 
| [hybrid-search-ranking.md](#item-dad887) | minor update | ハイブリッド検索ランキングの更新: 日付と表現の修正 | modified | 2 | 2 | 4 | 
| [search-capacity-planning.md](#item-0dd6c9) | minor update | 検索サービスの容量計画に関する更新: 日付の修正 | modified | 1 | 1 | 2 | 
| [search-filters.md](#item-3f2a7a) | minor update | 検索フィルターに関する更新: 日付の修正 | modified | 1 | 1 | 2 | 
| [search-how-to-index-csv-blobs.md](#item-2c3f3e) | minor update | CSVブロブをインデックスする方法に関する更新: 日付の修正 | modified | 1 | 1 | 2 | 
| [search-howto-schedule-indexers.md](#item-d57e7b) | minor update | インデクサをスケジュールする方法に関する更新: 日付の修正 | modified | 1 | 1 | 2 | 
| [search-indexer-tutorial.md](#item-a3e3ff) | minor update | インデクサチュートリアルに関する更新: 日付の修正 | modified | 1 | 1 | 2 | 
| [search-what-is-data-import.md](#item-d73ef5) | minor update | データインポートに関する更新: 日付とテキストの修正 | modified | 2 | 2 | 4 | 
| [tutorial-rag-build-solution-maximize-relevance.md](#item-2fdb09) | minor update | MAXIMIZE RELEVANCE チュートリアルの更新: 日付の修正 | modified | 1 | 1 | 2 | 
| [tutorial-rag-build-solution.md](#item-c7eca4) | minor update | RAGビルドソリューションチュートリアルの更新: 日付と内容の修正 | modified | 1 | 3 | 4 | 
| [vector-search-how-to-chunk-documents.md](#item-b79133) | breaking change | ベクター検索のドキュメントチャンク化方法の大幅な更新 | modified | 19 | 20 | 39 | 
| [vector-search-how-to-generate-embeddings.md](#item-e98f7b) | minor update | 埋め込み生成チュートリアルの軽微な修正 | modified | 4 | 4 | 8 | 
| [vector-search-how-to-query.md](#item-9bb93c) | minor update | ベクトル検索クエリの文法の修正 | modified | 2 | 2 | 4 | 
| [vector-store.md](#item-db9b8c) | minor update | ベクトルストレージに関する軽微な修正 | modified | 4 | 4 | 8 | 


# Modified Contents
## articles/search/cognitive-search-predefined-skills.md{#item-81d522}

<details>
<summary>Diff</summary>
````diff
@@ -10,14 +10,14 @@ ms.custom:
   - build-2024
   - ignite-2024
 ms.topic: concept-article
-ms.date: 09/19/2024
+ms.date: 03/11/2025
 ---
 
 # Skills for extra processing during indexing (Azure AI Search)
 
 This article describes the skills in Azure AI Search that you can include in a [skillset](cognitive-search-working-with-skillsets.md) to access external processing. 
 
-A *skill* provides an atomic operation that transforms content in some way. Often, it's an operation that recognizes or extracts text, but it can also be a utility skill that reshapes the enrichments that are already created. Typically, the output is text-based so that it can be used in [full text search](search-lucene-query-architecture.md) or vectors used in [vector search](vector-search-overview.md).
+A *skill* is an atomic operation that transforms content in some way. Often, it's an operation that recognizes or extracts text, but it can also be a utility skill that reshapes the enrichments that are already created. Typically, the output is either text-based so that it can be used in [full text search](search-lucene-query-architecture.md), or vectors used in [vector search](vector-search-overview.md).
 
 Skills are organized into categories:
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "検索用のスキルの更新: 日付と表現の修正"
}
```

### Explanation
このコードの変更は、Azure AI Searchに関する記事「cognitive-search-predefined-skills.md」の軽微な更新を示しています。具体的には、2つの行が削除され、2つの行が新たに追加され、全体で4つの変更が行われました。

主な変更点は、ドキュメントの日付が「09/19/2024」から「03/11/2025」に変更されたことです。また、スキルの説明において「スキルは、何らかの形でコンテンツを変換する原子的な操作です。」という文の構造もわずかに改良され、「出力はテキストベースまたはベクトルである」と明確にし、両方の出力形式が解説されています。

これらの修正は、ドキュメントの正確性を高め、読者に対してより明確な情報を提供することを目的としています。

## articles/search/hybrid-search-how-to-query.md{#item-345ce6}

<details>
<summary>Diff</summary>
````diff
@@ -9,7 +9,7 @@ ms.service: azure-ai-search
 ms.custom:
   - ignite-2023
 ms.topic: how-to
-ms.date: 10/01/2024
+ms.date: 03/11/2025
 ---
 
 # Create a hybrid query in Azure AI Search
@@ -19,19 +19,13 @@ ms.date: 10/01/2024
 In this article, learn how to:
 
 + Set up a basic request
-+ Formulate hybrid queries with more parameters and filters
++ Add parameters and filters
 + Improve relevance using semantic ranking or vector weights
 + Optimize query behaviors by controlling text and vector inputs
 
 > [!NOTE]
 > New in [**2024-09-01-preview**](/rest/api/searchservice/documents/search-post?view=rest-searchservice-2024-09-01-preview&preserve-view=true) is the ability to target filters to just the vector subqueries in a hybrid request. This gives you more precision over how filters are applied. For more information, see [targeting filters to vector subqueries](#hybrid-search-with-filters-targeting-vector-subqueries-preview) in this article.
 
-<!-- To improve relevance in a hybrid query, use these parameters:
-
-+ [vector.queries.weight](vector-search-how-to-query.md#vector-weighting) lets you set the relative weight of the vector query. This feature is particularly useful in complex queries where two or more distinct result sets need to be combined, as is the case for hybrid search. This feature is generally available.
-
-+ [hybridsearch.maxTextRecallSize and countAndFacetMode (preview)](#set-maxtextrecallsize-and-countandfacetmode) give you more control over text inputs into a hybrid query. This feature requires a preview API version.
- -->
 ## Prerequisites
 
 + A search index containing `searchable` vector and nonvector fields. We recommend the [Import and vectorize data wizard](search-import-data-portal.md) to create an index quickly. Otherwise, see [Create an index](search-how-to-create-search-index.md) and [Add vector fields to a search index](vector-search-how-to-create-index.md).
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "ハイブリッド検索クエリの更新: 日付と構成の変更"
}
```

### Explanation
このコードの変更は、Azure AI Searchに関する「hybrid-search-how-to-query.md」記事の軽微な更新を示しています。主に、8行が削除され、2行が新たに追加され、合計で10の変更が行われました。

具体的な変更点としては、最初に記事の日付が「10/01/2024」から「03/11/2025」に更新されています。また、ハイブリッド検索クエリに関するアクション項目が整理され、「より多くのパラメータとフィルターを用いたハイブリッドクエリの形成」という表現から「パラメータとフィルターの追加」というより簡潔で明確な表現に変更されています。

さらに、コメントとして記載されていた複数の機能に関する説明が削除され、代わりに必須条件として「`searchable` ベクトルおよび非ベクトルフィールドを含む検索インデックスを持つこと」が新たに追加されています。これにより、読者に対してより明確で簡潔な情報を提供することが意図されています。

## articles/search/hybrid-search-ranking.md{#item-dad887}

<details>
<summary>Diff</summary>
````diff
@@ -9,12 +9,12 @@ ms.service: azure-ai-search
 ms.custom:
   - ignite-2023
 ms.topic: conceptual
-ms.date: 10/01/2024
+ms.date: 03/11/2025
 ---
 
 # Relevance scoring in hybrid search using Reciprocal Rank Fusion (RRF)
 
-Reciprocal Rank Fusion (RRF) is an algorithm that evaluates the search scores from multiple, previously ranked results to produce a unified result set. In Azure AI Search, RRF is used whenever there are two or more queries that execute in parallel. Each query produces a ranked result set, and RRF is used to merge and homogenize the rankings into a single result set, returned in the query response. Examples of scenarios where RRF is always used include [*hybrid search*](hybrid-search-overview.md) and multiple vector queries executing concurrently. 
+Reciprocal Rank Fusion (RRF) is an algorithm that evaluates the search scores from multiple, previously ranked results to produce a unified result set. In Azure AI Search, RRF is used whenever there are two or more queries that execute in parallel. Each query produces a ranked result set, and RRF merges and homogenizes the rankings into a single result set for the query response. Examples of scenarios where RRF is always used include [*hybrid search*](hybrid-search-overview.md) and multiple vector queries executing concurrently. 
 
 RRF is based on the concept of *reciprocal rank*, which is the inverse of the rank of the first relevant document in a list of search results. The goal of the technique is to take into account the position of the items in the original rankings, and give higher importance to items that are ranked higher in multiple lists. This can help improve the overall quality and reliability of the final ranking, making it more useful for the task of fusing multiple ordered search results.
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "ハイブリッド検索ランキングの更新: 日付と表現の修正"
}
```

### Explanation
このコードの変更は、Azure AI Searchに関する記事「hybrid-search-ranking.md」の軽微な更新を示しています。主に、2行が削除され、2行が新たに追加され、全体で4つの変更が行われました。

具体的な変更点としては、最初に記事の日付が「10/01/2024」から「03/11/2025」に更新されています。また、Reciprocal Rank Fusion (RRF)に関する説明文がわずかに修正されました。元の文では「RRFは…統一された結果セットを生成するために複数の以前にランキングされた結果の検索スコアを評価するアルゴリズムである。」と述べられていましたが、修正後は「RRFは…検索応答のために単一の結果セットへのランキングのマージと均質化を行います。」と、文章がよりスムーズに結合されています。 

これらの変更は、ドキュメントの正確性を高め、情報の明確さを向上させることを目的としています。

## articles/search/search-capacity-planning.md{#item-0dd6c9}

<details>
<summary>Diff</summary>
````diff
@@ -11,7 +11,7 @@ ms.custom:
   - ignite-2023
   - ignite-2024
 ms.topic: conceptual
-ms.date: 10/02/2024
+ms.date: 03/11/2025
 ---
 
 # Estimate and manage capacity of a search service
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "検索サービスの容量計画に関する更新: 日付の修正"
}
```

### Explanation
このコードの変更は、検索サービスの容量計画に関する「search-capacity-planning.md」記事の軽微な更新を示しています。具体的には、1行が削除され、1行が新たに追加され、合計で2つの変更が行われました。

最も重要な変更点は、記事の日付が「10/02/2024」から「03/11/2025」に更新されていることです。この変更により、情報が最新のものとなり、読者に正確なタイムフレームを提供します。また、他に変更はなく、内容はそのまま保たれています。これにより、ドキュメントの信頼性と一貫性が向上しています。

## articles/search/search-filters.md{#item-3f2a7a}

<details>
<summary>Diff</summary>
````diff
@@ -8,7 +8,7 @@ author: HeidiSteen
 ms.author: heidist
 ms.service: azure-ai-search
 ms.topic: concept-article
-ms.date: 09/19/2024
+ms.date: 03/11/2025
 ms.custom:
   - devx-track-csharp
   - ignite-2023
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "検索フィルターに関する更新: 日付の修正"
}
```

### Explanation
このコードの変更は、検索フィルターに関する「search-filters.md」記事の軽微な更新を示しています。変更内容は、1行が削除され、1行が新たに追加される形で、合計で2つの変更が行われました。

具体的には、記事の日付が「09/19/2024」から「03/11/2025」に更新されています。この変更により、情報が最新のものに反映され、読者に正確なタイムフレームを提供します。他の内容については変更がなく、基本的な構造や情報は維持されています。この更新により、ドキュメントの一貫性と信頼性が向上しています。

## articles/search/search-how-to-index-csv-blobs.md{#item-2c3f3e}

<details>
<summary>Diff</summary>
````diff
@@ -11,7 +11,7 @@ ms.service: azure-ai-search
 ms.custom:
   - ignite-2023
 ms.topic: how-to
-ms.date: 10/23/2024
+ms.date: 03/11/2025
 ---
 
 # Index CSV blobs and files using delimitedText parsing mode
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "CSVブロブをインデックスする方法に関する更新: 日付の修正"
}
```

### Explanation
このコードの変更は、「search-how-to-index-csv-blobs.md」記事に対する軽微な更新を示しています。具体的には、1行が削除され、1行が追加され、合計で2つの変更が行われました。

主な変更点は、記事の日付が「10/23/2024」から「03/11/2025」に更新されたことです。この更新により、情報が最新となり、読者に正確なタイムラインが提供されます。他のコンテンツには変更がなく、基本的なガイドラインや構成は維持されています。この変更は、ドキュメントの信頼性と一貫性を高める役割を果たしています。

## articles/search/search-howto-schedule-indexers.md{#item-d57e7b}

<details>
<summary>Diff</summary>
````diff
@@ -9,7 +9,7 @@ ms.service: azure-ai-search
 ms.custom:
   - ignite-2023
 ms.topic: how-to
-ms.date: 10/02/2024
+ms.date: 03/11/2025
 ---
 
 # Schedule an indexer in Azure AI Search
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "インデクサをスケジュールする方法に関する更新: 日付の修正"
}
```

### Explanation
このコードの変更は、「search-howto-schedule-indexers.md」記事に対する軽微な更新を示しています。変更内容として、1行が削除され、1行が追加され、合計で2つの変更が行われました。

具体的な修正点は、記事の日付が「10/02/2024」から「03/11/2025」に更新されていることです。この更新により、情報が最新の内容に整えられ、読者に正確な日付情報が提供されます。その他の主要な内容や構成は変更されておらず、ドキュメント全体の一貫性と信頼性が維持されています。この変更は、ユーザーに最新の情報を提供するためのもので、価値のある情報源としてドキュメントを強化しています。

## articles/search/search-indexer-tutorial.md{#item-a3e3ff}

<details>
<summary>Diff</summary>
````diff
@@ -8,7 +8,7 @@ author: HeidiSteen
 ms.author: heidist
 ms.service: azure-ai-search
 ms.topic: tutorial
-ms.date: 09/23/2024
+ms.date: 03/11/2025
 ms.custom:
   - devx-track-csharp
   - devx-track-dotnet
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "インデクサチュートリアルに関する更新: 日付の修正"
}
```

### Explanation
このコードの変更は、「search-indexer-tutorial.md」記事に対する軽微な更新を示しています。具体的には、1行が削除され、1行が追加され、合計で2つの変更が行われました。

主な変更点は、記事の日付が「09/23/2024」から「03/11/2025」に更新されたことです。この更新により、情報が最新のものに修正され、読者には適切なタイムラインが提供されます。他のコンテンツや構造に関しては変更がなく、教育的価値を持つドキュメントとしての整合性が保たれています。この変更は、ユーザーに対して信頼性のある情報を提供するために重要です。

## articles/search/search-what-is-data-import.md{#item-d73ef5}

<details>
<summary>Diff</summary>
````diff
@@ -10,12 +10,12 @@ ms.service: azure-ai-search
 ms.custom:
   - ignite-2023
 ms.topic: concept-article
-ms.date: 09/17/2024
+ms.date: 03/11/2025
 ---
 
 # Data import in Azure AI Search
 
-In Azure AI Search, queries execute over user-owned content that's loaded into a [search index](search-what-is-an-index.md). This article describes the two basic workflows for populating an index: *push* your data into the index programmatically, or *pull* in the data using a [search indexer](search-indexer-overview.md).
+In Azure AI Search, queries execute over your content that's loaded into a [search index](search-what-is-an-index.md). This article describes the two basic workflows for populating an index: *push* your data into the index programmatically, or *pull* in the data using a [search indexer](search-indexer-overview.md).
 
 Both approaches load documents from an external data source. Although you can create an empty index, it's not queryable until you add the content.
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "データインポートに関する更新: 日付とテキストの修正"
}
```

### Explanation
このコードの変更は、「search-what-is-data-import.md」記事に対する軽微な更新を示しています。変更は、2行が削除され、2行が追加され、合計で4つの変更が行われました。

具体的な修正点としては、記事の日付が「09/17/2024」から「03/11/2025」に更新されたことに加えて、文章の一部が微調整されています。特に、「user-owned content（ユーザー所有のコンテンツ）」が「your content（あなたのコンテンツ）」に変更されており、読者にとってより直接的で親しみやすい表現となっています。他の内容は変更されていないため、ドキュメントの教育的な価値や整合性が保たれています。この更新は、情報を最新のものに保ちながら、読者との関連性を高めるために行われました。

## articles/search/tutorial-rag-build-solution-maximize-relevance.md{#item-2fdb09}

<details>
<summary>Diff</summary>
````diff
@@ -10,7 +10,7 @@ ms.service: azure-ai-search
 ms.custom:
   - ignite-2024
 ms.topic: tutorial
-ms.date: 10/05/2024
+ms.date: 03/11/2025
 ---
 
 # Tutorial: Maximize relevance (RAG in Azure AI Search)
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "MAXIMIZE RELEVANCE チュートリアルの更新: 日付の修正"
}
```

### Explanation
このコードの変更は、「tutorial-rag-build-solution-maximize-relevance.md」記事に対する軽微な更新を示しています。変更内容としては、1行が削除され、1行が追加される形で、合計2つの変更が行われました。

主な修正は、チュートリアルの日付が「10/05/2024」から「03/11/2025」に変更されたことです。この更新により、読者に対して最新の情報が提供され、信頼性が向上します。その他の内容については特に変更がなく、チュートリアルの役割や内容には影響を与えていません。この変更は、情報を正確に保ちながら、ユーザーの期待に応える形で行われました。

## articles/search/tutorial-rag-build-solution.md{#item-c7eca4}

<details>
<summary>Diff</summary>
````diff
@@ -8,7 +8,7 @@ author: HeidiSteen
 ms.author: heidist
 ms.service: azure-ai-search
 ms.topic: overview
-ms.date: 10/04/2024
+ms.date: 03/11/2024
 
 ---
 
@@ -34,8 +34,6 @@ Sample code can be found in [this Python notebook](https://github.com/Azure-Samp
 
 - Minimize storage and costs
 
-<!-- - Deploy and secure an app -->
-
 We omitted a few aspects of a RAG pattern to reduce complexity:
 
 - No management of chat history and context. Chat history is typically stored and managed separately from your grounding data, which means extra steps and code. This tutorial assumes atomic question and answers from the LLM and the default LLM experience.
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "RAGビルドソリューションチュートリアルの更新: 日付と内容の修正"
}
```

### Explanation
このコードの変更は、「tutorial-rag-build-solution.md」記事に対する軽微な更新を示しています。具体的な変更としては、1行が追加され、3行が削除され、合計で4つの変更が行われました。

主な修正点は、チュートリアルの日付が「10/04/2024」から「03/11/2024」に更新されたことです。この変更により、情報が新しくなり、読者への信頼性が増します。さらに、文中から不要な情報が削除されました。特に、ストレージとコストを最小限に抑えることに関連する説明の一部が取り除かれています。これにより、記事の焦点が明確になり、複雑さが軽減されています。全体として、この更新は、チュートリアルの内容をよりシンプルかつ適切に保つことを意図したものです。

## articles/search/vector-search-how-to-chunk-documents.md{#item-b79133}

<details>
<summary>Diff</summary>
````diff
@@ -9,30 +9,29 @@ ms.service: azure-ai-search
 ms.custom:
   - ignite-2023
 ms.topic: conceptual
-ms.date: 10/01/2024
+ms.date: 03/11/2025
 ---
 
 # Chunk large documents for vector search solutions in Azure AI Search
 
-Partitioning large documents into smaller chunks can help you stay under the maximum token input limits of embedding models. For example, the maximum length of input text for the [Azure OpenAI](/azure/ai-services/openai/how-to/embeddings) text-embedding-ada-002 model is 8,191 tokens. Given that each token is around four characters of text for common OpenAI models, this maximum limit is equivalent to around 6,000 words of text. If you're using these models to generate embeddings, it's critical that the input text stays under the limit. Partitioning your content into chunks ensures that your data can be processed by the embedding models and that you don't lose information due to truncation.
+Partitioning large documents into smaller chunks can help you stay under the maximum token input limits of embedding models. For example, the maximum length of input text for the [Azure OpenAI](/azure/ai-services/openai/how-to/embeddings) text-embedding-ada-002 model is 8,191 tokens. Given that each token is around four characters of text for common OpenAI models, this maximum limit is equivalent to around 6,000 words of text. If you're using these models to generate embeddings, it's critical that the input text stays under the limit. Partitioning your content into chunks helps you meet embedding model requirements and prevents data loss due to truncation.
 
-We recommend [integrated vectorization](vector-search-integrated-vectorization.md) for built-in data chunking and embedding. Integrated vectorization takes a dependency on indexers, skillsets, the [Text Split skill](cognitive-search-skill-textsplit.md), and an embedding skill like [Azure OpenAI Embedding skill](cognitive-search-skill-azure-openai-embedding.md). If you can't use integrated vectorization, this article describes some approaches for chunking your content.
+We recommend [integrated vectorization](vector-search-integrated-vectorization.md) for built-in data chunking and embedding. Integrated vectorization takes a dependency on indexers and skillsets that split text and generate embeddings. If you can't use integrated vectorization, this article describes some alternative approaches for chunking your content.
 
 ## Common chunking techniques
 
-Chunking is only required if the source documents are too large for the maximum input size imposed by models.
+Chunking is only required if the source documents are too large for the maximum input size imposed by models. Here are some common chunking techniques, associated with built-in features if you use [indexers](search-indexer-overview.md) and [skills](cognitive-search-working-with-skillsets.md).
 
-Here are some common chunking techniques, starting with the most widely used method:
-
-+ Fixed-size chunks: Define a fixed size that's sufficient for semantically meaningful paragraphs (for example, 200 words) and allows for some overlap (for example, 10-15% of the content) can produce good chunks as input for embedding vector generators.
-
-+ Variable-sized chunks based on content: Partition your data based on content characteristics, such as end-of-sentence punctuation marks, end-of-line markers, or using features in the Natural Language Processing (NLP) libraries. Markdown language structure can also be used to split the data.
-
-+ Customize or iterate over one of the above techniques. For example, when dealing with large documents, you might use variable-sized chunks, but also append the document title to chunks from the middle of the document to prevent context loss.
+| Approach | Usage | Built-in functionality |
+|----------|-------|-----------------|
+| Fixed-size chunks | Define a fixed size that's sufficient for semantically meaningful paragraphs (for example, 200 words or 600 characters) and allows for some overlap (for example, 10-15% of the content) can produce good chunks as input for embedding vector generators. | [Text Split skill](cognitive-search-skill-textsplit.md), splitting by pages (defined by character length) |
+| Variable-sized chunks based on content characteristics | Partition your data based end-of-sentence punctuation marks, end-of-line markers, or using features in the Natural Language Processing (NLP) libraries that detect document structure. Embedded markup, like HTML or Markdown, have heading syntax that can be used to chunk data by sections. | [Document Layout skill](cognitive-search-skill-document-intelligence-layout.md) or [Text Split skill](cognitive-search-skill-textsplit.md), splitting by sentences. |
+| Custom combinations | Use a combination of fixed and variable sized chunking, or extend an approach. For example, when dealing with large documents, you might use variable-sized chunks, but also append the document title to chunks from the middle of the document to prevent context loss. | None |
+| Document parsing | Indexers can parse larger source documents into smaller search documents for indexing. Strictly speaking, this approach isn't *chunking* but it can sometimes achieve the same objective. | [Index Markdown blobs and files](search-how-to-index-markdown-blobs.md) or [one-to-many indexing](search-howto-index-one-to-many-blobs.md) or [Index JSON blobs and files ](search-howto-index-json-blobs.md) |
 
 ### Content overlap considerations
 
-When you chunk data, overlapping a small amount of text between chunks can help preserve context. We recommend starting with an overlap of approximately 10%. For example, given a fixed chunk size of 256 tokens, you would begin testing with an overlap of 25 tokens. The actual amount of overlap varies depending on the type of data and the specific use case, but we have found that 10-15% works for many scenarios.
+When you chunk data based on fixed size, overlapping a small amount of text between chunks can help preserve context. We recommend starting with an overlap of approximately 10%. For example, given a fixed chunk size of 256 tokens, you would begin testing with an overlap of 25 tokens. The actual amount of overlap varies depending on the type of data and the specific use case, but we find that 10-15% works for many scenarios.
 
 ### Factors for chunking data
 
@@ -42,11 +41,11 @@ When it comes to chunking data, think about these factors:
 
 + User queries: Larger chunks and overlapping strategies help preserve context and semantic richness for queries that target specific information.
 
-+ Large Language Models (LLM) have performance guidelines for chunk size. you need to set a chunk size that works best for all of the models you're using. For instance, if you use models for summarization and embeddings, choose an optimal chunk size that works for both.
++ Large Language Models (LLM) have performance guidelines for chunk size. Find a chunk size that works best for all of the models you're using. For instance, if you use models for summarization and embeddings, choose an optimal chunk size that works for both.
 
 ### How chunking fits into the workflow
 
-If you have large documents, you must insert a chunking step into indexing and query workflows that breaks up large text. When using [integrated vectorization](vector-search-integrated-vectorization.md), a default chunking strategy using the [Text Split skill](./cognitive-search-skill-textsplit.md) is applied. You can also apply a custom chunking strategy using a [custom skill](cognitive-search-custom-skill-web-api.md). Some libraries that provide chunking include:
+If you have large documents, insert a chunking step into indexing and query workflows that breaks up large text. When using [integrated vectorization](vector-search-integrated-vectorization.md), a default chunking strategy using the [Text Split skill](./cognitive-search-skill-textsplit.md) is common. You can also apply a custom chunking strategy using a [custom skill](cognitive-search-custom-skill-web-api.md). Some external libraries that provide chunking include:
 
 + [LangChain Text Splitters](https://python.langchain.com/v0.1/docs/modules/data_connection/document_transformers/)
 + [Semantic Kernel TextChunker](/dotnet/api/microsoft.semantickernel.text.textchunker)
@@ -77,7 +76,7 @@ The `pages` parameter adds extra parameters:
 
 + `maximumPageLength` defines the maximum number of characters <sup>1</sup> or tokens <sup>2</sup> in each chunk. The text splitter avoids breaking up sentences, so the actual character count depends on the content.
 + `pageOverlapLength` defines how many characters from the end of the previous page are included at the start of the next page. If set, this must be less than half the maximum page length.
-+ `maximumPagesToTake` defines how many pages / chunks to take from a document. The default value is 0, which means taking all pages or chunks from the document.
++ `maximumPagesToTake` defines how many pages / chunks to take from a document. The default value is 0, which means to take all pages or chunks from the document.
 
 <sup>1</sup> Characters don't align to the definition of a [token](/azure/ai-services/openai/concepts/prompt-engineering#space-efficiency). The number of tokens measured by the LLM might be different than the character size measured by the Text Split skill.
 
@@ -95,23 +94,23 @@ The following table shows how the choice of parameters affects the total chunk c
 | `pages` | 5000 | 500 | 38 |
 | `sentences` | N/A | N/A | 13361 |
 
-Using a `textSplitMode` of `pages` results in a majority of chunks having total character counts close to `maximumPageLength`. Chunk character count varies due to differences on where sentence boundaries fall inside the chunk. Chunk token length varies due to differences in the contents of the chunk.
+Using a `textSplitMode` of `pages` results in most chunks having total character counts close to `maximumPageLength`. Chunk character count varies due to differences on where sentence boundaries fall inside the chunk. Chunk token length varies due to differences in the contents of the chunk.
 
 The following histograms show how the distribution of chunk character length compares to chunk token length for [gpt-35-turbo](/azure/ai-services/openai/how-to/chatgpt) when using a `textSplitMode` of `pages`, a `maximumPageLength` of 2000, and a `pageOverlapLength` of 500 on the Earth at Night e-book:
 
    :::image type="content" source="./media/vector-search-how-to-chunk-documents/maximumpagelength-2000-pageoverlap-500-characters.png" alt-text="Histogram of chunk character count for maximumPageLength 2000 and pageOverlapLength 500.":::
 
    :::image type="content" source="./media/vector-search-how-to-chunk-documents/maximumpagelength-2000-pageoverlap-500-tokens.png" alt-text="Histogram of chunk token count for maximumPageLength 2000 and pageOverlapLength 500.":::
 
-Using a `textSplitMode` of `sentences` results in a large number of chunks consisting of individual sentences. These chunks are significantly smaller than those produced by `pages`, and the token count of the chunks more closely matches the character counts.
+Using a `textSplitMode` of `sentences` results in a large number of chunks consisting of individual sentences. These chunks are smaller than those produced by `pages`, and the token count of the chunks more closely matches the character counts.
 
 The following histograms show how the distribution of chunk character length compares to chunk token length for [gpt-35-turbo](/azure/ai-services/openai/how-to/chatgpt) when using a `textSplitMode` of `sentences` on the Earth at Night e-book:
 
    :::image type="content" source="./media/vector-search-how-to-chunk-documents/sentences-characters.png" alt-text="Histogram of chunk character count for sentences.":::
 
    :::image type="content" source="./media/vector-search-how-to-chunk-documents/sentences-tokens.png" alt-text="Histogram of chunk token count for sentences.":::
 
-The optimal choice of parameters depends on how the chunks will be used. For most applications, it's recommended to start with the following default parameters:
+The optimal choice of parameters depends on how the chunks are used. For most applications, it's recommended to start with the following default parameters:
 
 | `textSplitMode` | `maximumPageLength` | `pageOverlapLength` |
 |-----------------|-----------------|-----------------|
@@ -164,7 +163,7 @@ print(f"Max: {max_token_count}")
 
 Output indicates that no pages have zero tokens, the average token length per page is 189 tokens, and the maximum token count of any page is 1,583.
 
-Knowing the average and maximum token size gives you insight into setting chunk size. Although you could use the standard recommendation of 2000 characters with a 500 character overlap, in this case it makes sense to go lower given the token counts of the sample document. In fact, setting an overlap value that's too large can result in no overlap appearing at all.
+Knowing the average and maximum token size gives you insight into setting chunk size. Although you could use the standard recommendation of 2,000 characters with a 500 character overlap, in this case it makes sense to go lower given the token counts of the sample document. In fact, setting an overlap value that's too large can result in no overlap appearing at all.
 
 ```python
 from langchain.text_splitter import RecursiveCharacterTextSplitter
@@ -195,6 +194,6 @@ A [fixed-sized chunking and embedding generation sample](https://github.com/Azur
 
 ## See also
 
-+ [Understanding embeddings in Azure OpenAI Service](/azure/ai-services/openai/concepts/understand-embeddings)
++ [Understand embeddings in Azure OpenAI Service](/azure/ai-services/openai/concepts/understand-embeddings)
 + [Learn how to generate embeddings](/azure/ai-services/openai/how-to/embeddings)
 + [Tutorial: Explore Azure OpenAI Service embeddings and document search](/azure/ai-services/openai/tutorials/embeddings)
````
</details>

### Summary

```json
{
    "modification_type": "breaking change",
    "modification_title": "ベクター検索のドキュメントチャンク化方法の大幅な更新"
}
```

### Explanation
このコードの変更は、「vector-search-how-to-chunk-documents.md」ドキュメントに対する大幅な更新を示しています。合計で39の変更が行われ、そのうち19行が追加され、20行が削除されました。このような大規模な修正は内容の構造や説明をきれいに整理し、最新の情報を提供することを目的としています。

主な更新には、ドキュメントの日付の変更（「10/01/2024」から「03/11/2025」への更新）、チュートリアル内の段落の修正や簡略化が含まれています。具体的には、情報の明確化や冗長な部分の削除が行われ、内容がより直感的かつ読みやすくなっています。特に、データチャンク方法やベクター検索ソリューションに関する手法は、表形式に整理され、各アプローチの機能や使用法についての記述が追加されています。

この更新によって、読者は効率的にデータをチャンク化し、ベクター検索を効果的に使用するための実践的な手法を得ることができます。情報の整理と最新化が図られ、全体的に信頼性の高いガイドラインが提供されるようになっています。

## articles/search/vector-search-how-to-generate-embeddings.md{#item-e98f7b}

<details>
<summary>Diff</summary>
````diff
@@ -9,14 +9,14 @@ ms.service: azure-ai-search
 ms.custom:
   - ignite-2023
 ms.topic: how-to
-ms.date: 09/19/2024
+ms.date: 03/11/2025
 ---
 
 # Generate embeddings for search queries and documents
 
-Azure AI Search doesn't host vectorization models, so one of your challenges is creating embeddings for query inputs and outputs. You can use any supported embedding model, but this article assumes Azure OpenAI embedding models for the steps.
+Azure AI Search doesn't host embedding models, so one of your challenges is creating vectors for query inputs and outputs. You can use any supported embedding model, but this article assumes Azure OpenAI embedding models for illustration.
 
-We recommend [integrated vectorization](vector-search-integrated-vectorization.md), which provides built-in data chunking and vectorization. Integrated vectorization takes a dependency on indexers, skillsets, and built-in or custom skills that point to a model that executes externally from Azure AI Search.
+We recommend [integrated vectorization](vector-search-integrated-vectorization.md), which provides built-in data chunking and vectorization. Integrated vectorization takes a dependency on indexers, skillsets, and built-in or custom skills that point to a model that executes externally from Azure AI Search. Several built-in skills point to embedding models in Azure AI Foundry, which makes integrated vectorization your easiest solution for solving the embedding challenge.
 
 If you want to handle data chunking and vectorization yourself, we provide demos in the [sample repository](https://github.com/Azure/azure-search-vector-samples/tree/main) that show you how to integrate with other community solutions.
 
@@ -30,7 +30,7 @@ If you want to handle data chunking and vectorization yourself, we provide demos
 
 ## Create resources in the same region
 
-Integrated vectorization requires resources to be in the same region:
+Integrated vectorization usually requires resources to be in the same region:
 
 1. [Check regions for a text embedding model](/azure/ai-services/openai/concepts/models#model-summary-table-and-region-availability).
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "埋め込み生成チュートリアルの軽微な修正"
}
```

### Explanation
このコードの変更は、「vector-search-how-to-generate-embeddings.md」ドキュメントに対する軽微な更新を示しています。合計で8つの変更が行われ、4行が追加され、4行が削除されました。

具体的な修正内容としては、ドキュメントの日付が「09/19/2024」から「03/11/2025」に変更され、埋め込みモデルに関する説明が明確化されています。特に、「Azure AI Search doesn't host vectorization models」という表現が「Azure AI Search doesn't host embedding models」に変更され、より具体的な情報提供がされています。また、推奨される「integrated vectorization」のメリットに関する説明が追加され、Azure AI Foundryにおける埋め込みモデルに触れて、統合ベクタリゼーションが埋め込み課題を解決するための最も簡単なソリューションであることが強調されています。

全体として、この更新は内容の明瞭性を向上させ、読者にとっての理解を助けることを目的としています。最新の情報を反映し、埋め込み生成に関する実用的なアドバイスが提供されています。

## articles/search/vector-search-how-to-query.md{#item-9bb93c}

<details>
<summary>Diff</summary>
````diff
@@ -9,7 +9,7 @@ ms.service: azure-ai-search
 ms.custom:
   - build-2024
 ms.topic: how-to
-ms.date: 09/24/2024
+ms.date: 03/11/2025
 ---
 
 # Create a vector query in Azure AI Search
@@ -497,7 +497,7 @@ Because nearest neighbor search always returns the requested `k` neighbors, it's
 
 This parameter is still in preview. We recommend preview REST API version [2024-05-01-preview](/rest/api/searchservice/documents/search-post?view=rest-searchservice-2024-05-01-preview&preserve-view=true).
 
-In this example, all matches that score below 0.8 are excluded from vector search results, even if the number of results fall below `k`.
+In this example, all matches that score below 0.8 are excluded from vector search results, even if the number of results falls below `k`.
 
 ```http
 POST https://[service-name].search.windows.net/indexes/[index-name]/docs/search?api-version=2024-05-01-preview 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "ベクトル検索クエリの文法の修正"
}
```

### Explanation
このコードの変更は、「vector-search-how-to-query.md」ドキュメントに対する軽微な更新を示しています。合計で4つの変更が行われ、2行が追加され、2行が削除されました。

主な更新内容は、ドキュメントの日付が「09/24/2024」から「03/11/2025」に変更されたことです。また、一つの文の文法が修正され、「the number of results fall below `k`」から「the number of results falls below `k`」に変更されています。この文法的な修正により、内容がより正確で理解しやすくなっています。

全体として、この更新はドキュメントの最新化と文法の明瞭化を目的としており、読者にとっての理解を助けることが期待されます。ベクトル検索クエリに関する重要な情報が正しく伝わるよう配慮されています。

## articles/search/vector-store.md{#item-db9b8c}

<details>
<summary>Diff</summary>
````diff
@@ -9,7 +9,7 @@ ms.service: azure-ai-search
 ms.custom:
   - ignite-2023
 ms.topic: concept-article
-ms.date: 09/19/2024
+ms.date: 03/11/2025
 ---
 
 # Vector storage in Azure AI Search
@@ -29,9 +29,9 @@ Considerations for vector storage include the following points:
 
 In Azure AI Search, there are two patterns for working with search results. 
 
-+ Generative search. Language models formulate a response to the user's query using data from Azure AI Search. This pattern includes an orchestration layer to coordinate prompts and maintain context. In this pattern, search results are fed into prompt flows, received by chat models like GPT and Text-Davinci. This approach is based on [**Retrieval augmented generation (RAG)**](retrieval-augmented-generation-overview.md) architecture, where the search index provides the grounding data.
++ Generative search. Language models formulate a response to the user's query using grounding data from Azure AI Search. This pattern typically includes an orchestration layer to coordinate prompts and maintain context. In this pattern, search results are fed into prompt flows, received by chat models like GPT. This approach is based on [**Retrieval augmented generation (RAG)**](retrieval-augmented-generation-overview.md) architecture, where the search index provides the grounding data.
 
-+ Classic search using a search bar, query input string, and rendered results. The search engine accepts and executes the vector query, formulates a response, and you render those results in a client app. In Azure AI Search, results are returned in a flattened row set, and you can choose which fields to include search results. Since there's no chat model, it's expected that you would populate the vector store (search index) with nonvector content that's human readable in your response. Although the search engine matches on vectors, you should use nonvector values to populate the search results. [**Vector queries**](vector-search-how-to-query.md) and [**hybrid queries**](hybrid-search-how-to-query.md) cover the types of query requests you can formulate for classic search scenarios.
++ Classic search using a search bar, query input, and rendered results. The search engine formulates the response using verbatim content in the search index, with no extra reasoning or logic. At query time, your application code or the search engine vectorizes the user input into a vector. The search engine performs a vector search over vector fields and formulates a response. You render those results in a client app. In Azure AI Search, results are returned in a flattened row set, and you can choose which fields to include search results. Since there's no chat model, it's expected that you would populate the vector store (search index) with nonvector content that's human readable in your response. Although the search engine matches on vectors, you should use nonvector values to populate the search results. [**Vector queries**](vector-search-how-to-query.md) and [**hybrid queries**](hybrid-search-how-to-query.md) cover the types of query requests you can formulate for classic search scenarios.
 
 Your index schema should reflect your primary use case. The following section highlights the differences in field composition for solutions built for generative AI or classic search.
 
@@ -171,7 +171,7 @@ Vector index limits and estimations are covered in [another article](vector-sear
 This section introduces vector run time operations, including connecting to and securing a single index.
 
 > [!NOTE]
-> When managing an index, be aware that there is no portal or API support for moving or copying an index. Instead, customers typically point their application deployment solution at a different search service (if using the same index name), or revise the name to create a copy on the current search service, and then build it.
+> When managing an index, be aware that there's no portal or API support for moving or copying an index. Instead, customers typically point their application deployment solution at a different search service (if using the same index name), or revise the name to create a copy on the current search service, and then build it.
 
 ### Continuously available
 
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "ベクトルストレージに関する軽微な修正"
}
```

### Explanation
このコードの変更は、「vector-store.md」ドキュメントに対する軽微な更新を示しています。合計で8つの変更が行われ、4行が追加され、4行が削除されました。

主な内容としては、ドキュメントの日付が「09/19/2024」から「03/11/2025」に変更されており、情報の新しさが保たれています。また、「Generative search」や「Classic search」に関する説明文が一部修正され、特に「基盤データ」や「検索エンジンによる応答形成」の部分が明確化されています。

さらに、注意事項のセクションにおいて、「there is no」と「there's no」という表現の修正が行われ、より口語的で自然な表現に統一されています。これにより、読者が文章をスムーズに理解できるよう配慮されています。

全体的に、この更新は明瞭性の向上を目指し、技術的な情報が正確に伝わるよう工夫されています。ベクトルストレージに関する重要な考慮点が明確に示されており、読者の理解を深める助けとなるでしょう。


