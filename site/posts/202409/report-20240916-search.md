---
date: '2024-09-16'
permalink: https://github.com/MicrosoftDocs/azure-ai-docs/compare/MicrosoftDocs:804ee13...MicrosoftDocs:41463e4
summary: このアップデートは、Azure AI Searchに関する複数のチュートリアルとビジュアル要素を強化し、Retrieval-Augmented Generation（RAG）ソリューションの構築と利用に関する新しいドキュメントと画像を追加しました。新たに追加された画像は、チュートリアルをより視覚的にわかりやすくし、インデックス設計やモデル設定、インデクシングパイプライン構築などの新しいチュートリアルが提供されています。これにより、ユーザーはAzure
  AI Searchの機能をより効果的に利用できるようになります。リンク修正や新しいリソースの追加も行われ、最新の情報に基づいたRAGソリューションの開発をサポートしています。
title: Diff Insight Report - search

---

[View Diff on GitHub](https://github.com/MicrosoftDocs/azure-ai-docs/compare/MicrosoftDocs:804ee13...MicrosoftDocs:41463e4){target="_blank"}

# Highlights
このアップデートは、Azure AI Searchに関する複数のチュートリアルとビジュアル要素を強化し、Retrieval-Augmented Generation（RAG）ソリューションの構築および利用に深い洞察を提供する新しいドキュメントと画像を追加するという大きな変更を伴っています。

## New features
- チャット結果画像の追加
  - `chat-results-1.png`
  - `chat-results-2.png`
  - `chat-results-3.png`
  - `chat-results-4.png`
  - `chat-results-filter.png`
- RAGソリューションに関する新しいチュートリアルの追加
  - インデックス設計ガイド
  - モデルの設定ガイド
  - インデクシングパイプラインの構築
  - LLMを使用した検索の構築
- 目次（toc.yml）にRAGチュートリアルセクションの追加
- 既存ドキュメントのリンクおよびリソースの更新

## Breaking changes
なし

## Other updates
- 「retrieval-augmented-generation-overview.md」および「search-get-started-rag.md」のマイナーアップデートによるリンク修正と新しいリソースの追加。

# Insights
このアップデートは、Azure AI Searchを利用したRAG（Retrieval-Augmented Generation）ソリューションの開発および理解を深めるために大幅な拡張が行われました。具体的には、以下の点に注目します。

新たに追加された画像により、チュートリアルがビジュアル的によりわかりやすくなりました。`chat-results-1.png`から`chat-results-filter.png`までの一連の画像は、ユーザーが視覚的なコンテキストを持ちながら学ぶ手助けをします。これらの画像は、Azure AI ドキュメントのチュートリアルセクションで、結果の解釈や実装手順の理解を深めるために使用されることが期待されます。

ドキュメントの側面では、「retrieval-augmented-generation-overview.md」のリンク修正と、新しいリソースの追加が行われました。これにより、最新のビデオリソースや新しいクイックスタートチュートリアルに簡単にアクセスできるようになり、ユーザーは最新の情報に基づいたRAGソリューションを開発する際に役立てることができます。

特に注目すべきは、新しく追加された数多くのチュートリアルです。以下に簡単な概要をもう一度示します。
1. **インデックス設計ガイド**は、特にRAGに必須なインデックスの設計に関する具体的なアプローチを提供し、ベクターやハイブリッドクエリ対応のインデックス構築方法を詳細に解説しています。
2. **モデルの設定ガイド**は、RAGに使用する埋め込みモデルとチャットモデルの設定方法に焦点を当てており、Azureクラウドでのデプロイ方法やカスタムスキルの活用についても触れています。
3. **インデクシングパイプラインの構築**は、自動化されたインデクシングを実現するための具体的な手順を通じて、ユーザーがデータを効率的に取り込み、チャンク処理やベクター化を行うプロセスを詳細に説明しています。
4. **LLMを使用した検索の構築**は、RAGソリューションにおけるLLMとの対話的クエリの送信方法やフィルタリング技術を解説し、ユーザーが効果的なクエリを実行して高品質な応答を得る方法を紹介しています。

これらのチュートリアルは、RAGソリューションの構築を段階的に学ぶための包括的なガイドラインを提供し、利用者がAzure AI Searchの機能を最大限に活用するための手助けとなります。最終的には、これらの更新により、Azure AI Searchを用いたRAGソリューションの構築

# Summary Table
|  Filename  | Type |    Title    | Status | A  | D  | M  |
|------------|------|-------------|--------|----|----|----|
| [chat-results-1.png](#item-46f80f) | new feature | チャット結果画像の追加 | added | 0 | 0 | 0 | 
| [chat-results-2.png](#item-a972eb) | new feature | チャット結果画像の追加 | added | 0 | 0 | 0 | 
| [chat-results-3.png](#item-b78ca5) | new feature | チャット結果画像の追加 | added | 0 | 0 | 0 | 
| [chat-results-4.png](#item-cf47d5) | new feature | チャット結果画像の追加 | added | 0 | 0 | 0 | 
| [chat-results-filter.png](#item-844b51) | new feature | チャット結果フィルター画像の追加 | added | 0 | 0 | 0 | 
| [retrieval-augmented-generation-overview.md](#item-ec76e0) | minor update | RAGソリューションに関するドキュメントの更新 | modified | 3 | 1 | 4 | 
| [search-get-started-rag.md](#item-05ff0e) | minor update | RAGの開始ガイドに関する文言の修正 | modified | 2 | 2 | 4 | 
| [toc.yml](#item-c4768f) | minor update | RAGチュートリアルに関するセクションの追加 | modified | 13 | 0 | 13 | 
| [tutorial-rag-build-solution-index-schema.md](#item-9a17ca) | new feature | RAGチュートリアル: インデックス設計ガイドの追加 | added | 201 | 0 | 201 | 
| [tutorial-rag-build-solution-models.md](#item-6796c9) | new feature | RAGチュートリアル: モデルの設定ガイドの追加 | added | 181 | 0 | 181 | 
| [tutorial-rag-build-solution-pipeline.md](#item-25ce01) | new feature | RAGチュートリアル: インデクシングパイプラインの構築 | added | 373 | 0 | 373 | 
| [tutorial-rag-build-solution-query.md](#item-93965f) | new feature | RAGチュートリアル: LLMを使用した検索の構築 | added | 234 | 0 | 234 | 
| [tutorial-rag-build-solution.md](#item-c7eca4) | new feature | RAGソリューションの構築 | added | 56 | 0 | 56 | 


# Modified Contents
## articles/search/media/tutorial-rag-solution/chat-results-1.png{#item-46f80f}

### Summary

```json
{
    "modification_type": "new feature",
    "modification_title": "チャット結果画像の追加"
}
```

### Explanation
この変更は、新しい画像ファイル「chat-results-1.png」の追加を示しています。変更内容には削除や修正はなく、ファイルがリポジトリに新たに追加されたことがわかります。この画像は、Azure AI ドキュメントに関連するチュートリアルの一部として使用されると思われます。追加されたファイルのURLは以下の通りです。  
- [リポジトリ内の画像リンク](https://github.com/MicrosoftDocs/azure-ai-docs/blob/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Fmedia%2Ftutorial-rag-solution%2Fchat-results-1.png)  
- [生の画像データへのリンク](https://github.com/MicrosoftDocs/azure-ai-docs/raw/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Fmedia%2Ftutorial-rag-solution%2Fchat-results-1.png)  

この追加により、チュートリアルのビジュアルコンテンツが向上し、ユーザーが文脈をよりよく理解できるようになるでしょう。

## articles/search/media/tutorial-rag-solution/chat-results-2.png{#item-a972eb}

### Summary

```json
{
    "modification_type": "new feature",
    "modification_title": "チャット結果画像の追加"
}
```

### Explanation
この変更は、新しい画像ファイル「chat-results-2.png」の追加を示しています。ファイルには、削除および変更がなく、完全に新規の追加です。この画像は、Azure AI に関するチュートリアルの一部として使われることが予想されます。追加されたファイルのURLは以下の通りです。  
- [リポジトリ内の画像リンク](https://github.com/MicrosoftDocs/azure-ai-docs/blob/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Fmedia%2Ftutorial-rag-solution%2Fchat-results-2.png)  
- [生の画像データへのリンク](https://github.com/MicrosoftDocs/azure-ai-docs/raw/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Fmedia%2Ftutorial-rag-solution%2Fchat-results-2.png)  

この新しい画像の追加によって、チュートリアルのビジュアル情報が強化され、ユーザーが内容をより効果的に理解できるようになります。

## articles/search/media/tutorial-rag-solution/chat-results-3.png{#item-b78ca5}

### Summary

```json
{
    "modification_type": "new feature",
    "modification_title": "チャット結果画像の追加"
}
```

### Explanation
この変更は、新しい画像ファイル「chat-results-3.png」の追加を示しています。このファイルには、削除や変更がなく、新規に追加されたものです。この画像は、Azure AI に関するチュートリアルの一部として利用されると考えられます。追加されたファイルのURLは以下の通りです。  
- [リポジトリ内の画像リンク](https://github.com/MicrosoftDocs/azure-ai-docs/blob/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Fmedia%2Ftutorial-rag-solution%2Fchat-results-3.png)  
- [生の画像データへのリンク](https://github.com/MicrosoftDocs/azure-ai-docs/raw/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Fmedia%2Ftutorial-rag-solution%2Fchat-results-3.png)  

この新しい画像の追加によって、チュートリアルにおける視覚的なサポートが強化され、ユーザーがコンテンツをよりよく理解できるようになります。

## articles/search/media/tutorial-rag-solution/chat-results-4.png{#item-cf47d5}

### Summary

```json
{
    "modification_type": "new feature",
    "modification_title": "チャット結果画像の追加"
}
```

### Explanation
この変更は、新たに「chat-results-4.png」という画像ファイルが追加されたことを示しています。このファイルは新規に追加されたものであり、削除や変更はありません。この画像は、Azure AI に関するチュートリアルの一部として使われる見込みです。追加されたファイルのURLは以下の通りです。  
- [リポジトリ内の画像リンク](https://github.com/MicrosoftDocs/azure-ai-docs/blob/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Fmedia%2Ftutorial-rag-solution%2Fchat-results-4.png)  
- [生の画像データへのリンク](https://github.com/MicrosoftDocs/azure-ai-docs/raw/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Fmedia%2Ftutorial-rag-solution%2Fchat-results-4.png)  

この新しい画像の追加により、チュートリアルはより視覚的に強化され、ユーザーが提供される情報を効果的に理解する助けとなるでしょう。

## articles/search/media/tutorial-rag-solution/chat-results-filter.png{#item-844b51}

### Summary

```json
{
    "modification_type": "new feature",
    "modification_title": "チャット結果フィルター画像の追加"
}
```

### Explanation
この変更は、新しい画像ファイル「chat-results-filter.png」の追加を示しています。このファイルは新規に追加されたもので、削除や変更はありません。この画像は、Azure AI に関連するチュートリアルの一環として使用されると期待されます。追加されたファイルのURLは以下の通りです。  
- [リポジトリ内の画像リンク](https://github.com/MicrosoftDocs/azure-ai-docs/blob/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Fmedia%2Ftutorial-rag-solution%2Fchat-results-filter.png)  
- [生の画像データへのリンク](https://github.com/MicrosoftDocs/azure-ai-docs/raw/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Fmedia%2Ftutorial-rag-solution%2Fchat-results-filter.png)  

この新しい画像の追加により、チュートリアルが視覚的に強化され、ユーザーが情報をより効果的に理解できるようになるでしょう。

## articles/search/retrieval-augmented-generation-overview.md{#item-ec76e0}

<details>
<summary>Diff</summary>
````diff
@@ -30,7 +30,7 @@ The decision about which information retrieval system to use is critical because
 Azure AI Search is a [proven solution for information retrieval](/azure/developer/python/get-started-app-chat-template?tabs=github-codespaces) in a RAG architecture. It provides indexing and query capabilities, with the infrastructure and security of the Azure cloud. Through code and other components, you can design a comprehensive RAG solution that includes all of the elements for generative AI over your proprietary content. 
 
 > [!NOTE]
-> New to copilot and RAG concepts? Watch [Vector search and state of the art retrieval for Generative AI apps](https://ignite.microsoft.com/sessions/18618ca9-0e4d-4f9d-9a28-0bc3ef5cf54e?source=sessions).
+> New to copilot and RAG concepts? Watch [Vector search and state of the art retrieval for Generative AI apps](https://www.youtube.com/watch?v=lSzc1MJktAo).
 
 ## Approaches for RAG with Azure AI Search
 
@@ -222,6 +222,8 @@ A RAG solution that includes Azure AI Search can leverage [built-in data chunkin
 
 + [Try this RAG quickstart](search-get-started-rag.md) for a demonstration of query integration with chat models over a search index.
 
++ [Tutorial: How to build a RAG solution in Azure AI Search](tutorial-rag-build-solution.md) for focused coverage on the features and pattern for RAG solutions that obtain grounding data from a search index.
+
 + Start with solution accelerators:
 
   + ["Chat with your data" solution accelerator](https://github.com/Azure-Samples/chat-with-your-data-solution-accelerator) helps you create a custom RAG solution over your content.
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "RAGソリューションに関するドキュメントの更新"
}
```

### Explanation
この変更は、「retrieval-augmented-generation-overview.md」ファイルの更新を示しています。この更新では、主に情報のリンクが修正され、新しいリソースが追加されています。具体的には、以下の点が変更されています。

1. コパイロットとRAGの概念に関するビデオリンクが、従来のリンクからYouTubeの新しいリンクに変更されました。
   - 変更前: [Vector search and state of the art retrieval for Generative AI apps](https://ignite.microsoft.com/sessions/18618ca9-0e4d-4f9d-9a28-0bc3ef5cf54e?source=sessions)
   - 変更後: [Vector search and state of the art retrieval for Generative AI apps](https://www.youtube.com/watch?v=lSzc1MJktAo)

2. 新しいセクションが追加され、RAGソリューションのクイックスタートとチュートリアルに関するリンクが挿入されました。
   - [Try this RAG quickstart](search-get-started-rag.md)
   - [Tutorial: How to build a RAG solution in Azure AI Search](tutorial-rag-build-solution.md)

これらの変更により、ドキュメントがより包括的で、ユーザーがRAGソリューションを構築するための具体的なリソースへアクセスしやすくなっています。ドキュメント全体のURLは以下の通りです。  
- [記事へのリンク](https://github.com/MicrosoftDocs/azure-ai-docs/blob/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Fretrieval-augmented-generation-overview.md)  
- [生のMarkdownファイルへのリンク](https://github.com/MicrosoftDocs/azure-ai-docs/raw/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Fretrieval-augmented-generation-overview.md)  

この更新は、ユーザーが新しいリソースを活用しやすくするための重要なステップです。

## articles/search/search-get-started-rag.md{#item-05ff0e}

<details>
<summary>Diff</summary>
````diff
@@ -276,6 +276,6 @@ When you're working in your own subscription, it's a good idea at the end of a p
 
 You can find and manage resources in the portal by using the **All resources** or **Resource groups** link in the leftmost pane.
 
-## Next steps
+## See also
 
-As a next step, we recommend that you review the demo code for [Python](https://github.com/Azure/azure-search-vector-samples/tree/main/demo-python), [C#](https://github.com/Azure/azure-search-vector-samples/tree/main/demo-dotnet), or [JavaScript](https://github.com/Azure/azure-search-vector-samples/tree/main/demo-javascript) on the azure-search-vector-samples repository.
+- [Tutorial: How to build a RAG solution in Azure AI Search](tutorial-rag-build-solution.md)
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "RAGの開始ガイドに関する文言の修正"
}
```

### Explanation
この変更は、「search-get-started-rag.md」ファイルの更新を示しています。主な内容は、セクションタイトルの変更といくつかの文言の修正です。具体的には、次の変更が行われました。

1. 「Next steps」セクションのタイトルが「See also」に変更され、ページの内容がより明確になっています。

2. 次のステップとして、Azure のリソースとデモコードのレビューを推奨する文言が更新され、Python、C#、JavaScript 向けのデモコードへのリンクが提供されるようになりました。このリンクは、Azure Search Vector Samples リポジトリに関連しています。
   - [Python デモコード](https://github.com/Azure/azure-search-vector-samples/tree/main/demo-python)
   - [C# デモコード](https://github.com/Azure/azure-search-vector-samples/tree/main/demo-dotnet)
   - [JavaScript デモコード](https://github.com/Azure/azure-search-vector-samples/tree/main/demo-javascript)

3. 新たに追加されたリソースとして、RAG ソリューションの構築に関するチュートリアルへのリンクも挿入されました。
   - [Tutorial: How to build a RAG solution in Azure AI Search](tutorial-rag-build-solution.md)

これらの変更により、利用者が関連情報をより簡単に見つけることができ、RAG ソリューションに関する理解が深まることが期待されます。ドキュメント全体のURLは以下の通りです。  
- [記事へのリンク](https://github.com/MicrosoftDocs/azure-ai-docs/blob/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Fsearch-get-started-rag.md)  
- [生のMarkdownファイルへのリンク](https://github.com/MicrosoftDocs/azure-ai-docs/raw/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Fsearch-get-started-rag.md)  

この更新は、ユーザーにとって有益なリソースへのナビゲーションを改善する重要なステップです。

## articles/search/toc.yml{#item-c4768f}

<details>
<summary>Diff</summary>
````diff
@@ -1,3 +1,4 @@
+items:
 - name: Azure AI Search Documentation
   href: index.yml
 - name: Overview
@@ -89,6 +90,18 @@
       href: search-howto-index-encrypted-blobs.md
     - name: Create a custom analyzer
       href: tutorial-create-custom-analyzer.md
+  - name: RAG tutorials
+    items:
+    - name: Build a RAG solution
+      href: tutorial-rag-build-solution.md
+    - name: Choose models
+      href: tutorial-rag-build-solution-models.md
+    - name: Design an index
+      href: tutorial-rag-build-solution-index-schema.md
+    - name: Build an indexing pipeline
+      href: tutorial-rag-build-solution-pipeline.md
+    - name: Search and generate answers
+      href: tutorial-rag-build-solution-query.md
   - name: Skills tutorials
     items:
     - name: C#
````
</details>

### Summary

```json
{
    "modification_type": "minor update",
    "modification_title": "RAGチュートリアルに関するセクションの追加"
}
```

### Explanation
この変更は、「toc.yml」ファイルの更新を示しており、Azure AI Search に関する目次の項目が追加されています。特に、RAG（Retrieval-Augmented Generation）ソリューションに関連するチュートリアルのセクションが新たに組み込まれています。以下に具体的な変更内容を示します。

1. **目次の構造の追加**: 新たに「items」セクションが追加され、その中に「Azure AI Search Documentation」や「Overview」に続くエントリが設定されています。

2. **RAGチュートリアルの追加**: 
   - 「RAG tutorials」というセクションが追加され、その中に以下の各チュートリアルのリンクが含まれています。
     - **Build a RAG solution**: [tutorial-rag-build-solution.md]
     - **Choose models**: [tutorial-rag-build-solution-models.md]
     - **Design an index**: [tutorial-rag-build-solution-index-schema.md]
     - **Build an indexing pipeline**: [tutorial-rag-build-solution-pipeline.md]
     - **Search and generate answers**: [tutorial-rag-build-solution-query.md]

これにより、ユーザーは RAG に関するチュートリアルへ簡単にアクセスできるようになり、Azure AI Search の機能をより効果的に活用できるようになります。更新後の目次の全体像やその他のリンクは、以下のリンクから確認できます。
- [記事へのリンク](https://github.com/MicrosoftDocs/azure-ai-docs/blob/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Ftoc.yml)  
- [生のYAMLファイルへのリンク](https://github.com/MicrosoftDocs/azure-ai-docs/raw/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Ftoc.yml)  

この更新は、RAGに関するリソースへのナビゲーションを改善するための重要なステップです。

## articles/search/tutorial-rag-build-solution-index-schema.md{#item-9a17ca}

<details>
<summary>Diff</summary>
````diff
@@ -0,0 +1,201 @@
+---
+title: 'RAG Tutorial: Design an index'
+titleSuffix: Azure AI Search
+description: Design an index for RAG patterns in Azure AI Search.
+
+manager: nitinme
+author: HeidiSteen
+ms.author: heidist
+ms.service: cognitive-search
+ms.topic: tutorial
+ms.date: 09/12/2024
+
+---
+
+# Tutorial: Design an index for RAG in Azure AI Search
+
+An index contains searchable text and vector content, plus configurations. In a RAG pattern that uses a chat model for responses, you want an index that contains chunks of content that can be passed to an LLM at query time. 
+
+In this tutorial, you:
+
+> [!div class="checklist"]
+> - Learn the characteristics of an index schema built for RAG
+> - Create an index that accommodate vectors and hybrid queries
+> - Add vector profiles and configurations
+> - Add structured data
+> - Add filtering
+
+## Prerequisites
+
+[Visual Studio Code](https://code.visualstudio.com/download) with the [Python extension](https://marketplace.visualstudio.com/items?itemName=ms-python.python) and the [Jupyter package](https://pypi.org/project/jupyter/). For more information, see [Python in Visual Studio Code](https://code.visualstudio.com/docs/languages/python).
+
+The output of this exercise is an index definition in JSON. At this point, it's not uploaded to Azure AI Search, so there are no requirements for cloud services or permissions in this exercise.
+
+## Review schema considerations for RAG
+
+In conversational search, LLMs compose the response that the user sees, not the search engine, so you don't need to think about what fields to show in your search results, and whether the representations of individual search documents are coherent to the user. Depending on the question, the LLM might return verbatim content from your index, or more likely, repackage the content for a better answer.
+
+### Organized around chunks
+
+When LLMs generate a response, they operate on chunks of content for message inputs, and while they need to know where the chunk came from for citation purposes, what matters most is the quality of message inputs and its relevance to the user's question. Whether the chunks come from one document or a thousand, the LLM ingests the information or *grounding data*, and formulates the response using instructions provided in a system prompt.
+
+Chunks are the focus of the schema, and each chunk is the defining element of a search document in a RAG pattern. You can think of your index as a large collection of chunks, as opposed to traditional search documents that probably have more structure, such as fields containing uniform content for a name, descriptions, categories, and addresses.
+
+### Content centricity and structured data
+
+In addition to structural considerations, like chunked content, you also want to consider the substance of your content because it also informs what fields are indexed.
+
+In this tutorial, sample data consists of PDFs and content from the NASA Earth Book. This content is descriptive and informative, with numerous references to geographies, countries, and areas across the world. To capture this information in our index and potentially use it in queries, we include skills in our indexing pipeline that recognize and extract this information, loading it into a searchable and filterable `locations` field. Adding structured content to your index gives you more options for filtering, relevance tuning, and richer answers.
+
+The original ebook is large, over 100 pages and 35 MB in size. We broke it up into smaller PDFs, one per page of text, to stay under the REST API payload limit of 16 MB per API call.
+
+For simplicity, we omit image vectorization for this exercise.
+
+### Parent-child fields in one or two indexes
+
+Chunked content typically derives from a larger document. And although the schema is organized around chunks, you also want to capture properties and content at the parent level. Examples of these properties might include the parent file path, title, authors, publication date, or a summary.
+
+An inflection point in schema design is whether to have two indexes for parent and child/chunked content, or a single index that repeats parent elements for each chunk.
+
+In this tutorial, because all of the chunks of text originate from a single parent (NASA Earth Book), you don't need a separate index dedicated to up level the parent fields. However, if you're indexing from multiple parent PDFs, you might want a parent-child index pair to capture level-specific fields and then send [lookup queries](/rest/api/searchservice/documents/get) to the parent index to retrieve those fields relevant to each chunk.
+
+### Checklist of schema considerations
+
+In Azure AI Search, an index that works best for RAG workloads has these qualities:
+
+- Returns chunks that are relevant to the query and readable to the LLM. LLMs can handle a certain level of dirty data in chunks, such as mark up, redundancy, and incomplete strings. While chunks need to be readable and relevant to the question, they don't need to be pristine.
+
+- Maintains a parent-child relationship between chunks of a document and the properties of the parent document, such as the file name, file type, title, author, and so forth. To answer a query, chunks could be pulled from anywhere in the index. Association with the parent document providing the chunk is useful for context, citations, and follow up queries.
+
+- Accommodates the queries you want create. You should have fields for vector and hybrid content, and those fields should be attributed to support specific query behaviors. You can only query one index at a time (no joins) so your fields collection should define all of your searchable content.
+
+- Your schema should be flat (no complex types or structures). This requirement is specific to the RAG pattern in Azure AI Search.
+
+Although Azure AI Search can't join indexes, you can create indexes that preserve parent-child relationship, and then use sequential or parallel queries in your search logic to pull from both. This exercise includes templates for parent-child elements in the same index and in separate indexes, where information from the parent index is retrieved using a lookup query.
+
+<!-- > [!NOTE]
+> Schema design affects storage and costs. This exercise is focused on schema fundamentals. In the [Minimize storage and costs](tutorial-rag-build-solution-minimize-storage.md) tutorial, you revisit schema design to consider narrow data types, attribution, and vector configurations that offer more efficient. -->
+
+## Create an index for RAG workloads
+
+A minimal index for LLM is designed to store chunks of content. It typically includes vector fields if you want similarity search for highly relevant results. It also includes nonvector fields for human-readable inputs to the LLM for conversational search. Nonvector chunked content in the search results becomes the grounding data sent to the LLM.
+
+1. Open Visual Studio Code and create a new file. It doesn't have to be a Python file type for this exercise.
+
+1. Here's a minimal index definition for RAG solutions that support vector and hybrid search. Review it for an introduction to required elements: index name, fields, and a configuration section for vector fields.
+
+    ```json
+    {
+      "name": "example-minimal-index",
+      "fields": [
+        { "name": "id", "type": "Edm.String", "key": true },
+        { "name": "chunked_content", "type": "Edm.String", "searchable": true, "retrievable": true },
+        { "name": "chunked_content_vectorized", "type": "Edm.Single", "dimensions": 1536, "vectorSearchProfile": "my-vector-profile", "searchable": true, "retrievable": false, "stored": false },
+        { "name": "metadata", "type": "Edm.String", "retrievable": true, "searchable": true, "filterable": true }
+      ],
+      "vectorSearch": {
+          "algorithms": [
+              { "name": "my-algo-config", "kind": "hnsw", "hnswParameters": { }  }
+          ],
+          "profiles": [ 
+            { "name": "my-vector-profile", "algorithm": "my-algo-config" }
+          ]
+      }
+    }
+    ```
+
+   Fields must include key field (`"id"`) and should include vector chunks for similarity search, and nonvector chunks for inputs to the LLM. 
+
+   Vector fields have [specific types](/rest/api/searchservice/supported-data-types#edm-data-types-for-vector-fields) and extra attributes for embedding model dimensions and configuration. `Edm.Single` is a data type that works for commonly used LLMs. For more information about vector fields, see [Create a vector index](vector-search-how-to-create-index.md).
+
+   Metadata fields might be file path, creation date, or content type and are useful for [filters](vector-search-filters.md).
+
+1. Here's the index schema for the [tutorial source code](https://github.com/Azure-Samples/azure-search-python-samples/blob/main/Tutorial-RAG/Tutorial-rag.ipynb) and the [Earth Book content](https://github.com/Azure-Samples/azure-search-sample-data/tree/main/nasa-e-book/earth_book_2019_text_pages). 
+
+   Like the basic schema, it's organized around chunks. The `chunk_id` uniquely identifies each chunk. The `text_vector` field is an embedding of the chunk. The nonvector `chunk` field is a readable string. The `title` maps to a unique metadata storage path for the blobs. The `parent_id` is the only parent-level field, and it's a base64-encoded version of the parent file URI. 
+
+   The schema also includes a `locations` field for storing generated content that's created by the [indexing pipeline](tutorial-rag-build-solution-pipeline.md).
+
+   ```python
+    index_name = "py-rag-tutorial-idx"
+    index_client = SearchIndexClient(endpoint=AZURE_SEARCH_SERVICE, credential=AZURE_SEARCH_CREDENTIAL)  
+    fields = [
+        SearchField(name="parent_id", type=SearchFieldDataType.String),  
+        SearchField(name="title", type=SearchFieldDataType.String),
+        SearchField(name="locations", type=SearchFieldDataType.Collection(SearchFieldDataType.String), filterable=True),
+        SearchField(name="chunk_id", type=SearchFieldDataType.String, key=True, sortable=True, filterable=True, facetable=True, analyzer_name="keyword"),  
+        SearchField(name="chunk", type=SearchFieldDataType.String, sortable=False, filterable=False, facetable=False),  
+        SearchField(name="text_vector", type=SearchFieldDataType.Collection(SearchFieldDataType.Single), vector_search_dimensions=1536, vector_search_profile_name="myHnswProfile")
+        ]  
+      
+    # Configure the vector search configuration  
+    vector_search = VectorSearch(  
+        algorithms=[  
+            HnswAlgorithmConfiguration(name="myHnsw"),
+        ],  
+        profiles=[  
+            VectorSearchProfile(  
+                name="myHnswProfile",  
+                algorithm_configuration_name="myHnsw",  
+                vectorizer="myOpenAI",  
+            )
+        ],  
+        vectorizers=[  
+            AzureOpenAIVectorizer(  
+                name="myOpenAI",  
+                kind="azureOpenAI",  
+                azure_open_ai_parameters=AzureOpenAIParameters(  
+                    resource_uri=AZURE_OPENAI_ACCOUNT,  
+                    deployment_id="text-embedding-ada-002",
+                    model_name="text-embedding-ada-002"
+                ),
+            ),  
+        ],  
+    )  
+      
+    # Create the search index
+    index = SearchIndex(name=index_name, fields=fields, vector_search=vector_search)  
+    result = index_client.create_or_update_index(index)  
+    print(f"{result.name} created")  
+    ```
+
+1. For an index schema that more closely mimics structured content, you would have separate indexes for parent and child (chunked) fields. You would need index projections to coordinate the indexing of the two indexes simultaneously. Queries execute against the child index. Query logic includes a lookup query, using the parent_idto retrieve content from the parent index.
+
+   Fields in the child index:
+
+   - ID
+   - chunk
+   - chunkVectcor
+   - parent_id
+
+   Fields in the parent index (everything that you want "one of"):
+
+   - parent_id
+   - parent-level fields (name, title, category)
+
+<!-- Objective:
+
+- Design an index schema that generates results in a format that works for LLMs.
+
+Key points:
+
+- schema for rag is designed for producing chunks of content
+- schema should be flat (no complex types or structures)
+- schema determines what queries you can create (be generous in attribute assignments)
+- schema must cover all the queries you want to run. You can only query one index at a time (no joins), but you can create indexes that preserve parent-child relationship, and then use nested queries or parallel queries in your search logic to pull from both.
+- schema has impact on storage/size. Consider narrow data types, attribution, vector configuration.
+- show schema patterns: one for parent-child all-up, one for paired indexes via index projections
+- note metadata for filters
+- TBD: add fields for location and use entity recognition to pull this values out of the PDFs? Not sure how the extraction will work on chunked documents or how it will query, but goal would be to show that you can add structured data to the schema.
+
+Tasks:
+
+- H2 How to create an index for chunked and vectorized data (show examples for parent-child variants)
+- H2 How to define vector profiles and configuration (discuss pros and cons, shouldn't be a rehash of existing how-to)
+- H2 How to add filters
+- H2 How to add structured data (example is "location", top-level field, data aquisition is through the pipeline) -->
+
+## Next step
+
+> [!div class="nextstepaction"]
+> [Create an indexing pipeline](tutorial-rag-build-solution-pipeline.md)
\ No newline at end of file
````
</details>

### Summary

```json
{
    "modification_type": "new feature",
    "modification_title": "RAGチュートリアル: インデックス設計ガイドの追加"
}
```

### Explanation
この変更は、新たに「tutorial-rag-build-solution-index-schema.md」ファイルが追加されたことを示しています。このチュートリアルは、Azure AI Search における RAG（Retrieval-Augmented Generation）パターン用のインデックスを設計する方法を扱っています。以下は、主な内容の概要です。

1. **チュートリアルの目的**: RAGパターンで使用するためのインデックス設計に関する知識を提供し、関連する設計や要件、実装方法を説明します。

2. **アウトライン**:
   - インデックスの特徴や RAG に必要な要素について学ぶことができます。
   - ベクターやハイブリッドクエリに対応したインデックスの作成。
   - さまざまなデータの追加やフィルタリングの方法について触れています。

3. **前提条件**: 記載されているソフトウェア（Visual Studio Code、Python拡張機能、Jupyterパッケージ）や、実行に必要な情報が原則的に説明されています。

4. **スキーマ設計**: RAG 用のインデックスは、コンテンツのチャンクを中心に設計され、ユーザーの質問に対して関連性の高い回答を導くための要素や、親子関係に基づく設計の考慮点が提示されています。

5. **インデックス作成の実行方法**: チュートリアル内で提供されるサンプルの JSON スキーマを基に、RAG 用のインデックスを作成するための手順が明示されています。

6. **次のステップ**: このチュートリアルの後に進むべき次のアクションとして、インデクシングパイプラインの作成に関するリンクが設けられています。

この新しいチュートリアルは、RAG でのインデックス設計に関する具体的で実践的な手引きを提供するものであり、Azure AI Search を利用する開発者にとって貴重なリソースとなることが期待されます。記事全体は以下のリンクから確認できます。
- [記事へのリンク](https://github.com/MicrosoftDocs/azure-ai-docs/blob/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Ftutorial-rag-build-solution-index-schema.md)  
- [生のMarkdownファイルへのリンク](https://github.com/MicrosoftDocs/azure-ai-docs/raw/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Ftutorial-rag-build-solution-index-schema.md)  

この新しい機能により、ユーザーは効果的なインデックス設計に集中し、RAG ソリューションの実装をサポートするための知識とツールを得ることができます。

## articles/search/tutorial-rag-build-solution-models.md{#item-6796c9}

<details>
<summary>Diff</summary>
````diff
@@ -0,0 +1,181 @@
+---
+title: 'RAG tutorial: Set up models'
+titleSuffix: Azure AI Search
+description: Set up an embedding model and chat model for generative search (RAG).
+
+manager: nitinme
+author: HeidiSteen
+ms.author: heidist
+ms.service: cognitive-search
+ms.topic: tutorial
+ms.custom: references_regions
+ms.date: 09/12/2024
+
+---
+
+# Tutorial: Choose embedding and chat models for RAG in Azure AI Search
+
+A RAG solution built on Azure AI Search takes a dependency on embedding models for vectorization, and on chat models for conversational search over your data.
+
+In this tutorial, you:
+
+> [!div class="checklist"]
+> - Learn which models in the Azure cloud work with built-in integration
+> - Learn about the Azure models used for chat
+> - Deploy models and collect model information for your code
+> - Configure search engine access to Azure models
+> - Learn about custom skills and vectorizers for attaching non-Azure models
+
+If you don't have an Azure subscription, create a [free account](https://azure.microsoft.com/free/?WT.mc_id=A261C142F) before you begin.
+
+## Prerequisites
+
+- The Azure portal, used to deploy models and configure role assignments in the Azure cloud.
+
+- An **Owner** role on your Azure subscription, necessary for creating role assignments. Your model provider has more role requirements for deploying and accessing models. Those are noted in the following steps.
+
+- A model provider, such as [Azure OpenAI](/azure/ai-services/openai/how-to/create-resource), Azure AI Vision via an [Azure AI multi-service account](/azure/ai-services/multi-service-resource), or [Azure AI Studio](https://ai.azure.com/).
+
+  We use Azure OpenAI in this tutorial. Other providers are listed so that you know your options for integrated vectorization.
+
+- Azure AI Search, Basic tier or higher provides a [managed identity](search-howto-managed-identities-data-sources.md) used in role assignments. 
+
+- A shared region. To complete all of the tutorials in this series, the region must support both Azure AI Search and the model provider. See supported regions for:
+
+  - [Azure OpenAI regions](/azure/ai-services/openai/concepts/models#model-summary-table-and-region-availability)
+
+  - [Azure AI Vision regions](/azure/ai-services/computer-vision/overview-image-analysis?tabs=4-0#region-availability)
+
+  - [Azure AI Studio](/azure/ai-studio/reference/region-support) regions. 
+
+  Azure AI Search is currently facing limited availability in some regions, such as West Europe and West US 2/3. Check the [Azure AI Search region list](search-region-support.md) to confirm region status.
+
+> [!TIP]
+> Currently, the following regions provide the most overlap among the model providers and have the most capacity: **East US**, **East US2**, and **South Central** in the Americas; **France Central** or **Switzerland North** in Europe; **Australia East** in Asia Pacific.
+>
+> For Azure AI Vision and AI Search interoperability, choose one of these regions: **East US**, **France Central**, **Korea Central**, **North Europe**, **South East Asia**, or **West US**. 
+
+## Review models supporting built-in vectorization
+
+Vectorized content improves the query results in a RAG solution. Azure AI Search supports an embedding action in an indexing pipeline. It also supports an embedding action at query time, converting text or image inputs into vectors for a vector search. In this step, identify an embedding model that works for your content and queries. If you're providing raw vector data and raw vector queries, or if your RAG solution doesn't include vector data, skip this step.
+
+Vector queries that include a text-to-vector conversion step must use the same embedding model that was used during indexing. The search engine won't throw an error if you use different models, but you'll get poor results.
+
+To meet the same-model requirement, choose embedding models that can be referenced through *skills* during indexing and through *vectorizers* during query execution. Review [Create an indexing pipeline](tutorial-rag-build-solution-pipeline.md) for code that calls an embedding skill and a matching vectorizer. 
+
+Azure AI Search provides skill and vectorizer support for the following embedding models in the Azure cloud.
+
+| Client | Embedding models | Skill | Vectorizer |
+|--------|------------------|-------|------------|
+| Azure OpenAI | text-embedding-ada-002, text-embedding-3-large, text-embedding-3-small | [AzureOpenAIEmbedding](cognitive-search-skill-azure-openai-embedding.md) | [AzureOpenAIEmbedding](vector-search-vectorizer-azure-open-ai.md) |
+| Azure AI Vision | multimodal 4.0 <sup>1</sup> | [AzureAIVision](cognitive-search-skill-vision-vectorize.md) | [AzureAIVision](vector-search-vectorizer-ai-services-vision.md) |
+| Azure AI Studio model catalog | OpenAI-CLIP-Image-Text-Embeddings-vit-base-patch32, OpenAI-CLIP-Image-Text-Embeddings-ViT-Large-Patch14-336, Facebook-DinoV2-Image-Embeddings-ViT-Base, Facebook-DinoV2-Image-Embeddings-ViT-Giant, Cohere-embed-v3-english, Cohere-embed-v3-multilingual | [AML](cognitive-search-aml-skill.md) <sup>2</sup>  | [Azure AI Studio model catalog](vector-search-vectorizer-azure-machine-learning-ai-studio-catalog.md) |
+
+<sup>1</sup> Supports image and text vectorization.
+
+<sup>2</sup> Deployed models in the model catalog are accessed over an AML endpoint. We use the existing AML skill for this connection.
+
+You can use other models besides those listed here. For more information, see [Use non-Azure models for embeddings](#use-non-azure-models-for-embeddings) in this article.
+
+> [!NOTE]
+> Inputs to an embedding models are typically chunked data. In an Azure AI Search RAG pattern, chunking is handled in the indexer pipeline, covered in [another tutorial](tutorial-rag-build-solution-pipeline.md) in this series.
+
+## Review models used for generative AI at query time
+
+Azure AI Search doesn't have integration code for chat models, so you should choose an LLM that you're familiar with and that meets your requirements. You can modify query code to try different models without having to rebuild an index or rerun any part of the indexing pipeline. Review [Search and generate answers](tutorial-rag-build-solution-query.md) for code that calls the chat model.
+
+The following models are commonly used for a chat search experience:
+
+| Client | Chat models |
+|--------|------------|
+| Azure OpenAI | GPT-35-Turbo, GPT-4, GPT-4o, GPT-4 Turbo |
+
+GPT-35-Turbo and GPT-4 models are optimized to work with inputs formatted as a conversation. 
+
+## Deploy models and collect information
+
+Models must be deployed and accessible through an endpoint. Both embedding-related skills and vectorizers need the number of dimensions and the model name. Other details about your model might be required by the client used on the connection.
+
+This tutorial series uses the following models and model providers:
+
+- Text-embedding-ada-02 on Azure OpenAI for embeddings
+- GPT-35-Turbo on Azure OpenAI for chat completion
+
+You must have [**Cognitive Services OpenAI Contributor**]( /azure/ai-services/openai/how-to/role-based-access-control#cognitive-services-openai-contributor) or higher to deploy models in Azure OpenAI.
+
+1. Go to [Azure OpenAI Studio](https://oai.azure.com/).
+
+1. Select **Deployments** on the left menu.
+
+1. Select **Deploy model** > **Deploy base model**.
+
+1. Select **text-embedding-ada-02** from the dropdown list and confirm the selection.
+
+1. Specify a deployment name. We recommend "text-embedding-ada-002".
+
+1. Accept the defaults.
+
+1. Select **Deploy**.
+
+1. Repeat the previous steps for **gpt-35-turbo**.
+
+1. Make a note of the model names and endpoint. Embedding skills and vectorizers assemble the full endpoint internally, so you only need the resource URI. For example, given `https://MY-FAKE-ACCOUNT.openai.azure.com/openai/deployments/text-embedding-ada-002/embeddings?api-version=2023-05-15`, the endpoint you should provide in skill and vectorizer definitions is `https://MY-FAKE-ACCOUNT.openai.azure.com`.
+
+## Configure search engine access to Azure models
+
+For pipeline and query execution, this tutorial uses Microsoft Entra ID for authentication and roles for authorization. 
+
+Assign yourself and the search service identity permissions on Azure OpenAI. The code for this tutorial runs locally. Requests to Azure OpenAI originate from your system. Also, search results from the search engine are passed to Azure OpenAI. For these reasons, both you and the search service need permissions on Azure OpenAI.
+
+1. Sign in to the [Azure portal](https://portal.azure.com) and [find your search service](https://portal.azure.com/#blade/HubsExtension/BrowseResourceBlade/resourceType/Microsoft.Search%2FsearchServices).
+
+1. Configure Azure AI Search to [use a system-managed identity](search-howto-managed-identities-data-sources.md).
+
+1. Find your Azure OpenAI resource.
+
+1. Select **Access control (IAM)** on the left menu. 
+
+1. Select **Add role assignment**.
+
+1. Select [**Cognitive Services OpenAI User**](/azure/ai-services/openai/how-to/role-based-access-control#cognitive-services-openai-userpermissions).
+1. Select **Managed identity** and then select **Members**. Find the system-managed identity for your search service in the dropdown list.
+
+1. Next, select **User, group, or service principal** and then select **Members**. Search for your user account and then select it from the dropdown list.
+
+1. Select **Review and Assign** to create the role assignments.
+
+For access to models on Azure AI Vision, assign **Cognitive Services OpenAI User**. For Azure AI Studio, assign **Azure AI Developer**.
+
+## Use non-Azure models for embeddings
+
+The pattern for integrating any embedding model is to wrap it in a custom skill and custom vectorizer. This section provides links to reference articles. For a code example that calls a non-Azure model, see [custom-embeddings demo](https://github.com/Azure/azure-search-vector-samples/blob/main/demo-python/code/custom-vectorizer/readme.md).
+
+| Client | Embedding models | Skill | Vectorizer |
+|--------|------------------|-------|------------|
+| Any | Any | [custom skill](cognitive-search-custom-skill-web-api.md) | [custom vectorizer](vector-search-vectorizer-custom-web-api.md) |
+
+<!-- In this tutorial,  Learn how to set up connections so that Azure AI Search can connect securely during indexing, and at query time for generative AI responses and text-to-vector conversions of query strings.
+
+Objective:
+
+- Identify an embedding model and chat model for your RAG workflow.
+
+Key points:
+
+- Built-in integration for models hosted in the Azure cloud.
+- For chunking, use the native Text Split skill with overlapping text -- or -- for semantic chunking, use Document Intelligence.
+- For embedding during indexing, use a skill that points to Azure OpenAI, Azure AI Vision, or the model catalog. Alternatively, use custom skill with HTTP endpoint to external model.
+- For queries, same embedding models as above, but you're wrapping it in a "vectorizer" instead of a "skill".
+- Use the same embedding model for indexing and text-to-vector queries. If you want to try a different model, it's a rebuild. An indexer pipeline like the one used in this tutorial makes this step easy.
+- For chat, same location requirements and providers, except no Azure AI Vision. You specify a chat model in your query logic. Unlike embedding, you can swap these around at query time to see what they do.
+
+Tasks:
+
+- H2: Identify the models for which we have skills/vectorizers and provide locations (model catalog, Azure OpenAI, etc). Crosslink to model deployment instructions. Include steps for getting endpoints, model version, deployment name, REST API version.
+- H2: How to use other models (create a custom skill, create a custom vectorizer).
+- H2: How to configure access. Set up an Azure AI Search managed identity, give it permissions on Azure-hosted models. -->
+
+## Next step
+
+> [!div class="nextstepaction"]
+> [Design an index](tutorial-rag-build-solution-index-schema.md)
\ No newline at end of file
````
</details>

### Summary

```json
{
    "modification_type": "new feature",
    "modification_title": "RAGチュートリアル: モデルの設定ガイドの追加"
}
```

### Explanation
この変更は、新たに「tutorial-rag-build-solution-models.md」ファイルが追加されたことを示しています。このチュートリアルは、Azure AI Search における RAG（Retrieval-Augmented Generation）ソリューションに使用するための埋め込みモデルとチャットモデルの設定方法を説明しています。以下は、主な内容の概要です。

1. **チュートリアルの概要**: RAGソリューションでは、データ上での対話型検索を可能にするために、埋め込みモデルとチャットモデルが必要であることが強調されています。

2. **内容の要点**:
   - Azureクラウドで組み込み統合がサポートされているモデルの確認。
   - チャット用のAzureモデルについて学ぶ。
   - モデルのデプロイとコード用のモデル情報の収集。
   - Azureモデルに対する検索エンジンのアクセス設定。
   - 非Azureモデルを付加するためのカスタムスキルおよびベクタイザーについての説明。

3. **前提条件**: Azureポータルを使用してモデルをデプロイし、ロールの割り当てを設定するための詳細な要件が示されています。Azure OpenAIやAzure AI Visionなど、モデルプロバイダーの選択肢も記載されています。

4. **埋め込みモデルの確認**: Azure AI Searchは、インデックス作成パイプラインやクエリ実行時に埋め込みモデルを使用することでベクトル化されたコンテンツを処理する能力について言及しています。

5. **チャットモデルの選択**: Azure AI Searchは、チャットモデルの統合コードを提供していないため、ユーザーは馴染みのあるモデルを選択し、それに基づいてクエリを調整できることが説明されています。

6. **モデルのデプロイとアクセスの設定**: モデルをデプロイし、エンドポイントを通じてアクセスする手順が詳細に解説されています。

新たに追加されたこのチュートリアルは、Azure AI SearchにおけるRAGソリューションの実装において特に重要なモデルの設定に関する具体的なガイドを提供し、ユーザーが効果的に活用するためのリソースとなることが期待されます。記事全体は以下のリンクから確認できます。
- [記事へのリンク](https://github.com/MicrosoftDocs/azure-ai-docs/blob/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Ftutorial-rag-build-solution-models.md)  
- [生のMarkdownファイルへのリンク](https://github.com/MicrosoftDocs/azure-ai-docs/raw/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Ftutorial-rag-build-solution-models.md)  

この機能追加により、RAGワークフローに最適なモデルの選択と設定が促進され、より良い検索体験が提供されることが期待されます。

## articles/search/tutorial-rag-build-solution-pipeline.md{#item-25ce01}

<details>
<summary>Diff</summary>
````diff
@@ -0,0 +1,373 @@
+---
+title: 'RAG Tutorial: Build an indexing pipeline'
+titleSuffix: Azure AI Search
+description: Create an indexer-driven pipeline that loads, chunks, embeds, and ingests content for RAG solutions on Azure AI Search.
+
+manager: nitinme
+author: HeidiSteen
+ms.author: heidist
+ms.service: cognitive-search
+ms.topic: tutorial
+ms.date: 09/12/2024
+
+---
+
+# Tutorial: Build an indexing pipeline for RAG on Azure AI Search
+
+Learn how to build an automated indexing pipeline for a RAG solution on Azure AI Search. Indexing automation is through an indexer that drives indexing and skillset execution, providing [integrated data chunking and vectorization](vector-search-integrated-vectorization.md) on a one-time or recurring basis for incremental updates.
+
+In this tutorial, you:
+
+> [!div class="checklist"]
+> - Provide the index schema from the previous tutorial 
+> - Create a data source connection
+> - Create an indexer
+> - Create a skillset
+> - Run the indexer and check results
+
+If you don't have an Azure subscription, create a [free account](https://azure.microsoft.com/free/?WT.mc_id=A261C142F) before you begin.
+
+> [!TIP]
+> You can use the [Import and vectorize data wizard](search-import-data-portal.md) to create your pipeline. For some quickstarts, see [Image search](search-get-started-portal-image-search.md) and [Vector search](search-get-started-portal-import-vectors.md).
+
+## Prerequisites
+
+- [Visual Studio Code](https://code.visualstudio.com/download) with the [Python extension](https://marketplace.visualstudio.com/items?itemName=ms-python.python) and the [Jupyter package](https://pypi.org/project/jupyter/). For more information, see [Python in Visual Studio Code](https://code.visualstudio.com/docs/languages/python).
+
+- [Azure Storage](/azure/storage/common/storage-account-create) general purpose account. This exercise uploads PDF files into blob storage for automated indexing.
+
+- [Azure AI Search](search-create-service-portal.md), Basic tier or above for managed identity and semantic ranking. Choose a region that's shared with Azure OpenAI and Azure AI Services.
+
+- [Azure OpenAI](/azure/ai-services/openai/how-to/create-resource), with a deployment of text-embedding-002, in the same region as Azure AI Search. For more information about embedding models used in RAG solutions, see [Choose embedding models for RAG in Azure AI Search](tutorial-rag-build-solution-models.md).
+
+- [Azure AI Services multiservice account](/azure/ai-services/multi-service-resource), in the same region as Azure AI Search. This resource is used for the Entity Recognition skill that detects locations in your content.
+
+## Download the sample
+
+[Download a Jupyter notebook](https://github.com/Azure-Samples/azure-search-python-samples/blob/main/Tutorial-RAG/Tutorial-rag.ipynb) from GitHub to send the requests to Azure AI Search. For more information, see [Downloading files from GitHub](https://docs.github.com/get-started/start-your-journey/downloading-files-from-github).
+
+## Provide the index schema
+
+Open or create a Jupyter notebook (`.ipynb`) in Visual Studio Code to contain the scripts that comprise the pipeline. Initial steps install packages and collect variables for the connections. After you complete the setup steps, you're ready to begin with the components of the indexing pipeline. 
+
+Let's start with the index schema from the [previous tutorial](tutorial-rag-build-solution-index-schema.md). It's organized around vectorized and nonvectorized chunks. It includes a `locations` field that stores AI-generated content created by the skillset.  
+
+```python
+index_name = "py-rag-tutorial-idx"
+index_client = SearchIndexClient(endpoint=AZURE_SEARCH_SERVICE, credential=AZURE_SEARCH_CREDENTIAL)  
+fields = [
+    SearchField(name="parent_id", type=SearchFieldDataType.String),  
+    SearchField(name="title", type=SearchFieldDataType.String),
+    SearchField(name="locations", type=SearchFieldDataType.Collection(SearchFieldDataType.String), filterable=True),
+    SearchField(name="chunk_id", type=SearchFieldDataType.String, key=True, sortable=True, filterable=True, facetable=True, analyzer_name="keyword"),  
+    SearchField(name="chunk", type=SearchFieldDataType.String, sortable=False, filterable=False, facetable=False),  
+    SearchField(name="text_vector", type=SearchFieldDataType.Collection(SearchFieldDataType.Single), vector_search_dimensions=1536, vector_search_profile_name="myHnswProfile")
+    ]  
+    
+# Configure the vector search configuration  
+vector_search = VectorSearch(  
+    algorithms=[  
+        HnswAlgorithmConfiguration(name="myHnsw"),
+    ],  
+    profiles=[  
+        VectorSearchProfile(  
+            name="myHnswProfile",  
+            algorithm_configuration_name="myHnsw",  
+            vectorizer="myOpenAI",  
+        )
+    ],  
+    vectorizers=[  
+        AzureOpenAIVectorizer(  
+            name="myOpenAI",  
+            kind="azureOpenAI",  
+            azure_open_ai_parameters=AzureOpenAIParameters(  
+                resource_uri=AZURE_OPENAI_ACCOUNT,  
+                deployment_id="text-embedding-ada-002",
+                model_name="text-embedding-ada-002"
+            ),
+        ),  
+    ],  
+)  
+    
+# Create the search index on Azure AI Search
+index = SearchIndex(name=index_name, fields=fields, vector_search=vector_search)  
+result = index_client.create_or_update_index(index)  
+print(f"{result.name} created")  
+```
+
+## Create a data source connection
+
+In this step, set up the sample data and a connection to Azure Blob Storage. The indexer retrieves PDFs from a container. You create the container and upload files in this step.
+
+1. Sign in to the Azure portal and find your Azure Storage account.
+
+1. Create a container and upload the PDFs from [earth_book_2019_text_pages](https://github.com/Azure-Samples/azure-search-sample-data/tree/main/nasa-e-book/earth_book_2019_text_pages).
+
+1. Make sure Azure AI Search has **Storage Blob Data Reader** permissions on the resource.
+
+1. Next, in Visual Studio Code, define an indexer data source that provides connection information during indexing.
+
+    ```python
+    from azure.search.documents.indexes import SearchIndexerClient
+    from azure.search.documents.indexes.models import (
+        SearchIndexerDataContainer,
+        SearchIndexerDataSourceConnection
+    )
+    
+    # Create a data source 
+    indexer_client = SearchIndexerClient(endpoint=AZURE_SEARCH_SERVICE, credential=AZURE_SEARCH_CREDENTIAL)
+    container = SearchIndexerDataContainer(name="nasa-ebook-pdfs-all")
+    data_source_connection = SearchIndexerDataSourceConnection(
+        name="py-rag-tutorial-ds",
+        type="azureblob",
+        connection_string=AZURE_STORAGE_CONNECTION,
+        container=container
+    )
+    data_source = indexer_client.create_or_update_data_source_connection(data_source_connection)
+    
+    print(f"Data source '{data_source.name}' created or updated")
+    ```
+
+## Create a skillset
+
+Skills are the basis for integrated data chunking and vectorization. At a minimum, you want a Text Split skill to chunk your content, and an embedding skill that create vector representations of your chunked content.
+
+In this skillset, an extra skill is used to create structured data in the index. The Entity Recognition skill is used to identify locations, which can range from proper names to generic references, such as "ocean" or "mountain". Having structured data gives you more options for creating interesting queries and boosting relevance.
+
+```python
+from azure.search.documents.indexes.models import (
+    SplitSkill,
+    InputFieldMappingEntry,
+    OutputFieldMappingEntry,
+    AzureOpenAIEmbeddingSkill,
+    EntityRecognitionSkill,
+    SearchIndexerIndexProjections,
+    SearchIndexerIndexProjectionSelector,
+    SearchIndexerIndexProjectionsParameters,
+    IndexProjectionMode,
+    SearchIndexerSkillset,
+    CognitiveServicesAccountKey
+)
+
+# Create a skillset  
+skillset_name = "py-rag-tutorial-ss"
+
+split_skill = SplitSkill(  
+    description="Split skill to chunk documents",  
+    text_split_mode="pages",  
+    context="/document",  
+    maximum_page_length=2000,  
+    page_overlap_length=500,  
+    inputs=[  
+        InputFieldMappingEntry(name="text", source="/document/content"),  
+    ],  
+    outputs=[  
+        OutputFieldMappingEntry(name="textItems", target_name="pages")  
+    ],  
+)  
+  
+embedding_skill = AzureOpenAIEmbeddingSkill(  
+    description="Skill to generate embeddings via Azure OpenAI",  
+    context="/document/pages/*",  
+    resource_uri=AZURE_OPENAI_ACCOUNT,  
+    deployment_id="text-embedding-ada-002",  
+    model_name="text-embedding-ada-002",
+    dimensions=1536,
+    inputs=[  
+        InputFieldMappingEntry(name="text", source="/document/pages/*"),  
+    ],  
+    outputs=[  
+        OutputFieldMappingEntry(name="embedding", target_name="text_vector")  
+    ],  
+)
+
+entity_skill = EntityRecognitionSkill(
+    description="Skill to recognize entities in text",
+    context="/document/pages/*",
+    categories=["Location"],
+    default_language_code="en",
+    inputs=[
+        InputFieldMappingEntry(name="text", source="/document/pages/*")
+    ],
+    outputs=[
+        OutputFieldMappingEntry(name="locations", target_name="locations")
+    ]
+)
+  
+index_projections = SearchIndexerIndexProjections(  
+    selectors=[  
+        SearchIndexerIndexProjectionSelector(  
+            target_index_name=index_name,  
+            parent_key_field_name="parent_id",  
+            source_context="/document/pages/*",  
+            mappings=[  
+                InputFieldMappingEntry(name="chunk", source="/document/pages/*"),  
+                InputFieldMappingEntry(name="text_vector", source="/document/pages/*/text_vector"),
+                InputFieldMappingEntry(name="locations", source="/document/pages/*/locations"),
+                InputFieldMappingEntry(name="title", source="/document/metadata_storage_name"),  
+            ],  
+        ),  
+    ],  
+    parameters=SearchIndexerIndexProjectionsParameters(  
+        projection_mode=IndexProjectionMode.SKIP_INDEXING_PARENT_DOCUMENTS  
+    ),  
+) 
+
+cognitive_services_account = CognitiveServicesAccountKey(key=AZURE_AI_MULTISERVICE_KEY)
+
+skills = [split_skill, embedding_skill, entity_skill]
+
+skillset = SearchIndexerSkillset(  
+    name=skillset_name,  
+    description="Skillset to chunk documents and generating embeddings",  
+    skills=skills,  
+    index_projections=index_projections,
+    cognitive_services_account=cognitive_services_account
+)
+  
+client = SearchIndexerClient(endpoint=AZURE_SEARCH_SERVICE, credential=AZURE_SEARCH_CREDENTIAL)  
+client.create_or_update_skillset(skillset)  
+print(f"{skillset.name} created")  
+```
+
+## Create and run the indexer
+
+Indexers are the component that sets all of the processes in motion. You can create an indexer in a disabled state, but the default is to run it immediately. In this tutorial, create and run the indexer to retrieve the data from Blob storage, execute the skills, including chunking and vectorization, and load the index.
+
+The indexer takes several minutes to run. When it's done, you can move on to the final step: querying your index.
+
+```python
+from azure.search.documents.indexes.models import (
+    SearchIndexer,
+    FieldMapping
+)
+
+# Create an indexer  
+indexer_name = "py-rag-tutorial-idxr" 
+
+indexer_parameters = None
+
+indexer = SearchIndexer(  
+    name=indexer_name,  
+    description="Indexer to index documents and generate embeddings",  
+    skillset_name=skillset_name,  
+    target_index_name=index_name,  
+    data_source_name=data_source.name,
+    # Map the metadata_storage_name field to the title field in the index to display the PDF title in the search results  
+    field_mappings=[FieldMapping(source_field_name="metadata_storage_name", target_field_name="title")],
+    parameters=indexer_parameters
+)  
+
+# Create and run the indexer  
+indexer_client = SearchIndexerClient(endpoint=AZURE_SEARCH_SERVICE, credential=AZURE_SEARCH_CREDENTIAL)  
+indexer_result = indexer_client.create_or_update_indexer(indexer)  
+
+print(f' {indexer_name} is created and running. Give the indexer a few minutes before running a query.')  
+```
+
+## Run a query to check results
+
+Send a query to confirm your index is operational. This request converts the text string "`where are the nasa headquarters located?`" into a vector for a vector search. Results consist of the fields in the select statement, some of which are printed as output.
+
+```python
+from azure.search.documents import SearchClient
+from azure.search.documents.models import VectorizableTextQuery
+
+# Hybrid Search
+query = "where are the nasa headquarters located?"  
+
+search_client = SearchClient(endpoint=AZURE_SEARCH_SERVICE, credential=AZURE_SEARCH_CREDENTIAL, index_name=index_name)
+vector_query = VectorizableTextQuery(text=query, k_nearest_neighbors=1, fields="text_vector", exhaustive=True)
+  
+results = search_client.search(  
+    search_text=query,  
+    vector_queries= [vector_query],
+    select=["parent_id", "chunk_id", "title", "chunk", "locations"],
+    top=1
+)  
+  
+for result in results:  
+    print(f"Score: {result['@search.score']}")
+    print(f"Title: {result['title']}")
+    print(f"Locations: {result['locations']}")
+    print(f"Content: {result['chunk']}") 
+```
+
+This query returns a single match (`top=1`) consisting of the one chunk determined by the search engine to be the most relevant. Results from the query should look similar to the following example:
+
+```
+Score: 0.03306011110544205
+Title: page-178.pdf
+Locations: ['Headquarters', 'Washington']
+Content: national Aeronautics and Space Administration
+
+earth Science
+
+NASA Headquarters 
+
+300 E Street SW 
+
+Washington, DC 20546
+
+www.nasa.gov
+
+np-2018-05-2546-hQ
+```
+
+Try a few more queries to get a sense of what the search engine returns directly so that you can compare it with an LLM-enabled response. Rerun the previous script with this query: `"how much of the earth is covered in water"`?
+
+Results from this second query should look similar to the following results, which are lightly edited for concision. 
+
+```
+Score: 0.03333333507180214
+Content:
+
+Land of Lakes
+Canada
+
+During the last Ice Age, nearly all of Canada was covered by a massive ice sheet. Thousands of years later, the landscape still shows 
+
+the scars of that icy earth-mover. Surfaces that were scoured by retreating ice and flooded by Arctic seas are now dotted with 
+
+millions of lakes, ponds, and streams. In this false-color view from the Terra satellite, water is various shades of blue, green, tan, and 
+
+black, depending on the amount of suspended sediment and phytoplankton; vegetation is red.
+
+The region of Nunavut Territory is sometimes referred to as the “Barren Grounds,” as it is nearly treeless and largely unsuitable for 
+
+agriculture. The ground is snow-covered for much of the year, and the soil typically remains frozen (permafrost) even during the 
+
+summer thaw. Nonetheless, this July 2001 image shows plenty of surface vegetation in midsummer, including lichens, mosses, 
+
+shrubs, and grasses. The abundant fresh water also means the area is teeming with flies and mosquitoes.
+```
+
+With this example, it's easier to spot how chunks are returned verbatim, and how keyword and similarity search identify top matches. This specific chunk definitely has information about water and coverage over the earth, but it's not exactly relevant to the query. Semantic ranking would find a better answer, but as a next step, let's see how to connect Azure AI Search to an LLM for conversational search.
+
+<!-- Objective:
+
+- Create objects and run the indexer to produce an operational search index with chunked and vectorized content.
+
+Key points:
+
+- Dependency on a supported data source. Use Azure blob storage for this tutorial.
+- Indexer pulls from the data source, pushes to the index.
+- Large PDF files can't be chunked. Indexer shows success, but doesn't even attempt to chunk/ingest the docs. Individual files have to be less than 16 MB.
+- Skillset (example 1) has two skills: text split and embedding. Embedding model is also be used for vectorization at query time (assume text-to-vector conversion).
+- Skillset (example 2) add a custom skill that points to external embedding model, or document intelligence.
+- Skillset (example 3) add an entity recognition skill to lift locations from raw content into the index?
+- Duplicated content is expected due to overlap and repetition of parent info. It won't affect your LLM.
+
+Tasks:
+
+- H2: Configure access to Azure Storage and upload sample data.
+- H2: Create a data source
+- H2: Create a skillset (choose one skillset)
+- H2: Use alternative skillsets (present the other two skillsets)
+- H2: Create and run the indexer
+- H2: Check your data in the search index (hide vectors) -->
+
+## Next step
+
+> [!div class="nextstepaction"]
+> [Chat with your data](tutorial-rag-build-solution-query.md)
\ No newline at end of file
````
</details>

### Summary

```json
{
    "modification_type": "new feature",
    "modification_title": "RAGチュートリアル: インデクシングパイプラインの構築"
}
```

### Explanation
この変更は、新たに「tutorial-rag-build-solution-pipeline.md」ファイルが追加されたことを示しています。このチュートリアルは、Azure AI Search における RAG（Retrieval-Augmented Generation）ソリューションのためのインデクシングパイプラインを構築する方法を説明しています。以下は、主な内容の概要です。

1. **チュートリアルの主旨**: 自動化されたインデクシングパイプラインを作成し、データの読み込み、チャンク処理、ベクター化を行う方法が示されています。このパイプラインは、インデクサーを使用してデータの定期的な更新を行い、効果的な検索機能を提供します。

2. **重要な手順**:
   - 以前のチュートリアルで作成したインデックススキーマを提供する。
   - データソース接続の作成。
   - インデクサーの作成。
   - スキルセットの作成。
   - インデクサーを実行し、結果を確認する。

3. **前提条件**: 必要なソフトウェア（Visual Studio Code、Azure Storage、Azure AI Search など）や、使用するリソース（モデルプロバイダーなど）についても触れています。

4. **サンプルデータの扱い**: Azure Blob ストレージに PDF ファイルをアップロードし、それをインデクサーで読み込む方法が説明されています。

5. **スキルセットの利用**: データのチャンク処理とベクター化を行うためのスキルセットの設計と構築が示されています。具体的には、テキスト分割スキルと埋め込みスキル、エンティティ認識スキルが含まれています。

6. **インデクサーの実行とクエリの確認**: インデクサーを実行してデータをインデックスに取り込み、その後のクエリによってインデックスの動作を確認する方法が説明されています。

このチュートリアルは、RAG ソリューションを構築する際の重要なステップを詳細に解説しており、ユーザーが Azure AI Search を最大限に活用するための実践的な手引きとなることが期待されます。記事全体は以下のリンクから確認できます。
- [記事へのリンク](https://github.com/MicrosoftDocs/azure-ai-docs/blob/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Ftutorial-rag-build-solution-pipeline.md)  
- [生のMarkdownファイルへのリンク](https://github.com/MicrosoftDocs/azure-ai-docs/raw/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Ftutorial-rag-build-solution-pipeline.md)  

この新機能により、ユーザーはインデクシングプロセスを自動化し、RAG ソリューションの構築に必要な要素を効果的に統合することができます。

## articles/search/tutorial-rag-build-solution-query.md{#item-93965f}

<details>
<summary>Diff</summary>
````diff
@@ -0,0 +1,234 @@
+---
+title: 'RAG Tutorial: Search using an LLM'
+titleSuffix: Azure AI Search
+description: Learn how to build queries and engineer prompts for LLM-enabled search on Azure AI Search. Queries used in generative search provide the inputs to an LLM chat engine.
+
+manager: nitinme
+author: HeidiSteen
+ms.author: heidist
+ms.service: cognitive-search
+ms.topic: tutorial
+ms.date: 09/12/2024
+
+---
+
+# Tutorial: Search your data using a chat model (RAG in Azure AI Search)
+
+The defining characteristic of a RAG solution on Azure AI Search is sending queries to a Large Language Model (LLM) and providing a conversational search experience over your indexed content. It can be surprisingly easy if you implement just the basics.
+
+In this tutorial, you:
+
+> [!div class="checklist"]
+> - Set up clients
+> - Write instructions for the LLM
+> - Provide a query designed for LLM inputs
+> - Review results and explore next steps
+
+This tutorial builds on the previous tutorials. It assumes you have a search index created by the [indexing pipeline](tutorial-rag-build-solution-pipeline.md).
+
+## Prerequisites
+
+- [Visual Studio Code](https://code.visualstudio.com/download) with the [Python extension](https://marketplace.visualstudio.com/items?itemName=ms-python.python) and the [Jupyter package](https://pypi.org/project/jupyter/). For more information, see [Python in Visual Studio Code](https://code.visualstudio.com/docs/languages/python).
+
+- [Azure AI Search](search-create-service-portal.md), in a region shared with Azure OpenAI.
+
+- [Azure OpenAI](/azure/ai-services/openai/how-to/create-resource), with a deployment of gpt-35-turbo. For more information, see [Choose models for RAG in Azure AI Search](tutorial-rag-build-solution-models.md)
+
+## Download the sample
+
+You use the same notebook from the previous indexing pipeline tutorial. Scripts for querying the LLM follow the pipeline creation steps. If you don't already have the notebook, [download it](https://github.com/Azure-Samples/azure-search-python-samples/blob/main/Tutorial-RAG/Tutorial-rag.ipynb) from GitHub.
+
+## Configure clients for sending queries
+
+The RAG pattern in Azure AI Search is a synchronized series of connections to a search index to obtain the grounding data, followed by a connection to an LLM to formulate a response to the user's question. The same query string is used by both clients.
+
+You're setting up two clients, so you need permissions on both resources. We use API keys for this exercise. The following endpoints and keys are used for queries:
+
+```python
+# Set endpoints and API keys for Azure services
+AZURE_SEARCH_SERVICE: str = "PUT YOUR SEARCH SERVICE URL HERE"
+AZURE_SEARCH_KEY: str = "PUT YOUR SEARCH SERVICE ADMIN KEY HERE"
+AZURE_OPENAI_ACCOUNT: str = "PUT YOUR AZURE OPENAI ACCOUNT URL HERE"
+AZURE_OPENAI_KEY: str = "PUT YOUR AZURE OPENAI KEY HERE"
+```
+
+## Example script for prompt and query
+
+Here's the Python script that instantiates the clients, defines the prompt, and sets up the query. You can run this script in the notebook to generate a response from your chat model deployment.
+
+```python
+# Import libraries
+from azure.search.documents import SearchClient
+from azure.core.credentials import AzureKeyCredential
+from openai import AzureOpenAI
+
+# Set up clients and specify the chat model
+openai_client = AzureOpenAI(
+     api_version="2024-06-01",
+     azure_endpoint=AZURE_OPENAI_ACCOUNT,
+     api_key=AZURE_OPENAI_KEY
+ )
+
+deployment_name = "gpt-35-turbo"
+
+search_client = SearchClient(
+     endpoint=AZURE_SEARCH_SERVICE,
+     index_name=index_name,
+     credential=AZURE_SEARCH_CREDENTIAL
+ )
+
+# Provide instructions to the model
+GROUNDED_PROMPT="""
+You are an AI assistant that helps users learn from the information found in the source material.
+Answer the query using only the sources provided below.
+Use bullets if the answer has multiple points.
+If the answer is longer than 3 sentences, provide a summary.
+Answer ONLY with the facts listed in the list of sources below.
+If there isn't enough information below, say you don't know.
+Do not generate answers that don't use the sources below.
+Query: {query}
+Sources:\n{sources}
+"""
+
+# Provide the query. Notice it's sent to both the search engine and the LLM.
+query="how much of earth is covered by water"
+
+# Set up the search results and the chat thread.
+# Retrieve the selected fields from the search index related to the question.
+search_results = search_client.search(
+    search_text=query,
+    top=1,
+    select="title, chunk, locations"
+)
+sources_formatted = "\n".join([f'{document["title"]}:{document["chunk"]}:{document["locations"]}' for document in search_results])
+
+response = openai_client.chat.completions.create(
+    messages=[
+        {
+            "role": "user",
+            "content": GROUNDED_PROMPT.format(query=query, sources=sources_formatted)
+        }
+    ],
+    model=deployment_name
+)
+
+print(response.choices[0].message.content)
+```
+
+## Review results
+
+In this response, the answer is based on a single input (`top=1`) consisting of the one chunk determined by the search engine to be the most relevant. Instructions in the prompt tell the LLM to use only the information in the `sources`, or formatted search results. 
+
+Results from the first query`"how much of earth is covered by water"` should look similar to the following example.
+
+:::image type="content" source="media/tutorial-rag-solution/chat-results-1.png" alt-text="Screenshot of an LLM response to a simple question using a single match from search results.":::
+
+It's expected for LLMs to return different answers, even if the prompt and queries are unchanged. Your result might look very different from the example. For more information, see [Learn how to use reproducible output](/azure/ai-services/openai/how-to/reproducible-output).
+
+> [!NOTE]
+> In testing this tutorial, we saw a variety of responses, some more relevant than others. A few times, repeating the same request caused a deterioration in the response, most likely due to confusion in the chat history, possibly with the model registering the repeated requests as dissatisfaction with the generated answer. Managing chat history is out of scope for this tutorial, but including it in your application code should mitigate or even eliminate this behavior.
+
+## Add a filter
+
+Recall that you created a `locations` field using applied AI, populated with places recognized by the Entity Recognition skill. The field definition for locations includes the `filterable` attribute. Let's repeat the previous request, but this time adding a filter that selects on the term *ice* in the locations field. For more information about filtering on string collections, see [text filter fundamentals](search-filters.md#text-filter-fundamentals) and [Understand collection filters](search-query-understand-collection-filters.md).
+
+Replace the search_results definition with the following example that includes a filter:
+
+```python
+search_results = search_client.search(
+    search_text=query,
+    top=10,
+    filter="search.ismatch('ice*', 'locations', 'full', 'any')",
+    select="title, chunk, locations"
+```
+
+Results from the filtered query should now look similar to the following response.
+
+:::image type="content" source="media/tutorial-rag-solution/chat-results-filter.png" alt-text="Screenshot of an LLM response after a filter is added.":::
+
+## Change the inputs
+
+Increasing or decreasing the number of inputs to the LLM can have a large effect on the response. Try running the same query again after setting `top=3`. When you increase the inputs, the model returns different results each time, even if the query doesn't change. 
+
+Here's one example of what the model returns after increasing the inputs to 3.
+
+:::image type="content" source="media/tutorial-rag-solution/chat-results-2.png" alt-text="Screenshot of an LLM response to a simple question using a larger result set.":::
+
+Because the model is bound to just the grounding data, the answer becomes more expansive as you increase size of the input. You can use relevance tuning to potentially generate more focused answers.
+
+## Change the prompt
+
+You can also change the prompt to control the format of the output, tone, and whether you want the model to supplement the answer with its own training data by changing the prompt. 
+
+Here's another example of LLM output if we refocus the prompt.
+
+```python
+# Provide instructions to the model
+GROUNDED_PROMPT="""
+You are an AI assistant that helps users pull facts from the source material.
+Answer the query cocisely, using bulleted points.
+Answer ONLY with the facts listed in the list of sources below.
+If there isn't enough information below, say you don't know.
+Do not generate answers that don't use the sources below.
+Do not exceed 5 bullets.
+Query: {query}
+Sources:\n{sources}
+"""
+```
+
+Output from changing just the prompt, retaining `top=3` from the previous query, might look like this example. 
+
+:::image type="content" source="media/tutorial-rag-solution/chat-results-3.png" alt-text="Screenshot of an LLM response to a change in prompt composition.":::
+
+In this tutorial, assessing the quality of the answer is subjective, but since the model is working with the same results as the previous query, the answer feels less focused, and some bullets seem only tangential to a question about the surface area of water on earth. Let's try the request one last time, increasing `top=10`.
+
+:::image type="content" source="media/tutorial-rag-solution/chat-results-4.png" alt-text="Screenshot of an LLM response to a simple question using top set to 10.":::
+
+There are several observations to note:
+
+- Raising the `top` value can exhaust available quota on the model. If there's no quota, an error message is returned.
+
+- Raising the `top` value doesn't necessarily improve the outcome. The answer isn't the same as `top=3`, but it's similar. This observation underscores an important point that might be counter-intuitive to expections. Throwing more content at an LLM doesn't always yield better results.
+
+- So what might help? Typically, the answer is relevance tuning. Improving the relevance of the search results from Azure AI Search is usually the most effective approach for maximizing the utility of your LLM.
+
+In the next series of tutorials, the focus shifts to maximizing relevance and optimizing query performance for speed and concision. We revisit the schema definition and query logic to implement relevance features, but the rest of the pipeline and models remain intact.
+
+<!-- In this tutorial, learn how to send queries and prompts to a chat model for generative search. The queries that you create for a conversational search are built for prompts and the orchestration layer. The query response is fed into message prompts sent to an LLM like GPT-35-Turbo.
+
+Objective:
+
+- Set up clients for chat model and search engine, set up a prompt, point the model to search results.
+
+Key points:
+
+In a RAG app, the query request needs to:
+
+- Target searchable text (vector or nonvector) in the index
+- Return the most relevant results
+- Return any metadata necessary for citations or other client-side requirements
+
+A query request also specifies relevance options, which can include:
+
+- Scoring profile
+- L2 semantic reranking
+- Minimum thresholds
+
+- You can swap out models to see which one works best for your query. No reindexing or upstream modifications required.
+- Basic query (takeaway is prompt, scoping to grounding data, calling two clients)
+- Basic query is hybrid for the purposes of this tutorial
+- Query parent-child, one index
+- Query parent-child, two indexes
+- Filters
+
+Tasks:
+
+- H2 Set up clients and configure access (to the chat model)
+- H2 Query using text, with a filter
+- H2 Query using vectors and text-to-vector conversion at query time (not sure what the code looks like for this)
+- H2 Query parent-child two indexes (unclear how to do this, Carey said query on child, do a lookup query on parent) -->
+
+<!-- ## Next step
+
+> [!div class="nextstepaction"]
+> [Maximize relevance](tutorial-rag-build-solution-maximize-relevance.md) -->
````
</details>

### Summary

```json
{
    "modification_type": "new feature",
    "modification_title": "RAGチュートリアル: LLMを使用した検索の構築"
}
```

### Explanation
この変更は、新たに「tutorial-rag-build-solution-query.md」ファイルが追加されたことを示しています。このチュートリアルは、Azure AI Search における LLM（大規模言語モデル）を利用した検索方法を説明しています。以下は、主な内容の概要です。

1. **チュートリアルの目的**: Azure AI Search の RAG ソリューションを用いて、LLMとの対話形式でインデックス化されたコンテンツに対してクエリを送信し、情報を取得する方法を学ぶことが目的です。

2. **主要手順**:
   - クライアントを設定する。
   - LLM に対する指示を作成する。
   - LLM 入力に適したクエリを提供する。
   - 結果を確認し、次のステップを探る。

3. **前提条件**: このチュートリアルでは、前回のインデクシングパイプラインチュートリアルで作成した検索インデックスが必要です。また、Visual Studio Code、Azure AI Search、Azure OpenAI のリソースが必要です。

4. **クエリの送信**: RAG パターンでは、まず検索インデックスに接続してデータを取得し、そのデータを基に LLM に接続しユーザーの問いに応答します。このプロセスでは、両方のクライアントで同じクエリ文字列を使用します。

5. **実例スクリプト**: Python スクリプトの例が提供されており、クライアントの設定、プロンプトの定義、クエリの送信方法が示されています。このスクリプトを実行することで、LLM からの応答を生成できます。

6. **フィルタの追加**: エンティティ認識スキルを使用して作成された `locations` フィールドに基づくフィルタを追加する方法が説明されており、検索結果を特定の条件で絞り込む技術が紹介されています。

7. **入力の変更と応答の確認**: LLM への入力サイズを変更することによる応答の違いや、プロンプトの書き換えによる出力の形式やトーンの調整についても触れています。

このチュートリアルは、Azure AI Search の機能を最大限に活用して、ユーザーの質問に対して効果的に応答を生成するための重要な手法を提供しています。記事全体は以下のリンクから確認できます。
- [記事へのリンク](https://github.com/MicrosoftDocs/azure-ai-docs/blob/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Ftutorial-rag-build-solution-query.md)  
- [生のMarkdownファイルへのリンク](https://github.com/MicrosoftDocs/azure-ai-docs/raw/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Ftutorial-rag-build-solution-query.md)  

この新機能により、ユーザーは Azure AI Search を用いたインタラクティブな検索体験を構築し、LLM を駆使して情報にアクセスする方法を学ぶことができます。

## articles/search/tutorial-rag-build-solution.md{#item-c7eca4}

<details>
<summary>Diff</summary>
````diff
@@ -0,0 +1,56 @@
+---
+title: Build a RAG solution
+titleSuffix: Azure AI Search
+description: Learn how to build a generative search (RAG) app using LLMs and your proprietary grounding data in Azure AI Search.
+
+manager: nitinme
+author: HeidiSteen
+ms.author: heidist
+ms.service: cognitive-search
+ms.topic: overview
+ms.date: 09/12/2024
+
+---
+
+# How to build a RAG solution using Azure AI Search
+
+This tutorial series demonstrates a pattern for building RAG solutions on Azure AI Search. It covers the components built in Azure AI Search, dependencies, optimizations, and deployment tasks.
+
+Sample data is a [collection of PDFs](https://github.com/Azure-Samples/azure-search-sample-data/tree/main/nasa-e-book/earth_book_2019_text_pages) uploaded to Azure Storage.
+
+Sample code can be found in [this Python notebook](https://github.com/Azure-Samples/azure-search-python-samples/blob/main/Tutorial-RAG/Tutorial-rag.ipynb), but we recommend using this series for context, insights, and alternative approaches.
+
+## Exercises in this series
+
+- Choose your models for embeddings and chat
+
+- Design an index for conversational search
+
+- Design an indexing pipeline that loads, chunks, embeds, and ingests searchable content
+
+- Retrieve searchable content using queries and a chat model
+
+- Maximize relevance
+
+- Minimize storage and costs
+
+- Deploy and secure an app
+
+We omitted a few aspects of a RAG pattern to reduce complexity:
+
+- No chat history and context. Chat history must be stored and managed separately from your grounding data, which means extra steps and code. This tutorial assumes atomic question and answers from the LLM.
+
+- No per-user user access controls over results (what we refer to as "security trimming"). For more information and resources, start with [Security trimming](search-security-trimming-for-azure-search.md) and make sure to review the links at the end of the article.
+
+This series covers the fundamentals of RAG solution development. Once you understand the basics, continue with accelerators and other code samples that provide more abstraction or are otherwise better suited for production environments and more complex workloads.
+
+## Why use Azure AI Search for RAG?
+
+Chat models face constraints on the amount of data they can accept on a request. You should use Azure AI Search because the *quality* of content passed to an LLM can make or break a RAG solution. 
+
+To deliver the highest quality inputs to a chat model, Azure AI Search provides a best-in-class search engine with AI integration and comprehensive relevance tuning. The search engine supports vector similarity search (multiple algorithms), keyword search, fuzzy search, geospatial search, and filters. You can build hybrid query requests that include all of these components, and you can control how much each query contributes to the overall request.
+
+## Next step
+
+> [!div class="nextstepaction"]
+> [Choose models](tutorial-rag-build-solution-models.md)
\ No newline at end of file
````
</details>

### Summary

```json
{
    "modification_type": "new feature",
    "modification_title": "RAGソリューションの構築"
}
```

### Explanation
この変更は、新たに「tutorial-rag-build-solution.md」ファイルが追加されたことを示しています。このチュートリアルは、Azure AI Search を使用して RAG（Retrieval-Augmented Generation）アプリケーションを構築する方法を示しています。以下は、主な内容の概要です。

1. **チュートリアルの目的**: Azure AI Search を活用し、LLM（大規模言語モデル）と独自のグラウンディングデータを利用した生成検索アプリケーションの構築を学びます。

2. **内容の概要**: 
   - RAG ソリューションを構築するためのパターンや、Azure AI Search で作成されるコンポーネント、依存関係、最適化、展開タスクについて説明します。
   - サンプルデータとして、Azure Storage にアップロードされた PDF コレクションが参照されています。

3. **演習内容**:
   - 埋め込みとチャットのためのモデルの選択
   - 対話型検索のためのインデックス設計
   - 検索可能なコンテンツをロード、チャンク処理、埋め込み、取り込みを行うインデクシングパイプライン設計
   - クエリとチャットモデルを使用した検索可能なコンテンツの取得
   - 関連性の最大化
   - ストレージとコストの最小化
   - アプリの展開とセキュリティ

4. **省略された点**: チュートリアルでは、チャット履歴の管理やユーザー別のアクセス制御（セキュリティトリミング）が省略されており、シンプルな質問と回答形式を前提としています。これによって、より簡潔な説明を実現しています。

5. **Azure AI Search の利点**: Azure AI Search を使用することにより、LLM に渡すコンテンツの質を高め、より良い RAG ソリューションを実現します。高品質な入力を提供するための先進的な検索エンジンと AI 統合、包括的な関連性調整機能が強調されています。

このチュートリアルシリーズは、RAG ソリューションの開発 fundamentals をカバーしており、基礎を理解した後は、より抽象的な内容や本番環境および複雑なワークロードに最適なコードサンプルへ進むことが推奨されています。記事全体は以下のリンクから確認できます。
- [記事へのリンク](https://github.com/MicrosoftDocs/azure-ai-docs/blob/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Ftutorial-rag-build-solution.md)  
- [生のMarkdownファイルへのリンク](https://github.com/MicrosoftDocs/azure-ai-docs/raw/41463e4d9e2a419c80544fb376cb79a91498dc23/articles%2Fsearch%2Ftutorial-rag-build-solution.md) 

この新機能により、ユーザーは RAG ソリューションの構築に必要な基本的な手法を学ぶことができ、実用に向けた次のステップへと進むことができるようになります。


